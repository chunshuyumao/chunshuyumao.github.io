<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>用 VIM 写 Markdown</title>
    <link href="/2023/05/13/write-markdown-with-vim/"/>
    <url>/2023/05/13/write-markdown-with-vim/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>这是第 n次写这篇博客了。前面都是写了几次之后又删掉，因为主题不明，终于也有觉得自己写作主题不明的那天了。其实这篇文章也不全是关于VIM，因为我确实不好定性。</p><p>以前自己使用的 Markdown 编辑器是 <a href="https://typoraio.cn"title="Typora">Typora</a>，不得不说，Typora是真的优雅。虽然自己不再使用，但尝试过其他编辑器后，总是觉得没有一款可以比得上Typora。</p><p>Typora 收费后各种替代品涌现，打算占据这片高地，比较有名的是 <ahref="https://github.com/marktext/marktext"title="MarkText">MarkText</a>。可惜有些东西还真替代不了，虽然 MarkText真的很简洁，走了 Typora 风格，但是使用起来总觉得不够丝滑。</p><p>我还使用过 <a href="https://zettlr.org"title="Zettlr">Zettlr</a>，主要用于论文写作，因为 Typora不支持文献引用。后面 Zettlr 出现小bug，导致表格录入的数据都无法保存。这个问题很快就被修复了，但是当时我正在赶论文，根本没有时间等待，直接使用VIM 写。</p><p>俺是万万没想到，原来 VIM 写 Markdown 一样可以很顺手。当时不知道 <ahref="https://retorque.re/zotero-better-bibtex/"title="Bettle BibText">Better BibText</a> 可以直接在 VIM 内调用 Zotero的引用框，为了完成文献的插入，我用 vimscript，VIM的脚本语言，写了一个引用文献的脚本，然后完成了自己的论文。</p><p>事后想想，好像没有使用 Zettlr的道理了：原本它的优势是文献引用，现在自己写了一个小脚本也解决问题了。此外，当时为了交叉引用引入新语法，Zettlr也渲染不了，于是我就彻底抛弃 Zettlr 扎根 VIM。</p><p>使用 VIM 写作还是碰到了很多问题，很多都是自己并不完全了解 VIM导致的，但有些问题 VIM到现在还是没有解决。这也是我写这篇博客的原因：把自己碰到的一些问题总结到一起。</p><h1 id="用-vim-写-markdown">用 VIM 写 Markdown</h1><h2 id="物理行和逻辑行">物理行和逻辑行</h2><p>物理行指的是没有回车符断开的一行，或者叫做“段落”，逻辑行指的是段落内部可以分成的行。这很抽象，下面一张图解释一下物理行和逻辑行：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230513/20230513150009.png"alt="物理行和逻辑行" /></p><p>上图中，第 50、54 行属于物理行，一般只占一（逻辑）行。第 46、48行也是物理行，但是由于字数太多进行了段内分行，所以出现了逻辑行。简而言之，图片中标有行号的就是物理行。</p><p>逻辑行的行数是随着窗口大小改变的，比如我把窗口变大之后，逻辑行就变少了，因为一行可以容纳的字符变多了。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230513/20230513150313.png"alt="逻辑行变少了" /></p><p>一般的编辑器不区分物理行和逻辑行，也就是光标或者鼠标把肉眼能见到的行，都算作一行，不幸的是VIM 不这样。</p><p>VIM 的 j 和 k 是物理行的移动，逻辑行使用 <code>gj</code> 和<code>gk</code>。写文章的时候，一行包含的字符太多是没法用<code>j</code>、<code>k</code> 进行逻辑行移动的。</p><p>举个例子：上面第一张图，想要从第 46行的“镜像之后”移动到下面的“但是可以”。其他编辑器最笨也可以使用方向键往下移动，但是VIM 使用方向键或者 <code>j</code> 就会直接跳到第 47行，要移动到下一逻辑行必须使用 <code>gj</code> 或者<code>g&lt;Down&gt;</code>，否则就需要使用 <code>l</code>键一直往右移动，直到碰到自己想到的位置。</p><p>使用 <code>gj</code>也不是不行，只是需要敲两次按键，对我们来说太麻烦了。解决办法是使用 VIM的按键映射（map）。在 VIM 配置文件 <code>~/.vimrc</code> 添加：</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">nnoremap</span> <span class="hljs-symbol">&lt;silent&gt;</span> <span class="hljs-keyword">j</span> gj<br><span class="hljs-keyword">nnoremap</span> <span class="hljs-symbol">&lt;silent&gt;</span> <span class="hljs-keyword">k</span> gk<br><span class="hljs-keyword">nnoremap</span> <span class="hljs-symbol">&lt;silent&gt;</span> <span class="hljs-symbol">&lt;Up&gt;</span> g<span class="hljs-symbol">&lt;Up&gt;</span><br><span class="hljs-keyword">nnoremap</span> <span class="hljs-symbol">&lt;silent&gt;</span> <span class="hljs-symbol">&lt;Down&gt;</span> g<span class="hljs-symbol">&lt;Down&gt;</span><br><span class="hljs-keyword">nnoremap</span> <span class="hljs-symbol">&lt;silent&gt;</span> gj <span class="hljs-keyword">j</span><br><span class="hljs-keyword">nnoremap</span> <span class="hljs-symbol">&lt;silent&gt;</span> gk <span class="hljs-keyword">k</span><br><span class="hljs-keyword">nnoremap</span> <span class="hljs-symbol">&lt;silent&gt;</span> g<span class="hljs-symbol">&lt;Up&gt;</span> <span class="hljs-symbol">&lt;Up&gt;</span><br><span class="hljs-keyword">nnoremap</span> <span class="hljs-symbol">&lt;silent&gt;</span> g<span class="hljs-symbol">&lt;Down&gt;</span> <span class="hljs-symbol">&lt;Down&gt;</span><br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230513/20230513152439.png"alt="重新映射按键" /></p><p>上面是把两种按键对换了：物理行使用 <code>gj</code> 和 <code>gk</code>、<code>g&lt;Up&gt;</code> 和 <code>g&lt;Down&gt;</code>进行移动，逻辑行使用 <code>j</code> 和 <code>k</code>或者方向键即可。</p><p>至于为什么使用的是 <code>nnoremap</code> 而不是简单的<code>map</code>，这得涉及到 VIM的一些语法，一两句话说不清。<code>nnoremap</code> 是<code>normal not recursivelly map</code>的缩写，表示普通模式下对按键进行非递归映射。</p><h2 id="长段落">长段落</h2><p>第一个问题，物理行和逻辑行解决了，但是没有彻底解决：它只是解决了如何在物理行和逻辑行直接移动，没有解决逻辑行和物理行的问题。</p><p>物理行指的是一个段落，为方便叙述统一使用“段落”替代，请看下面的物理行：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230513/20230513160025.png"alt="长长的物理行" /></p><p>在段落里移动只能使用 <code>h</code> 和 <code>l</code>，因为 VIM最引以为豪的文本对象（text-object）对东亚文字不起作用。英语或者说拉丁字母的词是通过空格来区分的，但是中文、韩文、日文、喃字、字生（中日韩越壮字符）是没有空格的。</p><p>VIM 可以使用 <code>w</code> 进行字词的移动，或者 <code>f</code>快速跳转，那是借助了拉丁文字的空格判断。中文没有空格，这些文本操作只能识别标点符号。所以上面那些长长的段落，在VIM 中只能非常笨拙地一个字符一个字符移动。</p><p>至于解决办法，没有，VIM 到现在都没有解决这个问题。</p><p>不过使用 Markdown 就有点好处了。Markdown有一条规则：回车符不是分段的标志，空行才是段落的标志。举个例子：</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">不过使用 Markdown 就有点好处了。Markdown 有一条规则：回车符不是分段的标志，空<br>行才是段落的标志。举个例子：<br></code></pre></div></td></tr></table></figure><p>看起来是两行，毕竟有一个回车嘛，在“空”之后。但 Markdown中，这被当作一行看待， Markdown会把这两行合成一个段落，然后在两行之间添加一个空格，对于拉丁文字来说很方便。渲染后成为：</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">不过使用 Markdown 就有点好处了。Markdown 有一条规则：回车符不是分段的标志，空 行才是段落的标志。举个例子：<br></code></pre></div></td></tr></table></figure><p>那 Markdown 如何插入一个真正的段落？使用一个空行就行：</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">不过使用 Markdown 就有点好处了。Markdown 有一条规则：回车符不是分段的标志，空<br><br>行才是段落的标志。举个例子：<br></code></pre></div></td></tr></table></figure><p>正是 Markdown 的特性，我们不用让 VIM的段落太长，可以在自己想要断开的地方断开，反正渲染之后都会被当作一行对待。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230513/20230513162005.png"alt="直接在一定字数后断开，不必一行内全写整个段落" /></p><p>那应该在哪里断开？写代码一般都会有个不成文的规定：一行代码的字符数不多于78 个。所以我们可以限定自己的一段只有 78个字符。写文章的时候不可能去数自己一行到底写了多少字符，可以用 VIM的功能辅助：<code>colorcolumn</code>。</p><p><code>colorcolumn</code>可以高亮特定的列。如果我们希望自己的字符数不超过 78 这个列，可以在<code>~/.vimrc</code> 配置文件中添加<code>set colorcolumn=79</code>。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230513/20230513162605.gif"alt="高亮第 79 列，字数超过这列就断行" /></p><p>这样，只要写到这一列就可以换行了。上面的配色有点难看，但只是为了演示。</p><p>上面说了，Markdown会把回车断开的行拼成一个段落，然后在它们之间添加一个空格。问题就出在这里了：添加一个空格。对拉丁文字来说好处多多，毕竟这样就不用在分段的地方添加空格，但是对中文来说就多了一个不必要的空格。例如在<code>回</code> 之后分段，下一个字符是 <code>家</code>，合并成一行后成为<code>回 家</code>。</p><p>这个解决办法还算简单：使用 Pandoc 的功能。Pandoc 扩展里有一个<code>east_asian_line_breaks</code>功能，可以自动判断如果是东亚字符就不添加空格。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230513/20230513163705.png"alt="东亚文字断行" /></p><p>想要使用这个功能需要如此：</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">pandoc -f markdown+east_asian_line_breaks -t docx paper.md<br></code></pre></div></td></tr></table></figure><p>或者在 YAML 配置中输入：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">from:</span> <span class="hljs-string">markdown+east_asian_line_breaks</span><br><span class="hljs-comment"># 或者</span><br><span class="hljs-attr">reader:</span> <span class="hljs-string">markdown+east_asian_line_breaks</span><br></code></pre></div></td></tr></table></figure><p>下面是使用这个扩展和不使用的效果展示：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230513/20230513164646.png"alt="原始文件，一个段落分两行" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230513/20230513165034.png"alt="不使用 east_asian_line_breaks 扩展，可以看到“一”和“点”之间有空格" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230513/20230513164919.png"alt="使用 east_asian_line_breaks 扩展，“一”和“点”之间的空格没有了" /></p><p>至此，好像解决了逻辑行和物理行的问题了</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230513/20230513165311.png"alt="看看这篇文章的效果" /></p><h2 id="空格">空格</h2><p>写作的时候经常会碰到中英文混合输入。一般而言，如果碰到这种情况，应该在中英文之间保留一个空格— 中文、英文和阿拉伯数字之间应该有空格。</p><p>不过一般是看不到这些控制符号的。有些时候写的太快忘了在中英文之间放空格，回头检查就很麻烦。可以给空格、制表符等这类控制符一个标识，这样检查时就能一眼看出。比如下图使用一个点号（·）代替空格（可视化），检查的时候可以一眼看出空格在哪里：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230513/20230513154337.png"alt="空格使用一个点号替代" /></p><p>上图中出现了一个中文句号后接英文（<code>nnoremap</code>），它们之间是没有空格的，那里出现空白只是因为中文句号是全角符号，占用两格。如果不让空格可视化，我们可能以为是一个英文标点加一个空格— 没错，我改论文的时候被这东西害惨了。</p><p>可视化的方式是在 <code>~/.virmc</code> 配置文件添加：</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">set</span> listchars=space:·<br></code></pre></div></td></tr></table></figure><p>同理还可以设置其他的控制符，例如 <code>Tabular</code> 这类，可以在VIM 中输入 <code>:help listchars</code> 回车查看。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230513/20230513155301.png"alt="listchars 可以设置的部分" /></p><h2 id="平滑滚动">平滑滚动</h2><p>还是物理行和逻辑行的衍生问题：因为 VIM只认物理行，所以滚动的时候会出现这种问题：如果一行很长，例如JavaScript、JSON 文件，那滚动非常难受。</p><p>比如下面的演示：长段落滚动直接整段消失，重新绘制，太变态了。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230513/20230513165912.gif"alt="不设置平滑滚动" /></p><p>同样是上面的例子，这次看下图。这种时候，长段落不会整段消失，而是尽量铺满屏幕，用<code>&lt;&lt;&lt;</code> 表示和上面的文字是一个段落。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230513/20230513170335.png"alt="平滑滚动" /></p><p>这就是“平滑滚动”，在 <code>~/.vimrc</code> 中添加<code>set smoothscroll</code> 即可。</p><h2 id="使用-vim-的过滤功能filter">使用 VIM 的过滤功能（Filter）</h2><p>过滤功能（Filter）其实翻译不是很准确，本质上就是文本和外部命令的交互。VIM中可以通过 <code>!</code> 与调用外部命令。举个例子，在命令行模式输入<code>:!ls</code> 就可以列出当前文件所在目录下的所有文件了：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230513/20230513194753.gif"alt="使用过滤功能列出当前文件所在目录的所有文件" /></p><p>然后 VIM还可以把文件的文本传出去，调用外部命令处理。例如我要在下面随机生成 10 个100 以内的整数，然后再从大到小排序。可以写下 Python 代码，再传给外部Python 处理：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230513/20230513195712.gif"alt="生成随机数" /></p><p>这个示例调用了 Python 和 Linux 的 <code>sort</code>命令。选择范围我做了两次演示：第一次是使用行数范围，从第 257 到第259行；第二次是使用可视（块）模式，直接选定区域。</p><p>不过对于很多人来说，这可能没什么用，毕竟写代码的人才会意淫这种用法，是吧？其实不然，举个例子，我现在要画一个图，只需要在Markdown 内写下这个图的流程，然后调用外部命令处理即可：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230513/20230513200609.gif"alt="演示画图" /></p><p>上面使用的命令是<code>&#123;range&#125;w !&#123;command&#125;</code>：想看自己写的画图代码如何，只需要传出代码，不需要读入，所以使用<code>w !&#123;comamnd&#125;</code>（write），如果只是读入则使用<code>r !&#123;command&#125;</code>（read），传出又读入使用<code>!&#123;command&#125;</code>。</p><p>觉得画得不错，可以在当前目录直接生成图片<code>test.png</code>，然后引用：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230513/20230513201038.gif"alt="生成并引用图片" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230513/test.png"alt="生成的图片" /></p><p>何如？这其实有点像 VS Code 的 <code>Code Runner</code>（好像是这个名字，忘了），但是更灵活。</p><p>没办法，字数有点多了，下次再写。</p><h1 id="后语">后语</h1><p>其实之前我想写写自己写的 Zotero 引用插件，但是那时候使用 vimscript比较年轻，有点迷信 Lambda 表达式，导致自己的代码充斥着大量的 Lambda表达式，后面自己都看不懂。</p><p>下面可以看看我之前写的Lambda，都要走火入魔了。因为自己也看不懂代码，所以就一直没写。主要是那时候以我的知识知道，调用函数其实会拖慢速度，觉得Lambda 可能快一点，其实也不然。最近用 vim9script对自己的插件进行了重构（高大上的词），可能会真的写一篇文章讲讲 VIM的插件怎么写。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230513/20230513202246.png"alt="上古时代还年轻，大量使用 Lambda 表达式" /></p>]]></content>
    
    
    <categories>
      
      <category>VIM</category>
      
      <category>Markdown</category>
      
      <category>Pandoc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
      <tag>Pandoc</tag>
      
      <tag>VIM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安装 RoseTTAFold</title>
    <link href="/2023/04/30/installation-of-rosettafold/"/>
    <url>/2023/04/30/installation-of-rosettafold/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>RoseTTAFold 是华盛顿大学（University of Washington）Divid Baker团队开发的一个蛋白质结构预测工具<span class="citation"data-cites="AccuratePredictionProtein2021"><sup>[<ahref="#ref-AccuratePredictionProtein2021"role="doc-biblioref">1</a>]</sup></span>，2021年在《科学》（<em>Science</em>）杂志发表。RoseTTAFold基于三轨神经网络（3-Track neuralnetwork），预测可兼顾蛋白质序列模式、蛋白质内氨基酸相互作用和蛋白质可能的三维结构。</p><p>RoseTTAFold 开源，可到 GitHub下载代码源码在本地搭建，也可在网上使用。Baker团队搭建了一个在线版本，可以到 <a href="https://robetta.bakerlab.org/"title="RoseTTAFold server">RoseTTAFold server</a> 体验。</p><p>打开浏览器输入提供的网址，然后在左上角选择 Structure Prediction下拉菜单。下拉菜单有三个选项：</p><ul><li>提交（Submit）。提交要预测蛋白的序列，需要注册，我讨厌注册。</li><li>Queue（队列）。查看提交预测的队列，提交线上预测的人很多得排队。</li><li>示例结果（Example Result）。展示预测蛋白的五个结果 3D 模型。</li></ul><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230430/20230430122158.png"alt="RoseTTAFold server 使用" /></p><p>线上版本是免费的，全世界很多人都在排队使用，有条件可以选择本地搭建。</p><h1 id="rosettafold-本地搭建">RoseTTAFold 本地搭建</h1><h2 id="准备">准备</h2><p>RoseTTAFold 源码是开源的，可以直接到 GitHub下载。不过在开始之前我还是要说说本地搭建的要求：</p><ol type="1"><li>一台 Linux电脑。开虚拟机可能不行，因为这种运算，虚拟机太慢了，最好还是实体 Linux机，或可以使用 Windows 系统的 <ahref="https://learn.microsoft.com/zh-cn/windows/wsl/install"title="WSL">WSL</a>（Windows Subsystem of Linux，Windows 的 Linux子系统）。</li><li>8G 内存。这是可以分配给 RoseTTAFold的内存，不是电脑内存，建议电脑内存 8G 以上。我只试过源码自带示例在 8G、64G 和 128G 内存跑 PyRosetta。当然，跑的都是 8核，结果区别好像不大。8G 和 128G 都是 40 分钟左右，64G没有单独做过，但是所有的测试都是 64G做的，所以大差不差也是这个时间。反正一个小时应该是基本要求。生物嘛，一个小时很短的。</li><li>2.6T 磁盘空间。RoseTTAFold源码很小，但需要下载的模板和数据库压缩包有 402G，解压后有 2263.2G，即2.3T。系统安装、解压后删除压缩包、安装 <ahref="https://docs.conda.io/projects/conda/en/stable/index.html"title="Conda">conda</a>，还保存一些数据，300G只能算还过得去。所以整个电脑得有 2.6T 磁盘空间。</li><li>电脑安装 conda/mamba。电脑安装的可以是 <ahref="https://docs.conda.io/en/latest/miniconda.html"title="Miniconda">minconda</a>、 <a href="https://anaconda.org"title="Anaconda">anaconda</a>。安装完之后可以安装 <ahref="https://mamba.readthedocs.io/en/latest/user_guide/mamba.html"title="Mamba">mamba</a> 作为 conda 的替代命令。</li></ol><p>综上，如果要安装到自己电脑，需要花几个钱扩充一下硬盘空间。</p><p>我的建议是，有需要可以搭建，但自己电脑不行就不必勉强。可以询问自己的导师或者老师，看看学院有没有服务器。学校的服务器一般都很富裕。生信学生，一般学院都有服务器，毕竟生信做数据分析少不了。可能有的学校没有生信专业，所以还真没有服务器。</p><p>又或者，实验室有这个需求，可以问问老师，毕竟花个几百块钱买个硬盘不比动不动就几千上万的实验仪器便宜？RoseTTAFold比较高的要求无非就是 Nvidia（英伟达） GPU（Graphical processingunit）和硬盘。前者可以不用，直接 CPU （Central processingunit）跑，后者现在还不算贵。至于内存，我觉得问题应该不大，实在不够可以花百十大洋买个内存条。</p><p>Linux系统安装我就不演示了，这种教程我大清满大街都是，随便搜搜，或者可以翻我之前的博客。如果是学院、学校服务器就省了系统安装这一步。</p><h2 id="下载源码">下载源码</h2><p>到 <a href="https://github.com/RosettaCommons/RoseTTAFold"title="RoseTTAFold GitHub">RoseTTAFold GitHub</a> 主页查看如何下载。</p><p>如果使用 <a href="https://git-scm.com" title="Git">Git</a>下载源码，请确保自己的电脑安装了 Git。默认安装了 conda/mamba。</p><blockquote><p>安装 conda/mamba 可以参考之前的博客<ahref="https://chunshuyumao.github.io/2022/03/18/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85RStudio-Server/">服务器安装RStudio Server</a></p><p>友情提示：conda 一定要换源，不然时间耗死你。最好安装 mamba 替代conda</p></blockquote><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230430/20230430095355.png"alt="RoseTTAFold GitHub 主页的安装教程" /></p><p>按照 GitHub上的提示进行安装。当然，如果一帆风顺就不会有今天这篇文章了。</p><h3 id="克隆clone源码">克隆（Clone）源码</h3><p>使用 Git 克隆</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">$ <span class="hljs-built_in">pwd</span><br>/home/chunshuyumao/Downloads<br>$ git <span class="hljs-built_in">clone</span> https://github.com/RosettaCommons/RoseTTAFold.git<br>...<br>$ <span class="hljs-built_in">cd</span> RoseTTAFold<br>$ <span class="hljs-built_in">pwd</span><br>/home/chunshuyumao/Downloads/RoseTTAFold<br></code></pre></div></td></tr></table></figure><h3 id="创建环境">创建环境</h3><p>创建环境有两个选择：</p><ul><li>RoseTTAFold-linux.yml。Nvidia 卡支持的 Cuda 在 10 以上，一般是11。</li><li>RoseTTAFold-linux-cuda10.yml。Nvidia 卡支持的 Cuda 在 10及以下。</li></ul><p>如果太复杂，直接选择第一个。其实这个主要是看你的电脑有没有 Nvidia卡，Linux 命令行输入 <code>lspci | grep -i vga</code>。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ lspci | grep -i vga<br>02:00.0 VGA compatible controller: Matrox Electronics Systems Ltd. MGA G200e [Pilot] ServerEngines (SEP1) (rev 42)<br></code></pre></div></td></tr></table></figure><p>上面的输出显示根本没有 Nvidia 卡。直接使用第一个创建环境算了。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">pwd</span><br>/home/chunshuyumao/Downloads/RoseTTAFold<br>$ conda <span class="hljs-built_in">env</span> create -f RoseTTAFold-linux.yml<br></code></pre></div></td></tr></table></figure><p>创建完环境后，自己的 conda/mamba 下会有一个叫做 RoseTTAFold的环境，可以使用 <code>conda env list</code> 查看。</p><p>安装完之后还有一个可选的 folding-linux.yml 环境，使用 <ahref="https://pyrosetta.org/" title="PyRosetta">PyRosetta</a>预测蛋白结构需要。RoseTTAFold提供两种方式预测蛋白结构，一种是基于“点到点”（end-to-end,e2e）的方式，另一种是基于PyRosetta。前者的预测效果可能不比后者。</p><p>使用 PyRosetta，我后面会介绍，就需要创建 folding环境，只使用“点到点”的方式就不需要。</p><p>创建两个环境有点久，分别有 2G 左右。创建完毕查看当前环境：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ conda <span class="hljs-built_in">env</span> list<br><span class="hljs-comment"># conda environments:</span><br><span class="hljs-comment">#</span><br>base                     /home/chunshuyumao/.local/miniconda3<br>RoseTTAFold              /home/chunshuyumao/.local/miniconda3/envs/RoseTTAFold<br>folding                  /home/chunshuyumao/.local/miniconda3/envs/folding<br></code></pre></div></td></tr></table></figure><h3 id="下载第三方软件">下载第三方软件</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">pwd</span><br>/home/chunshuyumao/Downloads/RoseTTAFold<br>$ ./install_dependencies.sh<br></code></pre></div></td></tr></table></figure><p>这个几个第三方包不大，下载很快。</p><h3 id="下载数据包">下载数据包</h3><p>创建 RoseTTAFold 环境的时候，可以再开一个控制台下载需要的数据包。按照GitHub 上的 README.md 下载和解压即可。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">pwd</span><br>/home/chunshuyumao/Downloads/RoseTTAFold<br>$ <span class="hljs-comment"># 解压有 1.2 G</span><br>$ wget -c https://files.ipd.uw.edu/pub/RoseTTAFold/weights.tar.gz<br>$ tar -zx -f weights.tar.gz<br><br>$ <span class="hljs-comment"># uniref30 [46G]，解压有 182G</span><br>$ wget -c http://wwwuser.gwdg.de/~compbiol/uniclust/2020_06/UniRef30_2020_06_hhsuite.tar.gz<br>$ <span class="hljs-built_in">mkdir</span> -pv UniRef30_2020_06<br><span class="hljs-built_in">mkdir</span>: created directory <span class="hljs-string">&#x27;/home/chunshuyumao/Downloads/RoseTTAFold/UniRef30_2020_06&#x27;</span><br>$ tar -zx -f UniRef30_2020_06_hhsuite.tar.gz -C ./UniRef30_2020_06<br><br>$ <span class="hljs-comment"># BFD [272G]，解压有 1.8T</span><br>$ wget -c https://bfd.mmseqs.com/bfd_metaclust_clu_complete_id30_c90_final_seq.sorted_opt.tar.gz<br>$ <span class="hljs-built_in">mkdir</span> -pv bfd<br><span class="hljs-built_in">mkdir</span>: created directory <span class="hljs-string">&#x27;/home/chunshuyumao/Downloads/RoseTTAFold/bfd&#x27;</span><br>$ tar -zx -f bfd_metaclust_clu_complete_id30_c90_final_seq.sorted_opt.tar.gz -C ./bfd<br><br><span class="hljs-comment"># structure templates (including *_a3m.ffdata, *_a3m.ffindex) [over 100G]，解压有 280G</span><br>$ wget -c https://files.ipd.uw.edu/pub/RoseTTAFold/pdb100_2021Mar03.tar.gz<br>$ tar -zx -f pdb100_2021Mar03.tar.gz<br></code></pre></div></td></tr></table></figure><p>这几个文件下载的速度只能看命运了，可能晚上下载的速度快一点。上面的<code>wget</code> 命令和 README.md 不大一样，多了一个 <code>-c</code>命令。这是 <code>--continue</code>的缩写，最好加上，相信我，不然你会等到死。</p><h3 id="下载-pyrosetta可选">下载 PyRosetta（可选）</h3><p>如果不想使用 PyRosetta，可以不进行这一步。当然，这也就意味着源码中的<code>run_pyrosetta_ver.sh</code> 你无法使用。</p><h4 id="注册获取账户和密码">注册获取账户和密码</h4><p>要使用 PyRosetta 需要注册一个账号。到<ahref="https://els2.comotion.uw.edu/product/pyrosetta"title="PyRosetta in UW">华盛顿大学</a>下载。根据我给的网址进入，可以看到如下界面。点击右下角的ORDER NOW 即可。ORDER 后进入确认界面，再次点击 CHECKOUTNOW，进入登陆界面。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230430/20230430103414.png"alt="到华盛顿大学软件下载界面下载 PyRosetta" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230430/20230430103528.png"alt="确认购买，购买不需要钱，因为可以免费使用。点击 CHECKOUT NOW" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230430/20230430103719.png"alt="登陆界面" /></p><p>如果没有账号，可以现场创建一个账号，选择Register。后面的步骤就比较简单了，填写一下个人信息，至于地址机构什么的，随便填吧。后面根据邮件确认信息，然后会收到一封邮件。邮件里有自己可以使用的用户和密码，记住即可。</p><h4 id="安装-pyrosetta">安装 PyRosetta</h4><p>打开 conda 配置文件 <code>~/.condarc</code>。这一步可以参考 PyRosetta<a href="https://www.pyrosetta.org/downloads"title="PyRosetta Installation">安装教程</a>。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230430/20230430110137.png"alt="官网安装教程" /></p><p>下面是我的 conda配置，这是换源过后的。<code>remote_read_timeout_secs: 600.0</code> 设置conda 下载超时时间 600秒。因为是国外的软件下载速度肯定不好，所以超时时间可以设置久一点。</p><p>把自己注册后收到的密码和用户名填入下面的 PASSWD 和 USERNAME。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> ~/.condarc<br>show_channel_urls: <span class="hljs-literal">true</span><br>  default_channels:<br>    <span class="hljs-comment">#- https://USERNAME:PASSWD@conda.rosettacommons.org</span><br>    - https://USERNAME:PASSWD@conda.graylab.jhu.edu<br>    - https://mirrors.aliyun.com/anaconda/pkgs/main<br>    - https://mirrors.aliyun.com/anaconda/pkgs/r<br>    - https://mirrors.aliyun.com/anaconda/pkgs/free<br>    - https://mirrors.aliyun.com/anaconda/pkgs/msys2<br><br>  custom_channels:<br>    conda-forge: https://mirrors.aliyun.com/anaconda/cloud<br>    msys2: https://mirrors.aliyun.com/anaconda/cloud<br>    bioconda: https://mirrors.aliyun.com/anaconda/cloud<br>    menpo: https://mirrors.aliyun.com/anaconda/cloud<br>    pytorch: https://mirrors.aliyun.com/anaconda/cloud<br>    simpleitk: https://mirrors.aliyun.com/anaconda/cloud<br><br>auto_activate_base: <span class="hljs-literal">false</span><br>remote_read_timeout_secs: 600.0 <br></code></pre></div></td></tr></table></figure><p>设置好之后在命令行中输入：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ conda activate folding<br>$ conda install pyrosetta -y<br></code></pre></div></td></tr></table></figure><p>下载过程难免有多次失败，因为网络不行。如果想做到无人值守安装，可以将上面的安装命令改成：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ conda activate folding<br>$ <span class="hljs-keyword">while</span> ! conda install pyrosetta -y; <span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;Try again...&#x27;</span>; <span class="hljs-keyword">done</span><br></code></pre></div></td></tr></table></figure><p>这样如果下载失败，电脑会自动帮你恢复安装，直到安装成功或者你放弃。注意，如果是自己的电脑，那千万不要让电脑休眠（Suspend）。如果是服务器，可以使用<a href="https://github.com/tmux/tmux/wiki" title="tmux wiki">Tmux</a>连接服务器，然后后台运行。这是一个大话题，此处不进行解释。</p><p>如果安装成功，那就万事大吉了。</p><h2 id="运行示例">运行示例</h2><p>安装完成就可以运行示例了，可以参考 RoseTTAFold 文件下的 README.md文件。</p><p>首先进入 <code>example</code> 文件夹，然后运行<code>run_pyrosetta_ver.sh</code> 或者<code>run_e2e_ver.sh</code>。注意，没有安装 PyRosetta 软件就只能运行<code>run_e2e_ver.sh</code> 脚本。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">pwd</span><br>/home/chunshuyumao/Downloads/RoseTTAFold<br>$ <span class="hljs-built_in">cd</span> example<br>$ <span class="hljs-built_in">mkdir</span> -pv mytest<br>$ ../run_pyrosetta_ver.sh input.fa mytest<br></code></pre></div></td></tr></table></figure><p>所有的输出文件都会放到 mytest 文件夹内，也可以把 input.fa换成自己的蛋白质序列。</p><h3 id="输出结果">输出结果</h3><h4 id="end-to-end">end-to-end</h4><p>结果会产生一个 PDB（Protein Data Bank）文件，文件放到输出目录的 model文件夹内。例如我上面运行的输出目录是 <code>mytest</code>，所以 PDB文件在 <code>mytest/model</code> 内。</p><h4 id="pyrosetta">PyRosetta</h4><p>运行会产生 5 个模型文件，放到输出目录的 <code>model</code>文件夹内，命名规则是<code>model_[1-5].crderr.pdb</code>，头部包含一些误差信息，可以不用在意直接当作PDB 文件使用。</p><h3 id="输出结果可视化">输出结果可视化</h3><p>输出结果是文件，怎么可视化查看？可以去 <a href="https://rcsb.org"title="RCSB">RCSB</a> 查看。</p><p>浏览器打开 RCSB，选择“可视化”（Visualize）中的Mol*（MolStar）进行可视化。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230430/20230430112202.png"alt="RCSB 网站选择“可视化”（Visualize）中的 Mol* 进行可视化" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230430/20230430112338.png"alt="点击右上角的“选择文件”（Select files...），添加自己的 PDB 文件，添加完毕选择“应用”（Apply）即可" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230430/20230430113548.png"alt="可视化结果" /></p><p>至此，安装完成。马克思保佑！</p><h2 id="一些问题">一些问题</h2><h3 id="mul__-属性不存在">__mul__ 属性不存在</h3><blockquote><p>While processing/home/chunshuyumao/Downloads/RoseTTAFold/example/mytest/pdb-3track/model0_1_0.05.features.npz:'pyrosetta.rosetta.utility.graph.EdgeListConstItera' object has noattribute '__mul__'</p></blockquote><p>按照官网的步骤搭建本地 PyRosetta，运行完后 model文件夹内什么也没有。找到输出目录下的 log文件夹，里边是程序输出的日志文件。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230430/20230430114206.png"alt="查看日志，每一步都有输出" /></p><p>以 <code>stderr</code> 结尾的是错误日志，<code>stdout</code>结尾的是输出日志。一般来说先看错误日志，然后再看输出日志。</p><p>查看 <code>run_pyrosetta_ver.sh</code>文件可以看到脚本的运行顺序是：</p><ol type="1"><li>生成 MSA 文件，日志记录在 make_msa.std[err,out]；</li><li>运行次级结构，日志记录在 make_ss.std[err,out]；</li><li>查找模板文件，日志记录在 hhsearch.std[err,out]；</li><li>预测距离和方向，日志记录在 network.std[err,out]；</li><li>生成模型，日志记录在 folding.std[err,out]；</li><li>择取最终模型。分成两步：<ol type="1"><li>如果没有生成 NPZ 文件则先生成，日志记录在DAN_msa.std[err,out]；</li><li>择取最终模型，日志记录在 pick.std[err,out]。</li></ol></li></ol><p>看看问题出在哪里：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230430/20230430144124.png"alt="生成 NPZ 文件的步骤似乎有问题，DAN_msa.stderr" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230430/20230430144319.png"alt="DAN_msa.stdout 好像也有问题" /></p><p>不要看 DAN_msa.stderr就觉得它的问题严重性更强，其实不是，得通过报错信息来判断。其实DAN_msa.stderr只是发出了警告，不是错误。在程序员眼中，警告（Warning）并不是错误，大写也没用。</p><blockquote><p>有个笑话：公路尽头是悬崖，警察在路口贴了一个警告牌，结果还是有人开车掉下去死了。警察一看，好家伙，原来是个程序员，他以为“警告”（WARNING）不是什么大问题，毕竟又不是“错误”（ERROR）。</p></blockquote><p>这个警告不是程序出错的原因，再看 DAN_msa.stdout 文件。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">While processing /home/chunshuyumao/Downloads/RoseTTAFold/example/mytest/pdb-3track/model0_1_0<span class="hljs-number">.05</span>.features.npz: <span class="hljs-string">&#x27;pyrosetta.rosetta.utility.graph.EdgeListConstItera&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;__mul__&#x27;</span><br></code></pre></div></td></tr></table></figure><p>文件一直出现这个提示。其实这很让人费解，这是一个错误很明显，但是我不知道是哪里出现的问题。一个错误提示什么也没有，没有说哪个文件出了问题，没有说哪一行出了错误，也没说在干什么，只是说：俺在处理某某文件的时候发现某某对象没有某某特性。</p><p>呃，不得不说，这种情况就好像什么也没说。之前用 gThumb，GNOME桌面一个看图软件，开了一个不存在的插件，gThumb 报错了，错误信息是：Oops!There is something wrong!</p><p>这！我都不知道该说点啥好：我当然知道有问题呀，你好歹提示我哪里有问题嘛，你这么一说，好像我不知道一样！</p><p>看来这两个报错信息有的一拼。</p><p>碰到问题不要去百毒搜索，我们先去官网看看是不是有人遇到了同样的情况。源码发布在GitHub，先去 GitHub 查看。打开 RoseTTAFold 的 GitHub 主页，点击 Issues查看问题。被解决的问题一般在 Closed，未解决的在 Open。</p><p>可以看到在 Open 的 Issues里边，比较靠前的第三个问题就和我们遇到的一样。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230430/20230430145621.png"alt="GitHub Issues 第三个问题和我们碰到的一样！" /></p><p>点进去查看具体信息。这个问题目前没有人回答，使用的版本和我的差不多，出错的情况差不多，也是Python3.7 ，我当时就觉得可能是 Python 的问题。于是重新创建一个 Python3.6环境运行，结果还是不行。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230430/20230430145733.png"alt="查看具体信息。发现这个问题并没有人回答，问题是 23 年 3 月 18 号的，时间点和我们蛮近" /></p><p>自己动手，丰衣足食，直接看代码。我们运行的是 run_pyrosetta_ver.sh文件，故此查看。找到输出 DAN_msa.std[err,out] 文件的那一行，调用的是ErrorPredictorMSA.py，然后出错。那就简单，直接找到这个文件，在RoseTTAFold/DAN_msa 文件夹下。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230430/20230430150624.png"alt="查看 run_pyrosetta_ver.sh 文件，可以看到错误发生是在调用 ErrorPredictorMSA.py 文件之后，说明问题多半在这个文件" /></p><h4 id="查看-errorpredictormsa.py-文件">查看 ErrorPredictorMSA.py文件</h4><p>查看文件的时候可以跟着 Python 的调用走，例如找到 <code>main()</code>函数，然后跟着一步一步走。我看了一会之后发现真正调用的地方在第 159行，调用了 pyErrorPred.process 函数。</p><p>至于是怎么看的，其实只要看看它的参数即可。在函数调用的上面几行出现了关键字<code>features.npz</code>，这样这类文件自然只会在下面出现。不用担心，反正是找到了。</p><p>找到之后跟着这个函数进去，用 VIM 可以直接使用 <code>gd</code>（GotoDefinition）进行查看。如果使用其他编辑器，可以找找编辑器的快捷键或者跳转按钮。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230430/20230430151405.png"alt="ErrorPredictorMSA.py 文件真正解决问题的地方在这里，调用了这个函数" /></p><p>跳转之后我来到了 process 函数的定义：DAN_msa/pyErrorPred/featurize.py文件的第 607行。继续查看。接下来的查看是没有任何技巧的，因为报错给的信息基本等于没有。</p><p>我是暴力查找的：在 process 函数内选一个点，例如第 615行，插入一行输出：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-----------------------GOT YA----------------------------&#x27;</span>)<br></code></pre></div></td></tr></table></figure><p>插入之后再运行 <code>run_pyrosetta_ver.sh</code>脚本。错误信息出现在这个输出之后，说明报错位置在第 615行之后；出现在这个输出之前就说明问题在这行之前。这样慢慢推进，输出结果在DAN_msa.stdout 查看。</p><p>也可以使用夹逼法：选两个点，如果错误信息在两者之间就慢慢压缩。如果出现在前者前边，那就调整位置继续夹逼。同理后边一样。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230430/20230430152002.png"alt="process 函数的定义位置，DAN_msa/pyErrorPred/featurize.py 第 607 行" /></p><p>好巧不巧，我还真找到了，而且花的时间很短，可能是运气好吧！</p><p>第 619 行的函数 extract_EnergyDistM 调用，跳转进去，来到本文件的第 53行定义。看起来都没什么问题：这指的是代码的逻辑。直到看到第 80行，这里出现了一个似曾相识的字眼 ——<code>__mul__</code>，问题多半就是这里了。</p><p>结合刚刚的信息来看，代码中的 iru 是没有这个 <code>__mul__</code>属性的。我们需要确定一下它到底有没有这个属性。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-string">&#x27;pyrosetta.rosetta.utility.graph.EdgeListConstItera&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;__mul__&#x27;</span><br></code></pre></div></td></tr></table></figure><h4 id="确定-iru-的属性">确定 iru 的属性</h4><h4 id="打印属性">打印属性</h4><p>Python 可以使用 dir 函数查看对象的属性和内部函数。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230430/20230430153417.png"alt="使用 dir 查看 os 模块的属性和函数等" /></p><p>在代码中添加相应的输出部分：在 iru下面插入几行，打印它的属性，插入代码是<code>print(dir(iru))</code>。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># Get an edge iterator</span><br><span class="hljs-number">74</span>         iru = graph.get_node(index1).const_edge_list_begin()<br><span class="hljs-number">75</span>         irue = graph.get_node(index1).const_edge_list_end()<br><span class="hljs-number">76</span><br><span class="hljs-number">77</span>         <span class="hljs-built_in">print</span>(<span class="hljs-built_in">dir</span>(iru))<br><span class="hljs-number">78</span>         <br><span class="hljs-number">79</span>         <span class="hljs-comment"># Parse the energy graph.</span><br><span class="hljs-number">80</span>         <span class="hljs-keyword">while</span> iru!=irue:<br><span class="hljs-number">81</span>             <span class="hljs-comment"># Dereference the pointer and get the other end.</span><br><span class="hljs-number">82</span>             edge = iru.__mul__()<br><span class="hljs-number">83</span>          <br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230430/20230430153636.png"alt="添加 print(dir(iru)) 打印 iru 的属性" /></p><p>在交互模式可以直接使用 dir(iru) 打印，但是脚本中需要用 print打印。修改之后再次运行脚本。</p><p>再次运行脚本的参数和刚开始的一样，因为这样更省时间，输出会保存到DAN_msa.stdout 日志文件。</p><h4 id="查看日志内的属性">查看日志内的属性</h4><p>查看 DAN_msa.stdout日志，里边重复打印了很多次属性，只需要看一个即可。可以确认的是，iru的确没有 <code>__mul__</code> 属性。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">PyRosetta-<span class="hljs-number">4</span> <span class="hljs-number">2023</span> [Rosetta PyRosetta4.conda.linux.cxx11thread.serialization.CentOS.python37.Release <span class="hljs-number">2023.16</span>+release<span class="hljs-number">.942</span>c01d5066fd96860b7d268702b832fe906a739 <span class="hljs-number">2023</span>-04-12T15:05:<span class="hljs-number">51</span>] retrieved <span class="hljs-keyword">from</span>: http://www.pyrosetta.org<br>(C) Copyright Rosetta Commons Member Institutions. Created <span class="hljs-keyword">in</span> JHU by Sergey Lyskov <span class="hljs-keyword">and</span> PyRosetta Team.<br>/home/chunshuyumao/Downloads/RoseTTAFold/DAN-msa/models/smTr<br>[<span class="hljs-string">&#x27;__class__&#x27;</span>, <span class="hljs-string">&#x27;__delattr__&#x27;</span>, <span class="hljs-string">&#x27;__dir__&#x27;</span>, <span class="hljs-string">&#x27;__doc__&#x27;</span>, <span class="hljs-string">&#x27;__eq__&#x27;</span>, <span class="hljs-string">&#x27;__format__&#x27;</span>, <span class="hljs-string">&#x27;__ge__&#x27;</span>, <span class="hljs-string">&#x27;__getattribute__&#x27;</span>, <span class="hljs-string">&#x27;__gt__&#x27;</span>, <span class="hljs-string">&#x27;__hash__&#x27;</span>, <span class="hljs-string">&#x27;__init__&#x27;</span>, <span class="hljs-string">&#x27;__init_subclass__&#x27;</span>, <span class="hljs-string">&#x27;__le__&#x27;</span>, <span class="hljs-string">&#x27;__lt__&#x27;</span>, <span class="hljs-string">&#x27;__module__&#x27;</span>, <span class="hljs-string">&#x27;__ne__&#x27;</span>, <span class="hljs-string">&#x27;__new__&#x27;</span>, <span class="hljs-string">&#x27;__reduce__&#x27;</span>, <span class="hljs-string">&#x27;__reduce_ex__&#x27;</span>, <span class="hljs-string">&#x27;__repr__&#x27;</span>, <span class="hljs-string">&#x27;__setattr__&#x27;</span>, <span class="hljs-string">&#x27;__sizeof__&#x27;</span>, <span class="hljs-string">&#x27;__str__&#x27;</span>, <span class="hljs-string">&#x27;__subclasshook__&#x27;</span>, <span class="hljs-string">&#x27;arrow&#x27;</span>, <span class="hljs-string">&#x27;assign&#x27;</span>, <span class="hljs-string">&#x27;dereference&#x27;</span>, <span class="hljs-string">&#x27;pre_decrement&#x27;</span>, <span class="hljs-string">&#x27;pre_increment&#x27;</span>, <span class="hljs-string">&#x27;valid&#x27;</span>]<br>While processing /home/chunshuyumao/Downloads/RoseTTAFold/example/mytest/pdb-3track/model0_1_0<span class="hljs-number">.05</span>.features.npz: <span class="hljs-string">&#x27;pyrosetta.rosetta.utility.graph.EdgeListConstItera&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;__mul__&#x27;</span><br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230430/20230430154333.png"alt="属性被打印到日志 DAN_msa.stdout 文件中，可以看到 iru 确实没有 __mul__ 这个属性" /></p><p>再看看代码注释是怎么说的：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># Dereference the pointer and get the other end.</span><br>edge = iru.__mul__()<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230430/20230430154706.png"alt="代码对调用 mul 的解释是 Dereference，也就是解引用" /></p><p>“解引用”，哈哈，不知道大家是怎么想的。写这个代码的人多半使用过 C/C++语言，因为 C/C++ 语言的解引用操作是<code>*variable</code>。<code>variable</code> 是变量，例如<code>iru</code>，解引用就是在变量前面加一个<code>*</code>，这个符号同时也是乘法符号（multiple），在 Python中的乘法操作重载用 <code>__mul__</code>定义，解引用直接用这个符号，有点好玩。</p><p>它没有定义这个操作符我们无法使用。仔细看上面的属性发现，有一个属性是<code>dereference</code>，恰好就是解引用的意思。搞不好就是？其实就是了。这应该是代码重构后没改过来的部分。于是我们把<code>edge = iru.__mul__()</code> 改为<code>edge = iru.dereference()</code>。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">######################################</span><br><span class="hljs-comment"># Fill the dist_matrix with energies #</span><br><span class="hljs-comment">######################################</span><br>aas = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(length):<br>    index1: <span class="hljs-built_in">int</span> = i + <span class="hljs-number">1</span><br>    aas.append(pose.residue(index1).name().split(<span class="hljs-string">&quot;:&quot;</span>)[<span class="hljs-number">0</span>].split(<span class="hljs-string">&quot;_&quot;</span>)[<span class="hljs-number">0</span>])<br>    <br>    <span class="hljs-comment"># Get an edge iterator</span><br>    iru = graph.get_node(index1).const_edge_list_begin()<br>    irue = graph.get_node(index1).const_edge_list_end()<br><br>    <span class="hljs-comment"># Parse the energy graph.</span><br>    <span class="hljs-keyword">while</span> iru!=irue:<br>        <span class="hljs-comment"># Dereference the pointer and get the other end.</span><br>        <span class="hljs-comment">#edge = iru.__mul__()</span><br>        <span class="hljs-comment"># ↓↓↓↓↓↓↓↓↓修改这里↓↓↓↓↓↓↓↓↓↓↓↓</span><br>        edge = iru.dereference()<br>        <br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230430/20230430155525.png"alt="修改后的代码" /></p><p>修改完再次运行脚本：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">pwd</span><br>/home/chunshuyumao/Downloads/RoseTTAFold/example<br>$ ../run_pyrosetta_ver.sh input.fa mytest<br></code></pre></div></td></tr></table></figure><p>修改完之后发现 mytest/model 下仍空空如也，再次查找问题。</p><h3 id="plus_plus-属性不存在">plus_plus 属性不存在</h3><p>还是 DAN_msa.stdout 文件有问题，错误如下：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">While processing /home/chunshuyumao/Downloads/RoseTTAFold/example/mytest/pdb-3track/model0_0_0<span class="hljs-number">.15</span>.features.npz: <span class="hljs-string">&#x27;pyrosetta.rosetta.utility.graph.EdgeListConstItera&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;plus_plus&#x27;</span><br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230430/20230430161457.png"alt="新的问题，似乎是没有 plus_plus 属性" /></p><p>不用看，继续在我们刚刚的代码找。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-number">101</span>  <span class="hljs-comment"># Move pointer</span><br><span class="hljs-number">102</span>  iru.plus_plus()<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230430/20230430161623.png"alt="刚刚修改代码的地方，第 102 行就调用了 plus_plus 函数" /></p><p>看注释写的是 Move pointer，函数又是 plus_plus：这是 C/C++语言移动迭代器/指针的方式，即 <code>++variable</code> 或者<code>variable++</code>。<code>++</code> 不就是 Plus Plus 嘛！</p><p>查看刚刚的输出，iru 内有一个属性是<code>pre_increment</code>，<code>pre_increment</code>是前进没错了，就是不知道 <code>pre</code>是啥意思。为了确认这是我们找的函数，我们需要查看这个函数的说明。</p><p>在 <code>iru.plus_plus</code> 上面一行添加<code>print(iru.pre_increment.__doc__)</code>，查看函数的信息。这是Python 查看函数说明的方式，函数说明一般集中在 <code>__doc__</code>属性内。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230430/20230430162142.png"alt="查看 pre_increment 函数的说明" /></p><p>重新运行脚本 <code>run_pyrosetta_ver.sh</code>，查看结果，结果在mytest/log/DAN_msa.stdout 中。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">pre_increment(self: pyrosetta.rosetta.utility.graph.EdgeListConstIterator) -&gt; pyrosetta.rosetta.utility.graph.EdgeListConstIterator<br><br>increment operator.  Point this iterator at the <span class="hljs-built_in">next</span> element <span class="hljs-keyword">in</span> the <span class="hljs-built_in">list</span>.<br><br>C++: utility::graph::EdgeListConstIterator::operator++() --&gt; const <span class="hljs-keyword">class</span> <span class="hljs-title class_">utility</span>::graph::EdgeListConstIterator &amp;<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230430/20230430162459.png"alt="pre_increment 函数的定义" /></p><p>上面的输出很明显了，这就是我们要找的函数，用于移动指针/迭代器（Movepointer），而且是前加加（previous plus plus）<code>++variable</code>，可以说命名很规范了。</p><h4 id="修改-plus_plus-代码">修改 plus_plus 代码</h4><p>找到目的函数，把 <code>iru.plus_plus()</code> 改成<code>iru.pre_increment()</code> 即可。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># Move pointer</span><br><span class="hljs-comment">#iru.plus_plus()</span><br>iru.pre_increment()<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230430/20230430162937.png"alt="把 iru.plus_plus() 改成 iur.pre_increment() 函数" /></p><p>随后重新运行脚本。至此问题结束！</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230430/20230430163510.png"alt="重新运行，model 文件夹出现了我们要的文件，问题解决！" /></p><h1 id="后语">后语</h1><p>问题解决了，但是我没有在 GitHub回复那位同样碰到问题的同志，谁有时间或者兴趣可以回复回复人家，毕竟人家有需要，而且等一个月了没人回应。我不回只是因为我不想登录自己的账号。</p><p>此外再调侃修改代码中遇到的事。</p><p>虽然写下 RoseTTAFold 很厉害，但是这个团队的人技术明显不大一样。</p><p>首先是编写 PyRosetta C++源代码的人，他写了函数的使用说明（__doc__属性），这是一种很好的写代码习惯，一个函数应该有函数说明，让别人知道自己是干啥的。</p><p>其次是写 Python 代码的人，在一些非正常操作，例如使用 <code>*</code>作为解引用（调用 __mul__函数），应该写下注释给看代码的人知道这么做的目的。</p><p>上面两种操作都很专业，可以看出来技术很硬。</p><p>然后是编写 Shell 脚本的人，包括 run_pyrosetta_ver.sh 和run_e2e_ver.sh脚本，有一些操作做的很专业，但有些操作又很不应该。例如他知道先判断有没有生成相对应的文件，如果有就不需要重新运行程序，节约时间。但他同时又没有判断自己的程序有没有运行成功，直接让后面的脚本继续运行了。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">106 <span class="hljs-comment">############################################################</span><br>107 <span class="hljs-comment"># 6. Pick final models</span><br>108 <span class="hljs-comment">############################################################</span><br>109 count=$(find <span class="hljs-variable">$WDIR</span>/pdb-3track -maxdepth 1 -name <span class="hljs-string">&#x27;*.npz&#x27;</span> | grep -v <span class="hljs-string">&#x27;features&#x27;</span> | <span class="hljs-built_in">wc</span> -l)<br>110 <span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$count</span>&quot;</span> -lt <span class="hljs-string">&quot;15&quot;</span> ]; <span class="hljs-keyword">then</span><br>111    <span class="hljs-comment"># run DeepAccNet-msa</span><br>112    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Running DeepAccNet-msa&quot;</span><br>113    python <span class="hljs-variable">$PIPEDIR</span>/DAN-msa/ErrorPredictorMSA.py --roll -p <span class="hljs-variable">$CPU</span> <span class="hljs-variable">$WDIR</span>/t000_.3track.npz <span class="hljs-variable">$WDIR</span>/pdb-3track <span class="hljs-variable">$WDIR</span>/pdb-3track 1&gt; <span class="hljs-variable">$WDIR</span>/log/DAN_msa.stdout 2&gt; <span class="hljs-variable">$WDIR</span>/log/DAN_msa.stderr<br>114 <span class="hljs-keyword">fi</span> <br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20230430/20230430170143.png"alt="第 110 行 &quot;if $count&quot; 那里做了检测，只有未生成自己想要的文件才运行下面的代码，避免浪费时间。可第 113 行又没有对运行的脚本结果进行判断，导致这里明明出现了问题，后面的代码仍然运行" /></p><p>这种错误可能让人做出错误判断，例如无法正确找到出错的地方。</p><p>这种错误是故意的还是无意的？应该不是无意的，而是故意的，因为在RoseTTAFold 的 README.md文件中，团队表示这两个脚本只是简单让我们知道这个程序怎么用而已。由此可知这两个脚本的目的只是为了演示，所以他们简化了步骤，也就让脚本健壮性差很多。</p><p>上面的脚本可以改成：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">106 <span class="hljs-comment">############################################################</span><br>107 <span class="hljs-comment"># 6. Pick final models</span><br>108 <span class="hljs-comment">############################################################</span><br>109 count=$(find <span class="hljs-variable">$WDIR</span>/pdb-3track -maxdepth 1 -name <span class="hljs-string">&#x27;*.npz&#x27;</span> | grep -v <span class="hljs-string">&#x27;features&#x27;</span> | <span class="hljs-built_in">wc</span> -l)<br>110 <span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$count</span>&quot;</span> -lt <span class="hljs-string">&quot;15&quot;</span> ]; <span class="hljs-keyword">then</span><br>111   <span class="hljs-comment"># run DeepAccNet-msa</span><br>112   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Running DeepAccNet-msa&quot;</span><br>113   <span class="hljs-keyword">if</span> ! python <span class="hljs-variable">$PIPEDIR</span>/DAN-msa/ErrorPredictorMSA.py --roll -p <span class="hljs-variable">$CPU</span> <span class="hljs-variable">$WDIR</span>/t000_.3track.npz <span class="hljs-variable">$WDIR</span>/pdb-3track <span class="hljs-variable">$WDIR</span>/pdb-3track 1&gt; <span class="hljs-variable">$WDIR</span>/log/DAN_msa.stdout 2&gt; <span class="hljs-variable">$WDIR</span>/log/DAN_msa.stderr; <span class="hljs-keyword">then</span><br>114     <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;run DeepAccNet-msa: Error!&quot;</span><br>115     <span class="hljs-built_in">exit</span> 1<br>116   <span class="hljs-keyword">fi</span><br>117 <span class="hljs-keyword">fi</span> <br></code></pre></div></td></tr></table></figure><p>这样只要脚本没运行成功，后面的命令是无法执行的，而且根据输出可以明显看到是哪一步出了问题。同理，脚本里其他代码的运行都可以如此判断。</p><p>还有一点，就是我在文中调侃的报错信息：</p><blockquote><p>While processing/home/chunshuyumao/Downloads/RoseTTAFold/example/mytest/pdb-3track/model0_1_0.05.features.npz:'pyrosetta.rosetta.utility.graph.EdgeListConstItera' object has noattribute '__mul__'</p></blockquote><p>这里用的是 <code>try/catch</code> 进行错误捕捉，用<code>try/catch</code>我觉得不合适，但是无所谓，因为这是个人习惯问题。我不喜欢<code>try/catch</code>，他们没必要惯着我。可问题是，为什么错误信息不给个位置和文件？这个我非常不理解。</p><p>一般来说，如果选择报错，特别是这种直接不处理的异常，应该给个提示，例如：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">While processing `/home/chunshuyumao/Downloads/RoseTTAFold/example/mytest/pdb-3track/model0_1_0<span class="hljs-number">.05</span>.features.npz` <span class="hljs-keyword">in</span> file `/home/chunshuyumao/test.py`, <span class="hljs-number">619</span>: <span class="hljs-string">&#x27;pyrosetta.rosetta.utility.graph.EdgeListConstItera&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;__mul__&#x27;</span><br></code></pre></div></td></tr></table></figure><p>这样出现问题，其他人就可以快速定位了。当然，我觉得罪魁祸首还是<code>try/catch</code>。愿世间没有 <code>try/catch</code>。</p><h1 class="unnumbered" id="bibliography">参考文献</h1><div id="refs" class="references csl-bib-body" role="list"><div id="ref-AccuratePredictionProtein2021" class="csl-entry"role="listitem"><div class="csl-left-margin">[1] </div><divclass="csl-right-inline">Baek M, DiMaio F, Anishchenko I, <em><em>etal</em></em>. Accurate prediction of protein structures and interactionsusing a three-track neural network. <em>Science</em>, 2021, 373(6557):871-876.</div></div></div>]]></content>
    
    
    <categories>
      
      <category>RoseTTAFold</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>RoseTTAFold</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在 VIM 中安装 vim-pandoc-syntax 插件</title>
    <link href="/2023/04/29/Use-vim-pandoc-syntax-plugin-in-vim/"/>
    <url>/2023/04/29/Use-vim-pandoc-syntax-plugin-in-vim/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p><a href="https://github.com/vim-pandoc/vim-pandoc-syntax"title="vim-pandoc-syntax GitHub 仓库">vim-pandoc-syntax</a> 是 <ahref="https://www.vim.org" title="VIM">VIM</a> 编辑器的 Pandoc语法插件，支持大部分的 Pandoc Markdown 扩展（Pandoc'sMarkdown）语法特性。简单来说就是高亮。口说无凭，下面可以看看vim-pandoc-syntax 的高亮功能：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230429192542.png"alt="不开启语法高亮" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230429192005.png"alt="开启 vim-pandoc-syntax 高亮功能" /></p><p>可以看到确实漂亮，特别是用上了 VIM 的 conceal 特性，可以使用很多的Unicode 字符代替 ASCII 字符。</p><p>很久之前就听说了 vim-pandoc-syntax插件，但一直没有尝试，最近有时间试试。</p><h1 id="安装插件">安装插件</h1><p>安装插件之前最好确认自己用的是 VIM 编辑器，因为这是 VIM 插件。</p><h2 id="安装">安装</h2><p>首先是到 <a href="https://github.com/vim-pandoc/vim-pandoc-syntax"title="vim-pandoc-syntax GitHub 仓库">Github</a> 下载 vim-pandoc-syntax插件。因为很多人都使用插件管理器，可以按照 Github上的教程直接安装。我不用什么管理器，手动安装。</p><p>首先确认自己 VIM 有 pack 文件夹，控制台上输入：</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">$ file ~/.vim/pack/plugins/start<br>/home/chunshuyumao/.vim/pack/plugins/start: directory<br></code></pre></div></td></tr></table></figure><p>如果输出结果不是上面的，而是类似下面的提示，说明自己的 VIM并没有这个路径。</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">/home/chunshuyumao/.vim/pack/plugins/start: cannot open `/home/chunshuyumao/.vim/pack/plugins/start<span class="hljs-string">&#x27; (No such file or directory)</span><br></code></pre></div></td></tr></table></figure><blockquote><p>上面的 plugins 其实可以是任何名称，不是中文就行。例如:</p><p>/home/chunshuyumao/.vim/pack/anything/start</p></blockquote><p>建立一个文件夹，在控制台上输入以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">$ <span class="hljs-built_in">mkdir</span> -vp ~/.vim/pack/plugins/start<br><span class="hljs-built_in">mkdir</span>: created directory <span class="hljs-string">&#x27;/home/chunshuyumao/.vim/pack/plugins/start&#x27;</span><br></code></pre></div></td></tr></table></figure><p>建立文件夹之后，进入该文件夹。用 <a href="https://git-scm.com"title="Git">Git</a> 克隆（clone）仓库或者直接去 GitHub 上下载vim-pandoc-syntax 压缩包，解压后放到刚刚创建的文件夹。如下面的操作：</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">$ <span class="hljs-built_in">cd</span> ~/.vim/pack/plugins/start<br>$ <span class="hljs-built_in">pwd</span><br>/home/chunshuyumao/.vim/pack/plugins/start<br>$ git <span class="hljs-built_in">clone</span> https://github.com/vim-pandoc/vim-pandoc-syntax<br>Cloning into <span class="hljs-string">&#x27;vim-pandoc-syntax&#x27;</span>...<br>...<br>$ <span class="hljs-built_in">ls</span><br>vim-pandoc-syntax<br></code></pre></div></td></tr></table></figure><p>在 VIM 的配置文件 <code>~/.vimrc</code> 中添加：</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">augroup</span> pandoc_syntax<br>    au! BufNewFile,BufFilePre,BufRead *.md <span class="hljs-keyword">set</span> <span class="hljs-keyword">filetype</span>=markdown.pandoc<br><span class="hljs-keyword">augroup</span> END<br></code></pre></div></td></tr></table></figure><p>保存退出即可，这就算安装好了。</p><p>打开 VIM，然后进入命令行模式，即输入 <code>:</code>进入命令行模式。输入：</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">:helptag ~/.vim/pack/plugins/start/vim-pandoc-syntax/doc<br></code></pre></div></td></tr></table></figure><p>生成 vim-pandoc-syntax 插件的说明文档。这样自己忘了关于vim-pandoc-syntax 的配置时，可以直接在 VIM 命令行模式查找帮助。</p><p>进入命令行模式输入 <code>:help vim-pandoc-syntax</code>查看帮助文件是否正确生成。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230429195431.gif"alt="在命令行模式查看 vim-pandoc-syntax 帮助文档" /></p><h2 id="配置">配置</h2><p>今天写这个博客肯定不是单单安装就完了，还有一些需要配置。</p><h3 id="代码块高亮">代码块高亮</h3><p>vim-pandoc-syntax 可使 Markdown 代码块高亮，但默认不开启，可以使用<code>:help pandoc-syntax-commands</code> 查看帮助。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230429200304.png"alt="代码块高亮的帮助，文档表明可以使用 g:pandoc#syntax#codeblocks#enable#langs 或者 :PandocHighlight 手动调用高亮" /></p><p>按照帮助，我们可以在<code>g:pandoc#syntax#codeblocks#enable#langs</code>中列出自己的需要高亮的语言，或者使用 <code>:PandocHighlight LANG</code>高亮，其中 <code>LANG</code> 是需要高亮的语言的名称，如 <code>cpp</code>是 C++ ，<code>python</code> 是 Python。</p><p>先说手动高亮。手动高亮就是在自己写 Markdown时，用到什么语言再调用高亮。调用方式是使用 VIM的命令行模式，输入上面说的命令。下面的动图展示如何调用语言高亮。请仔细看，在调用高亮之前Markdown 文档的 VIM 代码块是没有高亮的，只显示了淡蓝色。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230429200812.gif"alt="手动调用语法高亮" /></p><p>这种方式比较粗糙，如果嫌麻烦，可以使用自动高亮，也就是下面要讲的。</p><p>要自动高亮需要在 VIM 的配置文件 <code>~/.vimrc</code> 中添加：</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">let</span> <span class="hljs-variable">g:pandoc</span>#syntax#codeblocks#enable#langs = [<br>      \ <span class="hljs-string">&#x27;cpp&#x27;</span>,<br>      \ <span class="hljs-string">&#x27;python&#x27;</span>,<br>      \ <span class="hljs-string">&#x27;sh&#x27;</span>,<br>      \ <span class="hljs-string">&#x27;bash&#x27;</span>,<br>      \ <span class="hljs-string">&#x27;lua&#x27;</span>,<br>      \ <span class="hljs-string">&#x27;vim&#x27;</span>,<br>      \ ]<br></code></pre></div></td></tr></table></figure><p>上面是我可能用到的几种语言。语言不是写得越多越好，毕竟有些语言自己也用不到，写下来作甚？写完之后保存退出。这样只要自己在代码块上标注使用了什么语言，VIM就会自动帮助你高亮。其他的配置也可以看文档。</p><h3 id="与-polyglot-插件冲突">与 polyglot 插件冲突</h3><p>我的 VIM 安装的插件不多，但是 vim-pandoc-syntax还是和其他插件冲突了。我使用 <ahref="https://github.com/sheerun/vim-polyglot"title="vim-polyglot 官网">vim-polyglot</a>作为自己的语法高亮包。这是一个集合了很多语言和文件高亮方式的插件包，Markdown自然也包含其中。如果没有安装这个插件，可以不用看关于这个插件冲突的解决方法。</p><p>首先查看帮助文档：</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">:<span class="hljs-keyword">help</span> poly-<span class="hljs-keyword">vim</span><br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230429202454.png"alt="文档说可以使用 g:polyglot_disabled 关闭特定语言的高亮" /></p><p>其实这个文档说的不够详细，可以参考更详细的 vim-polyglot <ahref="https://github.com/sheerun/vim-polyglot/blob/master/README.md"title="vim-polyglot README.md 文档">README.md</a> 。</p><p>在 <code>~/.vimrc</code> 中加入：</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">let</span> <span class="hljs-variable">g:polyglot_disabled</span> = [<br>    \ <span class="hljs-string">&#x27;markdown&#x27;</span>,<br>    \ ]<br></code></pre></div></td></tr></table></figure><p>来禁止 vim-polyglot 帮我们高亮自己的 Markdown 文件，因为使用vim-pandoc-syntax 效果更好。</p><p>vim-polyglot 除了可以给我们的 Markdown文件语法高亮，附带了一个可以查看、生成和跳转目录的插件，配置在<code>vim-polyglot/ftplugin</code> 下的 <code>markdown.vim</code>文件。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230429203428.png"alt="vim-polyglot 带的 Markdown 目录包生成的目录" /></p><p>我们希望使用这个可以生成目录的文件，但又不想使用 vim-polyglot带的高亮。vim-polyglot 提供了方法，只是帮助文档没有写，上面提到的README.md 文件里边写了，就是把上面添加的<code>g:polyglot_disabled</code> 那一行改成：</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">let</span> <span class="hljs-variable">g:polyglot_disabled</span> = [<br>    \ <span class="hljs-string">&#x27;markdown.plugin&#x27;</span>,<br>    \ ]<br></code></pre></div></td></tr></table></figure><p>可以了。我们可以看看是不是可以了。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230429204013.png"alt="可以了！但是好像有点不同" /></p><p>可以但有点不同，可以参考上面的一张图，好像代码块的边边不一样了：之前是一个λ 和语言名称，现在不见了。其实不是不见了，而是这个 <code>ftplugin</code>下的文件也同样对代码块有自己的想法。这样设计不好，一个插件应该只做一件事，它同时负责了代码块高亮和目录生成。</p><p>我们只要可以生成目录就行，不需要高亮，高亮已经有负责的插件了。直接打开<code>vim-polyglot</code> 文件夹下 <code>ftplugin</code> 文件夹内的<code>markdown.vim</code> 文件，查看是哪几行在作怪。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230429204516.png"alt="谁在作怪？" /></p><p>可以看到，从 774 行之后都是关于语法高亮的部分 ——我自然不可能只看这一点点就看出来了，我早就把文件看完了才这么肯定是这几行作怪的。要想去掉这个功能，只需要全删掉774行之后的代码，或者直接注释掉。我的习惯是注释掉，因为搞不好以后还有用，所以直接用<code>"</code> 注释吧！</p><p>使用 VIM 就不要一个一个插入注释符号了，使用命令行模式，输入<code>:774,$s/^/"/</code> 进行注释，回车即可。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230429205440.gif"alt="命令行直接替换" /></p><ul><li><code>774,$</code> 是选择第 774行到最后一行（<code>$</code>代表最后一行）</li><li><code>s</code> 是 <code>substitute</code>，”替换“的缩写</li><li><code>/</code> 用做分隔符</li><li><code>^</code> 表示是一行开头的字符</li><li><code>/</code> 还是分隔符</li><li><code>"</code> 是替换开头的字符</li><li><code>/</code> 还是分隔符</li></ul><h3 id="改进-vim-pandoc-syntax-插件">改进 vim-pandoc-syntax 插件</h3><p>vim-pandoc-syntax插件好是好，但有一个问题：斜体必须前后都是空格。</p><p>举个例子，要给 <code>you silly man</code> 中的 <code>silly</code>斜体必须要这样写<code>you *silly* man</code>。这么说大家可能觉得没啥，因为这很明显呀，难不成我还想写成<code>you*silly*man</code>？其实不然，这是英文大家才觉得正常，中文字与字之间是没有空格的。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230429211017.png"alt="没有空格，即使是英文也显示不出斜体" /></p><p>为了让它可以在没有空格和中文环境下也可以体现斜体，我们要做一些改变。当然，有些人觉得这没必要，因为中文一般不会使用斜体，这种修改多此一举。那我举个英文的例子好了：</p><p>生物领域里，限制性核酸内切酶由三个斜体字母命名，其后可以添加一个分离菌株的正体缩写，例如<em>Eco</em>RⅠ 酶、<em>Bam</em>HⅠ酶。这种时候即使是英文也没有空格。生物是一个严肃的学科，书写是专业性的体现，这种情况总是必要的吧？如果觉得没必要，那最好不好进实验室，不然会被导师骂死。</p><p>截个图看看没有空格之后的格式多混乱：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230429211751.png"alt="没有空格的混乱格式" /></p><p>没有空格导致后面的文字都被当成了斜体的内容，VIM 在等后接一个空格的<code>*</code> 作为斜体的结束标志。等不它自然觉得都是斜体咯！</p><p>闲话少叙。不用找斜体在哪了，我已经找到了：vim-pandoc-syntax插件目录内，syntax 目录下的 <code>pandoc.vim</code> 文件的第 352、353行。说实话，这正则我看了都头疼。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230429212547.png"alt="斜体部分的正则" /></p><p>这个正则非常复杂，我就不解释了 —— 其实也不全看懂，可以在 VIM 内输入<code>:help regexp</code> 查看，如果想看这些鬼东西代表什么的话。</p><p>主要看看 <code>start</code> 和 <code>end</code>两部分内的鬼东西就行了。这里我们看有个<code>\s</code>，这是空白字符的意思，这里就定义了必须要碰到起码一个空白字符。现在我们需要定义的是，是不是空白都可以，所以在后面添加<code>\S</code>，这表示非空白字符。</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">start=/\\\@<span class="hljs-number">1</span>&lt;!\(\_^\|\s\|[[:punct:]]\)\@&lt;=\*\S\@=/ skip=/\(\*\*\|__\)/ end=/\*\([[:punct:]]\|\s\|\_$\)\@=/<br>start=/\\\@<span class="hljs-number">1</span>&lt;!\(\_^\|\s\|[[:punct:]]\)\@&lt;=_\S\@=/ skip=/\(\*\*\|__\)/ end=/\S\@<span class="hljs-number">1</span>&lt;=_\([[:punct:]]\|\s\|\_$\)\@=/<br></code></pre></div></td></tr></table></figure><p>现在这两行变成：</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim"><span class="hljs-comment">&quot; 把 \s 换成 \s\|\S，一行改两处，总四处</span><br><span class="hljs-comment">&quot;start=/\\\@1&lt;!\(\_^\|\s\|[[:punct:]]\)\@&lt;=\*\S\@=/ skip=/\(\*\*\|__\)/ end=/\*\([[:punct:]]\|\s\|\_$\)\@=/</span><br><span class="hljs-comment">&quot;                       ↓                                                                         ↓</span><br>start=/\\\@<span class="hljs-number">1</span>&lt;!\(\_^\|\s\|\S\|[[:punct:]]\)\@&lt;=\*\S\@=/ skip=/\(\*\*\|__\)/ end=/\*\([[:punct:]]\|\s\|\S\|\_$\)\@=/<br><span class="hljs-comment">&quot;start=/\\\@1&lt;!\(\_^\|\s\|[[:punct:]]\)\@&lt;=_\S\@=/ skip=/\(\*\*\|__\)/ end=/\S\@1&lt;=_\([[:punct:]]\|\s\|\_$\)\@=/</span><br><span class="hljs-comment">&quot;                       ↓                                                                             ↓</span><br>start=/\\\@<span class="hljs-number">1</span>&lt;!\(\_^\|\s\|\S\|[[:punct:]]\)\@&lt;=_\S\@=/ skip=/\(\*\*\|__\)/ end=/\S\@<span class="hljs-number">1</span>&lt;=_\([[:punct:]]\|\s\S\|\|\_$\)\@=/<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230429214018.png"alt="修改 \s 为 \s\|\S" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230429213646.png"alt="修改之后斜体啦" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230429213722.png"alt="限制性核酸内切酶也斜体了" /></p><p>大功告成！至此，我觉得这个插件已经被改得比较好了，哈哈。</p><h2 id="书写规范">书写规范</h2><p>之前我写过一篇如何使用 Pandoc写论文的博客，里边讲到了怎么给表格添加标题：</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown"><br>查看[@tbl:id]。<br><br>|&lt;++&gt;|&lt;++&gt;|&lt;++&gt;|<br>|:----:|:----:|:----:|<br>|&lt;++&gt;|&lt;++&gt;|&lt;++&gt;|<br>|&lt;++&gt;|&lt;++&gt;|&lt;++&gt;|<br>|&lt;++&gt;|&lt;++&gt;|&lt;++&gt;|<br>: 这是标题 &#123;#tbl:id&#125;<br></code></pre></div></td></tr></table></figure><p>其实不全对，应该是这样的：</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown"><br>查看[@tbl:id]。<br><br>|&lt;++&gt;|&lt;++&gt;|&lt;++&gt;|<br>|:----:|:----:|:----:|<br>|&lt;++&gt;|&lt;++&gt;|&lt;++&gt;|<br>|&lt;++&gt;|&lt;++&gt;|&lt;++&gt;|<br>|&lt;++&gt;|&lt;++&gt;|&lt;++&gt;|<br><br>: 这是标题 &#123;#tbl:id&#125;<br></code></pre></div></td></tr></table></figure><p>即，表格和标题应该空一行。之前没有空是因为那时使用 <ahref="https://zettlr.com"title="Zettlr">Zettlr</a>，空一行编辑器就渲染成了新的一行。</p><p>这不算大问题，因为 Pandoc都会渲染成表格标题，所以我一直没说。然而现在推荐了 vim-pandoc-syntax插件，这个插件认为表格和标题之间是有空行的，如果表格和标题不空一行，它就不进行渲染—— 表格之后都不进行渲染。故此才得提一下。</p><h1 id="后言">后言</h1><p>有阵子没看 <a href="https://pandoc.org" title="Pandoc">Pandoc</a>的更新，现在都到第三个大版本了。Arch Linux 官方仓库的 Pandoc有很大的依赖，十几 M 的 Pandoc 安装的 <a href="https://www.haskell"title="Haskell Language">Haskell</a> 包有 500M 左右。</p><p>我是个有洁癖的人，最看不惯这种无所谓的依赖，所以自己安装的 Pandoc 是<a href="https://github.com/jpm/pandoc/releases">Github仓库</a>下载的独立可执行文件，因此才没有跟进 Pandoc的升级。现在自己使用的还是 2.9 版的 Pandoc。最近看了看，Pandoc 3.0的变化还是比较大的。</p><p>虽然 Pandoc 版本变化大，但是对我这种之用 Markdown 转到 WORD 或者 HTML的人来说，变化不大：HTML 增加了一些自己不是很常用的功能，WORD就添加了摘要标题（Abstract Title），作用不大。</p><p>作为一个懒散的人，只要目前的 Pandoc版本足够使用，我就不会改用其他的版本，所以继续停留在 v2.9也不是不行。</p>]]></content>
    
    
    <categories>
      
      <category>VIM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pandoc</tag>
      
      <tag>VIM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>布努语文介绍</title>
    <link href="/2023/04/27/sher-heu-buv-nuh-gaih-sauh/"/>
    <url>/2023/04/27/sher-heu-buv-nuh-gaih-sauh/</url>
    
    <content type="html"><![CDATA[<h1 id="前言-shav-ha-deh">前言 Shav-Ha-Deh</h1><p>最近一直在给布努文添加规则，好久没有发文章了。因为公众号只能改一次错误，所以少有在公众号上放，毕竟有些规定是需要灵活变通的。这篇文章主要还是介绍布努语的语音系统和书写系统的一些规定。因为参考的书籍都太老了，不知道怎么引用。不过也不用担心，毕竟也就那本，搜搜就找到了。</p><h1 id="sing-muv-heu-deh-声母">Sing-Muv (Heu-Deh) 声母</h1><p>布努语的声母包括腭化、圆唇的共有五十九个。如：</p><table><caption>声母表</caption><thead><tr class="header"><th style="text-align: left;">b</th><th style="text-align: left;">p</th><th style="text-align: left;">mb</th><th style="text-align: left;">mp</th><th style="text-align: left;">m</th><th style="text-align: left;">hm</th><th style="text-align: left;">w</th><th style="text-align: left;">f</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;">nzy</td><td style="text-align: left;">ncy</td><td style="text-align: left;"></td><td style="text-align: left;">s</td></tr><tr class="even"><td style="text-align: left;">z</td><td style="text-align: left;">c</td><td style="text-align: left;">nz</td><td style="text-align: left;">nc</td><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;">sh</td></tr><tr class="odd"><td style="text-align: left;">d</td><td style="text-align: left;">t</td><td style="text-align: left;">nd</td><td style="text-align: left;">nt</td><td style="text-align: left;">n</td><td style="text-align: left;">hn</td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;">dl</td><td style="text-align: left;">tl</td><td style="text-align: left;">ndl</td><td style="text-align: left;">ntl</td><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;">l</td><td style="text-align: left;">hl</td></tr><tr class="odd"><td style="text-align: left;">zh</td><td style="text-align: left;">ch</td><td style="text-align: left;">nzh</td><td style="text-align: left;">nch</td><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;">r</td><td style="text-align: left;">rh</td></tr><tr class="even"><td style="text-align: left;">j</td><td style="text-align: left;">q</td><td style="text-align: left;">nj</td><td style="text-align: left;">nq</td><td style="text-align: left;">ny</td><td style="text-align: left;">hny</td><td style="text-align: left;">y</td><td style="text-align: left;">x</td></tr><tr class="odd"><td style="text-align: left;">g</td><td style="text-align: left;">k</td><td style="text-align: left;">ngg</td><td style="text-align: left;">nk</td><td style="text-align: left;">ng</td><td style="text-align: left;">hng</td><td style="text-align: left;">v</td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;">gw</td><td style="text-align: left;">kw</td><td style="text-align: left;">nggw</td><td style="text-align: left;">nkw</td><td style="text-align: left;">ngw</td><td style="text-align: left;">hngw</td><td style="text-align: left;">u</td><td style="text-align: left;">hw</td></tr><tr class="odd"><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;">h</td></tr></tbody></table><h2 id="sol-mingl-nggongx-vangx-说明">Sol-Mingl (Nggongx-Vangx)说明</h2><ol type="1"><li>nzy /nzʲ/、ncy /nzʰʲ/ 有些地方读作 my /mʲ/、hmy /m̥ʲ/。</li><li>z /ʦ/、c /ʦʰ/、nz /nʦ/、nc /nʦʰ/ 有些地方读作 bzy /pʦʲ/、bcy/pʦʰʲ/、mbzy /mpʦʲ/、mbcy/mpʦʰʲ/。</li><li>dl /tɬ/、tl /tɬʰ/、ndl /ntɬ/、ntl /ntɬʰ/ 有些地方读作 bl /pl/、pl/pʰl/、mbl /mpl/、mpl /mpʰl/。</li><li>送气的声母，即第二、四、六、八列，都只出现在单数调，即1、3、5、7、1'、3' 调。</li><li>声母 y /j/、u /w/ 是介音i、u，与其他声母相拼时，分别表示腭化和唇化。</li><li>/ɦ/ 与 /h/ 皆写作 h。</li></ol><h2id="sing-muv-rongh-lil-sheuh-heu-deh-rongh-sher-lil-声母与例字">Sing-MuvRongh Lil-Sheuh (Heu-Deh rongh Sher-Lil) 声母与例字</h2><p>声母与例字列出以供发音参考下表，含国际音标（International PhoneticAlphabet,IPA）。</p><table><caption>声母与例字</caption><thead><tr class="header"><th style="text-align: left;">国际音标</th><th style="text-align: left;">声母</th><th style="text-align: left;">例音</th><th style="text-align: left;">例字</th><th style="text-align: left;">汉字</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">/p/</td><td style="text-align: left;">b</td><td style="text-align: left;">/pe¹/</td><td style="text-align: left;">be</td><td style="text-align: left;">三</td></tr><tr class="even"><td style="text-align: left;">/pʰ/</td><td style="text-align: left;">p</td><td style="text-align: left;">/pʰe³/</td><td style="text-align: left;">pev</td><td style="text-align: left;">烧</td></tr><tr class="odd"><td style="text-align: left;">/mp/</td><td style="text-align: left;">mb</td><td style="text-align: left;">/mpai⁵/</td><td style="text-align: left;">mbaix</td><td style="text-align: left;">猪</td></tr><tr class="even"><td style="text-align: left;">/mpʰ/</td><td style="text-align: left;">mp</td><td style="text-align: left;">/mpʰa⁸/</td><td style="text-align: left;">mpal</td><td style="text-align: left;">女</td></tr><tr class="odd"><td style="text-align: left;">/m/</td><td style="text-align: left;">m</td><td style="text-align: left;">/mi⁸/</td><td style="text-align: left;">mil</td><td style="text-align: left;">母</td></tr><tr class="even"><td style="text-align: left;">/m̥/</td><td style="text-align: left;">hm</td><td style="text-align: left;">/m̥i⁵/</td><td style="text-align: left;">hmix</td><td style="text-align: left;">夜</td></tr><tr class="odd"><td style="text-align: left;">/v/</td><td style="text-align: left;">w</td><td style="text-align: left;">/vo⁴/</td><td style="text-align: left;">woz</td><td style="text-align: left;">牛</td></tr><tr class="even"><td style="text-align: left;">/f/</td><td style="text-align: left;">f</td><td style="text-align: left;">/fa³/</td><td style="text-align: left;">fav</td><td style="text-align: left;">头</td></tr><tr class="odd"><td style="text-align: left;">/nzʲ/</td><td style="text-align: left;">nzy</td><td style="text-align: left;">/nzʲo⁸/</td><td style="text-align: left;">nzyol</td><td style="text-align: left;">猫</td></tr><tr class="even"><td style="text-align: left;">/nzʰʲ/</td><td style="text-align: left;">ncy</td><td style="text-align: left;">/nzʰʲɤŋ¹/</td><td style="text-align: left;">ncyerng</td><td style="text-align: left;">咒</td></tr><tr class="odd"><td style="text-align: left;">/ɕ/</td><td style="text-align: left;">s</td><td style="text-align: left;">/ɕa⁵/</td><td style="text-align: left;">sax</td><td style="text-align: left;">浸</td></tr><tr class="even"><td style="text-align: left;">/ʦ/</td><td style="text-align: left;">z</td><td style="text-align: left;">/ʦɤŋ¹/</td><td style="text-align: left;">zerng</td><td style="text-align: left;">兵</td></tr><tr class="odd"><td style="text-align: left;">/ʦʰ/</td><td style="text-align: left;">c</td><td style="text-align: left;">/ʦʰo³/</td><td style="text-align: left;">cov</td><td style="text-align: left;">敲</td></tr><tr class="even"><td style="text-align: left;">/nʦ/</td><td style="text-align: left;">nz</td><td style="text-align: left;">/nʦɤ³/</td><td style="text-align: left;">nzerngv</td><td style="text-align: left;">掀</td></tr><tr class="odd"><td style="text-align: left;">/nʦʰ/</td><td style="text-align: left;">nc</td><td style="text-align: left;">/nʦʰɤŋ³/</td><td style="text-align: left;">ncerngv</td><td style="text-align: left;">血</td></tr><tr class="even"><td style="text-align: left;">/θ/</td><td style="text-align: left;">sh</td><td style="text-align: left;">/θa³/</td><td style="text-align: left;">shav</td><td style="text-align: left;">事</td></tr><tr class="odd"><td style="text-align: left;">/t/</td><td style="text-align: left;">d</td><td style="text-align: left;">/te¹/</td><td style="text-align: left;">de</td><td style="text-align: left;">答</td></tr><tr class="even"><td style="text-align: left;">/tʰ/</td><td style="text-align: left;">t</td><td style="text-align: left;">/tʰɤŋ¹'/</td><td style="text-align: left;">terng</td><td style="text-align: left;">梯</td></tr><tr class="odd"><td style="text-align: left;">/nt/</td><td style="text-align: left;">nd</td><td style="text-align: left;">/ntaŋ⁵/</td><td style="text-align: left;">ndangx</td><td style="text-align: left;">树</td></tr><tr class="even"><td style="text-align: left;">/ntʰ/</td><td style="text-align: left;">nt</td><td style="text-align: left;">/ntʰɤ¹/</td><td style="text-align: left;">nter</td><td style="text-align: left;">净</td></tr><tr class="odd"><td style="text-align: left;">/n/</td><td style="text-align: left;">n</td><td style="text-align: left;">/nau²/</td><td style="text-align: left;">nauh</td><td style="text-align: left;">吃</td></tr><tr class="even"><td style="text-align: left;">/n̥/</td><td style="text-align: left;">hn</td><td style="text-align: left;">/n̥oŋ¹/</td><td style="text-align: left;">hnong</td><td style="text-align: left;">日</td></tr><tr class="odd"><td style="text-align: left;">/tɬ/</td><td style="text-align: left;">dl</td><td style="text-align: left;">/tɬu⁷/</td><td style="text-align: left;">dlus</td><td style="text-align: left;">落</td></tr><tr class="even"><td style="text-align: left;">/tɬʰ/</td><td style="text-align: left;">tl</td><td style="text-align: left;">/tɬʰu⁷/</td><td style="text-align: left;">tlus</td><td style="text-align: left;">脱</td></tr><tr class="odd"><td style="text-align: left;">/ntɬ/</td><td style="text-align: left;">ndl</td><td style="text-align: left;">/ntɬaŋ²'/</td><td style="text-align: left;">ndlangh</td><td style="text-align: left;">叶</td></tr><tr class="even"><td style="text-align: left;">/ntɬʰ/</td><td style="text-align: left;">ntl</td><td style="text-align: left;">/ntɬʰɤŋ⁷/</td><td style="text-align: left;">ntlerngs</td><td style="text-align: left;">溅</td></tr><tr class="odd"><td style="text-align: left;">/l/</td><td style="text-align: left;">l</td><td style="text-align: left;">/laŋ⁸/</td><td style="text-align: left;">langl</td><td style="text-align: left;">大</td></tr><tr class="even"><td style="text-align: left;">/ɬ/</td><td style="text-align: left;">hl</td><td style="text-align: left;">/ɬo³/</td><td style="text-align: left;">hlov</td><td style="text-align: left;">竹</td></tr><tr class="odd"><td style="text-align: left;">/ʈ/</td><td style="text-align: left;">zh</td><td style="text-align: left;">/ʈu⁷/</td><td style="text-align: left;">zhus</td><td style="text-align: left;">逃</td></tr><tr class="even"><td style="text-align: left;">/ʈʰ/</td><td style="text-align: left;">ch</td><td style="text-align: left;">/ʈʰo⁷/</td><td style="text-align: left;">chos</td><td style="text-align: left;">抽</td></tr><tr class="odd"><td style="text-align: left;">/ɳʈ/</td><td style="text-align: left;">nzh</td><td style="text-align: left;">/ɳʈu⁵/</td><td style="text-align: left;">nzhux</td><td style="text-align: left;">爱</td></tr><tr class="even"><td style="text-align: left;">/ɳʈʰ/</td><td style="text-align: left;">nch</td><td style="text-align: left;">/ɳʈʰɤŋ⁵/</td><td style="text-align: left;">ncherngx</td><td style="text-align: left;">顶</td></tr><tr class="odd"><td style="text-align: left;">/ʐ/</td><td style="text-align: left;">r</td><td style="text-align: left;">/ʐoŋ²/</td><td style="text-align: left;">rongh</td><td style="text-align: left;">跟</td></tr><tr class="even"><td style="text-align: left;">/ʂ/</td><td style="text-align: left;">rh</td><td style="text-align: left;">/ʂoŋ¹/</td><td style="text-align: left;">rho</td><td style="text-align: left;">量</td></tr><tr class="odd"><td style="text-align: left;">/c/</td><td style="text-align: left;">j</td><td style="text-align: left;">/cɤu⁸/</td><td style="text-align: left;">jeul</td><td style="text-align: left;">十</td></tr><tr class="even"><td style="text-align: left;">/cʰ/</td><td style="text-align: left;">q</td><td style="text-align: left;">/cʰi⁵/</td><td style="text-align: left;">qix</td><td style="text-align: left;">找</td></tr><tr class="odd"><td style="text-align: left;">/ɲc/</td><td style="text-align: left;">nj</td><td style="text-align: left;">/ɲce²/</td><td style="text-align: left;">njeh</td><td style="text-align: left;">柱</td></tr><tr class="even"><td style="text-align: left;">/ɲcʰ/</td><td style="text-align: left;">nq</td><td style="text-align: left;">/ɲcʰai¹/</td><td style="text-align: left;">nqai</td><td style="text-align: left;">教</td></tr><tr class="odd"><td style="text-align: left;">/ɲ/</td><td style="text-align: left;">ny</td><td style="text-align: left;">/ɲɤŋ⁶/</td><td style="text-align: left;">nyerngc</td><td style="text-align: left;">须</td></tr><tr class="even"><td style="text-align: left;">/ɲ̥/</td><td style="text-align: left;">hny</td><td style="text-align: left;">/ɲ̥uŋ³/</td><td style="text-align: left;">hnyungv</td><td style="text-align: left;">更</td></tr><tr class="odd"><td style="text-align: left;">/j/</td><td style="text-align: left;">y</td><td style="text-align: left;">/jo⁸/</td><td style="text-align: left;">yol</td><td style="text-align: left;">骗</td></tr><tr class="even"><td style="text-align: left;">/ç/</td><td style="text-align: left;">x</td><td style="text-align: left;">/çai¹/</td><td style="text-align: left;">xai</td><td style="text-align: left;">满</td></tr><tr class="odd"><td style="text-align: left;">/k/</td><td style="text-align: left;">g</td><td style="text-align: left;">/ka¹/</td><td style="text-align: left;">ga</td><td style="text-align: left;">鸡</td></tr><tr class="even"><td style="text-align: left;">/kʰ/</td><td style="text-align: left;">k</td><td style="text-align: left;">/kʰa¹/</td><td style="text-align: left;">ka</td><td style="text-align: left;">绑</td></tr><tr class="odd"><td style="text-align: left;">/ŋk/</td><td style="text-align: left;">ngg</td><td style="text-align: left;">/ŋka²/</td><td style="text-align: left;">nggah</td><td style="text-align: left;">肉</td></tr><tr class="even"><td style="text-align: left;">/ŋkʰ/</td><td style="text-align: left;">nk</td><td style="text-align: left;">/ŋkʰai³/</td><td style="text-align: left;">nkaiv</td><td style="text-align: left;">枯</td></tr><tr class="odd"><td style="text-align: left;">/ŋ/</td><td style="text-align: left;">ng</td><td style="text-align: left;">/ŋai⁶/</td><td style="text-align: left;">ngaic</td><td style="text-align: left;">易</td></tr><tr class="even"><td style="text-align: left;">/ŋ̥/</td><td style="text-align: left;">hng</td><td style="text-align: left;">/ŋ̥iaŋ⁵/</td><td style="text-align: left;">hngiangx</td><td style="text-align: left;">歪</td></tr><tr class="odd"><td style="text-align: left;">/ɣ/</td><td style="text-align: left;">v</td><td style="text-align: left;">/ɣe¹/</td><td style="text-align: left;">ve</td><td style="text-align: left;">石</td></tr><tr class="even"><td style="text-align: left;">/kʷ/</td><td style="text-align: left;">gw</td><td style="text-align: left;">/kʷai²/</td><td style="text-align: left;">gwaih</td><td style="text-align: left;">黄</td></tr><tr class="odd"><td style="text-align: left;">/kʰʷ/</td><td style="text-align: left;">kw</td><td style="text-align: left;">/kʰʷai¹/</td><td style="text-align: left;">kwai</td><td style="text-align: left;">轻</td></tr><tr class="even"><td style="text-align: left;">/ŋkʷ/</td><td style="text-align: left;">nggw</td><td style="text-align: left;">/ŋkʷe⁴/</td><td style="text-align: left;">nggwez</td><td style="text-align: left;">捉</td></tr><tr class="odd"><td style="text-align: left;">/ŋkʰʷ/</td><td style="text-align: left;">nkw</td><td style="text-align: left;">/ŋkʷa¹' ŋkʰʷiŋ¹'/</td><td style="text-align: left;">nggwa-nkwing</td><td style="text-align: left;">（蛇）盘着</td></tr><tr class="even"><td style="text-align: left;">/ŋʷ/</td><td style="text-align: left;">ngw</td><td style="text-align: left;">/ŋʷa⁴/</td><td style="text-align: left;">ngwaz</td><td style="text-align: left;">瓦</td></tr><tr class="odd"><td style="text-align: left;">/ŋ̥ʷ/</td><td style="text-align: left;">hngw</td><td style="text-align: left;">/θɤu⁶ ŋ̥ʷi²/</td><td style="text-align: left;">sheuc-hngwih</td><td style="text-align: left;">打瞌睡</td></tr><tr class="even"><td style="text-align: left;">/w/</td><td style="text-align: left;">u</td><td style="text-align: left;">/wa¹/</td><td style="text-align: left;">ua</td><td style="text-align: left;">挖</td></tr><tr class="odd"><td style="text-align: left;">/w̥/</td><td style="text-align: left;">hw</td><td style="text-align: left;">/w̥a⁵/</td><td style="text-align: left;">hwaix</td><td style="text-align: left;">扒</td></tr><tr class="even"><td style="text-align: left;">/ɦ/</td><td style="text-align: left;">h</td><td style="text-align: left;">/ɦau⁸/</td><td style="text-align: left;">haul</td><td style="text-align: left;">箕</td></tr><tr class="odd"><td style="text-align: left;">/h/</td><td style="text-align: left;">h</td><td style="text-align: left;">/ho³/</td><td style="text-align: left;">hov</td><td style="text-align: left;">磨</td></tr></tbody></table><h1 id="yinh-muv-heu-jerng-韵母">Yinh-Muv (Heu-Jerng) 韵母</h1><p>韵母二十五个，如：</p><table><caption>韵母</caption><thead><tr class="header"><th style="text-align: left;">i</th><th style="text-align: left;"></th><th style="text-align: left;"></th><th style="text-align: left;">in</th><th style="text-align: left;">ing</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">e</td><td style="text-align: left;">ei</td><td style="text-align: left;"></td><td style="text-align: left;">en</td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;">ien</td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;">a</td><td style="text-align: left;">ai</td><td style="text-align: left;">au</td><td style="text-align: left;">an</td><td style="text-align: left;">ang</td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;">iau</td><td style="text-align: left;"></td><td style="text-align: left;">iang</td></tr><tr class="odd"><td style="text-align: left;">o</td><td style="text-align: left;">oi</td><td style="text-align: left;"></td><td style="text-align: left;">on</td><td style="text-align: left;">ong</td></tr><tr class="even"><td style="text-align: left;">u</td><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;">ung</td></tr><tr class="odd"><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;">uang</td></tr><tr class="even"><td style="text-align: left;">er</td><td style="text-align: left;"></td><td style="text-align: left;">eu</td><td style="text-align: left;">ern</td><td style="text-align: left;">erng</td></tr></tbody></table><h2 id="sol-mingl-nggongx-vangx-说明-1">Sol-Mingl (Nggongx-Vangx)说明</h2><ol type="1"><li>in /in/、on /on/、ern /ɤn/、uang /uaŋ/ 韵母，以及 i介音的韵母都是借词韵母。</li><li>一般布努语把汉语中的 i（思、师）/ɿ/ 读作 er /ɤ/，如“资本” sher-bernv/θɤ¹' pɤn³'/，受普通话影响，现在也有读 i /ɿ/，即 shi-bernv /θɿ¹'pɤn³'/。但不普遍，故不列出。</li><li>介音 u 可做为声母，作声母仍写作 u，如 uoc “全”，但音标用 /w/记。</li></ol><h2id="yinh-muv-rongh-lil-sheuh-heu-jerng-rongh-sher-lil-韵母与例字">Yinh-Muvrongh Lil-Sheuh (Heu-Jerng rongh Sher-Lil) 韵母与例字</h2><p>韵母与例字列出以供发音参考，见下表。</p><table><caption>韵母与例字</caption><thead><tr class="header"><th style="text-align: center;">国际音标</th><th style="text-align: center;">韵母</th><th style="text-align: center;">例音</th><th style="text-align: center;">例字</th><th style="text-align: center;">汉字</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">/i/</td><td style="text-align: center;">i</td><td style="text-align: center;">/θi³/</td><td style="text-align: center;">shiv</td><td style="text-align: center;">写</td></tr><tr class="even"><td style="text-align: center;">/in/</td><td style="text-align: center;">in</td><td style="text-align: center;">/ɲin⁴/</td><td style="text-align: center;">nyinz</td><td style="text-align: center;">筋</td></tr><tr class="odd"><td style="text-align: center;">/iŋ/</td><td style="text-align: center;">ing</td><td style="text-align: center;">/ɕiŋ¹/</td><td style="text-align: center;">sing</td><td style="text-align: center;">新</td></tr><tr class="even"><td style="text-align: center;">/e/</td><td style="text-align: center;">e</td><td style="text-align: center;">/e³/</td><td style="text-align: center;">ev</td><td style="text-align: center;">姐</td></tr><tr class="odd"><td style="text-align: center;">/ei/</td><td style="text-align: center;">ei</td><td style="text-align: center;">/θei²/</td><td style="text-align: center;">sheih</td><td style="text-align: center;">最</td></tr><tr class="even"><td style="text-align: center;">/en/</td><td style="text-align: center;">en</td><td style="text-align: center;">/ɕen¹/</td><td style="text-align: center;">sen</td><td style="text-align: center;">真</td></tr><tr class="odd"><td style="text-align: center;">/ien/</td><td style="text-align: center;">ien</td><td style="text-align: center;">/n̥ien⁵/</td><td style="text-align: center;">hnienx</td><td style="text-align: center;">记</td></tr><tr class="even"><td style="text-align: center;">/a/</td><td style="text-align: center;">a</td><td style="text-align: center;">/pa¹/</td><td style="text-align: center;">ba</td><td style="text-align: center;">知</td></tr><tr class="odd"><td style="text-align: center;">/ai/</td><td style="text-align: center;">ai</td><td style="text-align: center;">/pai⁵/</td><td style="text-align: center;">baix</td><td style="text-align: center;">转</td></tr><tr class="even"><td style="text-align: center;">/au/</td><td style="text-align: center;">au</td><td style="text-align: center;">/au¹/</td><td style="text-align: center;">au</td><td style="text-align: center;">二</td></tr><tr class="odd"><td style="text-align: center;">/an/</td><td style="text-align: center;">an</td><td style="text-align: center;">/pan²/</td><td style="text-align: center;">banh</td><td style="text-align: center;">笨</td></tr><tr class="even"><td style="text-align: center;">/aŋ/</td><td style="text-align: center;">ang</td><td style="text-align: center;">/caŋ¹/</td><td style="text-align: center;">jang</td><td style="text-align: center;">针</td></tr><tr class="odd"><td style="text-align: center;">/iau/</td><td style="text-align: center;">iau</td><td style="text-align: center;">/piau⁵/</td><td style="text-align: center;">biaux</td><td style="text-align: center;">钞（票）</td></tr><tr class="even"><td style="text-align: center;">/iaŋ/</td><td style="text-align: center;">iang</td><td style="text-align: center;">/liaŋ²/</td><td style="text-align: center;">liangh</td><td style="text-align: center;">樑</td></tr><tr class="odd"><td style="text-align: center;">/o/</td><td style="text-align: center;">o</td><td style="text-align: center;">/lo³/</td><td style="text-align: center;">lov</td><td style="text-align: center;">断</td></tr><tr class="even"><td style="text-align: center;">/oi/</td><td style="text-align: center;">oi</td><td style="text-align: center;">/poi⁶/</td><td style="text-align: center;">boic</td><td style="text-align: center;">背（诵）</td></tr><tr class="odd"><td style="text-align: center;">/on/</td><td style="text-align: center;">on</td><td style="text-align: center;">/nton²/</td><td style="text-align: center;">ndonh</td><td style="text-align: center;">猜</td></tr><tr class="even"><td style="text-align: center;">/oŋ/</td><td style="text-align: center;">ong</td><td style="text-align: center;">/ɦoŋ¹/</td><td style="text-align: center;">hong</td><td style="text-align: center;">右</td></tr><tr class="odd"><td style="text-align: center;">/u/</td><td style="text-align: center;">u</td><td style="text-align: center;">/mu⁴/</td><td style="text-align: center;">muz</td><td style="text-align: center;">马</td></tr><tr class="even"><td style="text-align: center;">/uŋ/</td><td style="text-align: center;">ung</td><td style="text-align: center;">/uŋ¹/</td><td style="text-align: center;">ung</td><td style="text-align: center;">那</td></tr><tr class="odd"><td style="text-align: center;">/uaŋ/</td><td style="text-align: center;">uang</td><td style="text-align: center;">/θuaŋ⁴/</td><td style="text-align: center;">shuangz</td><td style="text-align: center;">壳</td></tr><tr class="even"><td style="text-align: center;">/ɤ/</td><td style="text-align: center;">er</td><td style="text-align: center;">/ɲcɤ⁶/</td><td style="text-align: center;">njerc</td><td style="text-align: center;">多</td></tr><tr class="odd"><td style="text-align: center;">/ɤu/</td><td style="text-align: center;">eu</td><td style="text-align: center;">/hɤu³/</td><td style="text-align: center;">heuv</td><td style="text-align: center;">云</td></tr><tr class="even"><td style="text-align: center;">/ɤn/</td><td style="text-align: center;">ern</td><td style="text-align: center;">/θɤn¹'/</td><td style="text-align: center;">shern</td><td style="text-align: center;">村</td></tr><tr class="odd"><td style="text-align: center;">/ɤŋ/</td><td style="text-align: center;">erng</td><td style="text-align: center;">/cʰɤŋ³/</td><td style="text-align: center;">qerngv</td><td style="text-align: center;">姜</td></tr></tbody></table><h1 id="sing-diauh-diauh-heu-声调">Sing-Diauh (Diauh-Heu) 声调</h1><p>布努语有八个基本调，三个变调，共十一个声调，如下表。</p><table><caption>声调</caption><colgroup><col style="width: 7%" /><col style="width: 7%" /><col style="width: 11%" /><col style="width: 7%" /><col style="width: 7%" /><col style="width: 7%" /><col style="width: 7%" /><col style="width: 8%" /><col style="width: 7%" /><col style="width: 10%" /><col style="width: 10%" /><col style="width: 8%" /></colgroup><thead><tr class="header"><th style="text-align: left;">调次</th><th style="text-align: left;">1</th><th style="text-align: left;">2</th><th style="text-align: left;">3</th><th style="text-align: left;">4</th><th style="text-align: left;">5</th><th style="text-align: left;">6</th><th style="text-align: left;">7</th><th style="text-align: left;">8</th><th style="text-align: left;">1'</th><th style="text-align: left;">2'</th><th style="text-align: left;">3'</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">调号</td><td style="text-align: left;"></td><td style="text-align: left;">h</td><td style="text-align: left;">v</td><td style="text-align: left;">z</td><td style="text-align: left;">x</td><td style="text-align: left;">c</td><td style="text-align: left;">s</td><td style="text-align: left;">l</td><td style="text-align: left;"></td><td style="text-align: left;">h</td><td style="text-align: left;">v</td></tr><tr class="even"><td style="text-align: left;">调值</td><td style="text-align: left;">33</td><td style="text-align: left;">12</td><td style="text-align: left;">43</td><td style="text-align: left;">231</td><td style="text-align: left;">42</td><td style="text-align: left;">23</td><td style="text-align: left;">31</td><td style="text-align: left;">21</td><td style="text-align: left;">44</td><td style="text-align: left;">24</td><td style="text-align: left;">54</td></tr><tr class="odd"><td style="text-align: left;">例音</td><td style="text-align: left;">/to¹/</td><td style="text-align: left;">/to²/</td><td style="text-align: left;">/to³/</td><td style="text-align: left;">/to⁴/</td><td style="text-align: left;">/to⁵/</td><td style="text-align: left;">/to⁶/</td><td style="text-align: left;">/tɬu⁷/</td><td style="text-align: left;">/to⁸/</td><td style="text-align: left;">/kɤu¹'/</td><td style="text-align: left;">/tɤu²'/</td><td style="text-align: left;">/pɤ³'/</td></tr><tr class="even"><td style="text-align: left;">例字</td><td style="text-align: left;">do</td><td style="text-align: left;">doh</td><td style="text-align: left;">dov</td><td style="text-align: left;">doz</td><td style="text-align: left;">dox</td><td style="text-align: left;">doc</td><td style="text-align: left;">dlus</td><td style="text-align: left;">dol</td><td style="text-align: left;">geu</td><td style="text-align: left;">deuh</td><td style="text-align: left;">berv</td></tr><tr class="odd"><td style="text-align: left;">汉字</td><td style="text-align: left;">深</td><td style="text-align: left;">回</td><td style="text-align: left;">敲</td><td style="text-align: left;">读</td><td style="text-align: left;">杀</td><td style="text-align: left;">死</td><td style="text-align: left;">落</td><td style="text-align: left;">咬</td><td style="text-align: left;">镰刀</td><td style="text-align: left;">兔</td><td style="text-align: left;">碗</td></tr></tbody></table><h2 id="sol-mingl-nggongx-vangx-说明-2">Sol-Mingl (Nggongx-Vangx)说明</h2><ol type="1"><li><p>声调写在声母、韵母之后，如 mungz “去”，声母是 m，韵母是ung，声调是 z。</p></li><li><p>第 1 调不标，第 2 至 8 调分别用 h、v、z、x、c、s、l表示。</p></li><li><p>第 1'、2'、3' 调从原调第 1、2、3调分化而来，调型相同，但比原调高一至二度，所以与原调归并，不另标调。</p></li><li><p>只标原调，不标变调。</p></li><li><p>除现代汉语借词外，只有少数词单读时读 1'、2'、3' 调，第 1、2、3调的变调也读这几个调。</p></li><li><p>变调规则：</p><ul><li><p>多数变调是第二个音节变调。一般第 1、2、1'、2' 调后接第 1、2、3调时，后面的第 1、2、3 调变成第 1'、2'、3' 调，如:</p><table><caption>变调示例</caption><colgroup><col style="width: 18%" /><col style="width: 23%" /><col style="width: 8%" /><col style="width: 16%" /><col style="width: 22%" /><col style="width: 11%" /></colgroup><thead><tr class="header"><th style="text-align: left;">例字</th><th style="text-align: left;">例音</th><th style="text-align: left;">汉字</th><th style="text-align: left;">例字</th><th style="text-align: left;">例音</th><th style="text-align: left;">汉字</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">nzhong-hnong</td><td style="text-align: left;">/ɳʈoŋ¹ n̥oŋ¹˙¹'/</td><td style="text-align: left;">白天</td><td style="text-align: left;">ang-ncing</td><td style="text-align: left;">/aŋ¹ nʦʰiŋ¹˙¹'/</td><td style="text-align: left;">清水</td></tr><tr class="even"><td style="text-align: left;">dla-yongh</td><td style="text-align: left;">/tɬa¹ joŋ²˙²'/</td><td style="text-align: left;">羊毛</td><td style="text-align: left;">hnang-ndleh</td><td style="text-align: left;">/n̥aŋ¹ ntɬe²˙²'/</td><td style="text-align: left;">谷的种子</td></tr><tr class="odd"><td style="text-align: left;">dla-dlev</td><td style="text-align: left;">/tɬa¹ tɬe³˙³'/</td><td style="text-align: left;">狗毛</td><td style="text-align: left;">nggeu-zev</td><td style="text-align: left;">/ŋkɤu¹ ʦe³˙³'/</td><td style="text-align: left;">鸽子</td></tr><tr class="even"><td style="text-align: left;">ruh-ang</td><td style="text-align: left;">/ʐu² aŋ¹˙¹'/</td><td style="text-align: left;">漏水</td><td style="text-align: left;">nuh-hing</td><td style="text-align: left;">/nu² hiŋ¹˙¹'/</td><td style="text-align: left;">高的人</td></tr><tr class="odd"><td style="text-align: left;">nuh-mongh</td><td style="text-align: left;">/nu² moŋ²˙²'/</td><td style="text-align: left;">富人</td><td style="text-align: left;">baih-gwaih</td><td style="text-align: left;">/pai² kʷai²˙²'/</td><td style="text-align: left;">黄花</td></tr><tr class="even"><td style="text-align: left;">ndleh-dluv</td><td style="text-align: left;">/ntɬe² tɬu³˙³'/</td><td style="text-align: left;">稻秧</td><td style="text-align: left;">doh-zev</td><td style="text-align: left;">/to² ʦe³˙³'/</td><td style="text-align: left;">回家</td></tr><tr class="odd"><td style="text-align: left;">dung-va</td><td style="text-align: left;">/tuŋ¹' ɣa¹˙¹'/</td><td style="text-align: left;">菜秧</td><td style="text-align: left;">geu-sing</td><td style="text-align: left;">/kɤu¹' ɕiŋ¹˙¹'/</td><td style="text-align: left;">新镰刀</td></tr><tr class="even"><td style="text-align: left;">hmong-ndoh</td><td style="text-align: left;">/m̥oŋ¹' nto²˙²'/</td><td style="text-align: left;">白薯藤</td><td style="text-align: left;">jang-loh</td><td style="text-align: left;">/caŋ¹ lo²˙²'/</td><td style="text-align: left;">粗针</td></tr><tr class="odd"><td style="text-align: left;">hnong-nderngv</td><td style="text-align: left;">/n̥oŋ¹' ntɤŋ³˙³'/</td><td style="text-align: left;">剑鞘</td><td style="text-align: left;">dung-dlev</td><td style="text-align: left;">/tuŋ¹ tɬe³˙³'/</td><td style="text-align: left;">小狗</td></tr><tr class="even"><td style="text-align: left;">ndlangh-lerng</td><td style="text-align: left;">/ntɬaŋ²' lɤŋ¹˙¹'/</td><td style="text-align: left;">红叶</td><td style="text-align: left;">nderngh-sing</td><td style="text-align: left;">/ntɤŋ² ɕiŋ¹˙¹'/</td><td style="text-align: left;">新柴刀</td></tr><tr class="odd"><td style="text-align: left;">shah-jauh</td><td style="text-align: left;">/θa²' cau²'/</td><td style="text-align: left;">早玉米</td><td style="text-align: left;">beh nauh</td><td style="text-align: left;">/pe²' nau²˙²'/</td><td style="text-align: left;">全吃</td></tr><tr class="even"><td style="text-align: left;">jangh-wiv</td><td style="text-align: left;">/caŋ²' vi³˙³'/</td><td style="text-align: left;">小鸡茏</td><td style="text-align: left;">ndlangh-hlov</td><td style="text-align: left;">/ntɬaŋ²' ɬo³˙³'/</td><td style="text-align: left;">竹叶</td></tr></tbody></table></li><li><p>第 1、2、3 调的量词重叠，或两个第 1调相邻的基数词相连，表示概数时，前后两个音都发生变调。如“天天”hnong-hnong /n̥oŋ¹˙¹' n̥oŋ¹˙¹'/，“家家” zev-zev /ʦe³˙³' ʦe³˙³'/，“两三”au-be /au¹˙¹' pe¹˙¹'/；“四五” dla-zu /tɬa¹˙¹' ʦu¹˙¹'/。</p></li><li><p>少数量词（名词兼作量词的）和极少数的其他词中，第 1'、2'、3'调可以变成第 1、2、3 调，如：</p><table style="width:100%;"><caption>量词变调</caption><colgroup><col style="width: 8%" /><col style="width: 11%" /><col style="width: 8%" /><col style="width: 25%" /><col style="width: 32%" /><col style="width: 13%" /></colgroup><thead><tr class="header"><th style="text-align: left;">变调</th><th style="text-align: left;">音标</th><th style="text-align: left;">汉字</th><th style="text-align: left;">原调</th><th style="text-align: left;">音标</th><th style="text-align: left;">汉字</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">ge</td><td style="text-align: left;">/ke¹'/</td><td style="text-align: left;">米筒</td><td style="text-align: left;">zheux ge shungv</td><td style="text-align: left;">/ʈɤu⁵ ke¹'˙¹ θuŋ³˙³'/</td><td style="text-align: left;">六筒米</td></tr><tr class="even"><td style="text-align: left;">banh</td><td style="text-align: left;">/pan²'/</td><td style="text-align: left;">盆</td><td style="text-align: left;">jeul banh ang</td><td style="text-align: left;">/cɤu⁸ pan²'˙² aŋ¹˙¹'/</td><td style="text-align: left;">十盆水</td></tr><tr class="odd"><td style="text-align: left;">berv</td><td style="text-align: left;">/bɤ³'/</td><td style="text-align: left;">碗</td><td style="text-align: left;">yul berv yuz</td><td style="text-align: left;">/ju⁸ pɤ³'˙³ ju⁴/</td><td style="text-align: left;">八碗饭</td></tr><tr class="even"><td style="text-align: left;">i</td><td style="text-align: left;">/i¹'/</td><td style="text-align: left;">一</td><td style="text-align: left;">be-i</td><td style="text-align: left;">/pe¹ i¹'˙¹/</td><td style="text-align: left;">三十一</td></tr><tr class="odd"><td style="text-align: left;">ndla</td><td style="text-align: left;">/ntɬa¹'/</td><td style="text-align: left;">柿</td><td style="text-align: left;">biv-ndla</td><td style="text-align: left;">/pi³ ntɬa¹'˙¹/</td><td style="text-align: left;">杮子</td></tr><tr class="even"><td style="text-align: left;">njeuh</td><td style="text-align: left;">/ɲcɤu²'/</td><td style="text-align: left;">嘴</td><td style="text-align: left;">sheuc-njeuh</td><td style="text-align: left;">/θɤu⁶ ɲcɤu²'˙²/</td><td style="text-align: left;">多嘴多舌</td></tr></tbody></table></li><li><p>第 1'、2'、3' 调在第 3 至第 8 调后也可能变为第 1、2、3调。如“十一” jeul-i /cɤu⁸ i¹'˙¹/，“骨折” lov-shongv /lo³θoŋ³'˙³/</p></li></ul></li><li><p>现代汉语借词：</p><ul><li>阴平入第 1' 调，如“飞机” fei-ji /fei¹' ci¹'/；</li><li>阳平、入声入第 8 调，如“民族” minl-sul /min⁸ɕu⁸/，“侵略”（“略”字入声） shin-lol /θin¹ lo⁸/；</li><li>上声入第 3' 调，如“总理” shungv-liv /θuŋ³' li³'/；</li><li>去声入第 2' 调，如“制度” sih-duh /ɕi²' tu²'/。</li></ul></li></ol><h1 id="gwei-sherl-shiv-sher-书写规则">Gwei-Sherl Shiv-Sher书写规则</h1><h2 id="shungv-lanv-总览">Shungv-Lanv 总览</h2><ol type="1"><li><p>以音节为单位拼写，称“字”，复合词、表示一个整体概念的双音节或三音节结构用连字符连接，称“词”，字词用空格分开。如：</p><table><caption>书写示例</caption><thead><tr class="header"><th style="text-align: left;">汉字</th><th style="text-align: left;">书写</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">头</td><td style="text-align: left;">fav</td></tr><tr class="even"><td style="text-align: left;">手</td><td style="text-align: left;">bez</td></tr><tr class="odd"><td style="text-align: left;">国家</td><td style="text-align: left;">gol-ja</td></tr><tr class="even"><td style="text-align: left;">大学</td><td style="text-align: left;">dah-yol</td></tr><tr class="odd"><td style="text-align: left;">因为</td><td style="text-align: left;">yin-ueic</td></tr><tr class="even"><td style="text-align: left;">北京</td><td style="text-align: left;">Berl-ging</td></tr><tr class="odd"><td style="text-align: left;">英格兰</td><td style="text-align: left;">Ying-gol-lanl</td></tr></tbody></table></li><li><p>四音节及以上按词分开拼写，不能分开则全部连写。如：</p><table><caption>四音节书写示例</caption><colgroup><col style="width: 30%" /><col style="width: 69%" /></colgroup><thead><tr class="header"><th style="text-align: left;">汉字</th><th style="text-align: left;">书写</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">五角星</td><td style="text-align: left;">Uv-gol-shing</td></tr><tr class="even"><td style="text-align: left;">天安门</td><td style="text-align: left;">Tien-ngan-mernl</td></tr><tr class="odd"><td style="text-align: left;">清华大学</td><td style="text-align: left;">Shing-ual Dah-yol</td></tr><tr class="even"><td style="text-align: left;">来来回回</td><td style="text-align: left;">mungz-mungz doh-doh</td></tr><tr class="odd"><td style="text-align: left;">辩证唯物主义</td><td style="text-align: left;">Bienh-singh Ngweil-uh Suv-nyih</td></tr><tr class="even"><td style="text-align: left;">中华人民共和国</td><td style="text-align: left;">Sung-ual Yinl-minl Gung-hol-gol</td></tr><tr class="odd"><td style="text-align: left;">大不列颠及北爱尔兰联合王国</td><td style="text-align: left;">Dah-Buh-lel-dien jil Berl-Ngaih-ov-lanlLienl-hol Uangl-gol</td></tr><tr class="even"><td style="text-align: left;">古生物学家</td><td style="text-align: left;">Guv-sherng-uh-yol-jah</td></tr><tr class="odd"><td style="text-align: left;">海陆空军</td><td style="text-align: left;">Hai-Lul-Kung Jen</td></tr></tbody></table></li><li><p>汉语借词优先用民族文意译，再是当地标准音拼写，其次是西南官话桂柳方言转写。</p></li><li><p>姓名分写，名连写，开头大写，两姓复合姓各自大写。如，LiaulBang（刘邦），Ngou-yang Shern-sih（欧阳椿树），Qinl-UeilYih（覃韦宇），Yo-sher-fu Sheu-dah-linl（约瑟夫·斯大林）。</p></li><li><p>姓名与职位、称呼分开，职位、称呼小写。如，Uangldungl-sih（王同志），Mol fuh-suv-yinh（莫副主任）。</p></li><li><p>百以下连写。如，nyongz-jeul-zu（二十五），jeul-zheux（十六），i-baixjeuh-jeul-yul（一百九十八）。</p></li><li><p>以百、千、万、亿为单位分词连写。如，jeul-dla-yih au-sen-wanczu-sen yul-baix jeuh-jeul-dla（十四亿二千万五千八百九十四）。</p></li><li><p>基数词可省略时，百、千、万、亿可与后面的数词连写。基数词省略请看数词篇，这里仅举例：</p><ul><li>i-baix be-jeul-dla（一百三十四）可省为 baix-be-dla（百三四）。</li><li>i-sen au-baix jeuh-jeul-zu（一千二百九十五）可省为sen-au-jeuh-zu（千二九五）</li></ul></li><li><p>序数词连写。如 dac-i（第一）。十以上同数词。</p></li><li><p>量词不连写。如 i dung nuh（一个人），be-senlung（三千个）。</p></li><li><p>量名词（非误写，与“名量词”不同，一般用于强调，类似冠词）连写。如：</p><ul><li>dungz-nuh（只人）指“人”</li><li>nggungz-ndangx（棵树）指”树“</li><li>lung-qeul（个球）指”球“</li></ul></li><li><p>日期应连写，写全则以”日“”月“区分，如 hlux-Songc hnong-nyongz-be”七月二十三日“；省略则全连写，如 hlux-Zu-zu ”五月五日“，Zu-hlux-zheux”五月六日“。</p></li></ol><h2 id="dah-sev-sher-langl-大写">Dah-Sev (Sher-Langl) 大写</h2><ol type="1"><li><p>专有名词首字母大写。如，Berl-ging（北京），Meiv-gol（美国），Shing-mingl（清明节）。</p></li><li><p>月份大写。如，hlux-Yul（八月）。月份大写是避免日期与数词连写表概数相混。如：</p><ul><li>Zu-jeuh（此处应为 Zu-Jeuh，只是举例）表示”五·二九“节（5 月 29日）</li><li>4.5，表示概数是 dla-zu，表示日期为 Dla-zu（正确应为 hlux-Dla-zu 或hlux-Dla hnong-zu，表示”四月五“或”四月五日“）</li></ul></li><li><p>具有联合意义的，各个独立部分音节首字母可大写。如，Hai-Lul-KungJen（海陆空军）。但有时书写者不知是联合，故不强制要求。</p></li><li><p>句子和诗歌行首，首字母大写。</p></li><li><p>标点符号用英文标点，书名、刊名斜体，同英语。如：</p><ul><li><p><em>Sher-Buv-Nuh Shauv-Ngan</em> waic nyiv gwei-dingh ndux hlaivgiv-nauv.</p><p>《布努文草案》的一些规定与本文不同。</p></li><li><p>Buv-jangv, buv-gwai rongh buv-hiv zhauc Sung-gol zu-jeul-zheuxlung minl-sul nzhong waic be lung.</p><p>壮族、汉族和布依族是中国五十六个民族中的三个。</p></li></ul></li><li><p>标题、标语、强调、告示、广告等具有强调意义的字词，每个音节首字母大写，可全大写。如：</p><table><caption>大写示例</caption><colgroup><col style="width: 24%" /><col style="width: 75%" /></colgroup><thead><tr class="header"><th style="text-align: center;">汉字</th><th style="text-align: center;">书写</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">人民医院（告示）</td><td style="text-align: center;">Yinl-Minl Yi-Yenh; YINL-MINLYI-YENH</td></tr><tr class="even"><td style="text-align: center;">新中国成立七十周年（标题）</td><td style="text-align: center;">Sing Sung-Gol Shing Songc-JeulSangx-Xai; SING SUNG-GOL SHING SONGC-JEUL SANGX-XAI</td></tr><tr class="odd"><td style="text-align: center;">好好学习，天天向上（标语）</td><td style="text-align: center;">Yungc-Ringh Doz-Sher, Yel Doz Yel Daux;YUNGC-RINGH DOZ-SHER, YEL DOZ YEL DAUX</td></tr></tbody></table></li></ol><h2 id="sho-sev-sher-shov-缩写">Sho-Sev (Sher-Shov) 缩写</h2><p>类似汉文，不使用首字母缩写。缩写后各部分首字母大写。如：</p><p>Nanl-ging Dah-yol（南京大学）缩写是 Nanl-Dah(南大)，不是Nanl-dah、NGDY 或 N.G.D.Y。但 Nanl-kai Dah-yol（南开大学）缩写是Nanl-kai，kai 不需要大写。</p><h1 id="beih-suh-shav-gaiv-sih-备注">Beih-Suh (Shav-Gaiv-Sih) 备注</h1><p>由于本文主要是解释语音，故将不重要的一些备注放此。</p><h2 id="sing-muv-heu-deh-声母-1">Sing-Muv (Heu-Deh) 声母</h2><table><thead><tr class="header"><th style="text-align: left;">国际音标</th><th style="text-align: left;">/kʷ/</th><th style="text-align: left;">/kʰʷ/</th><th style="text-align: left;">/ŋkʷ/</th><th style="text-align: left;">/ŋkʰʷ/</th><th style="text-align: left;">/ŋʷ/</th><th style="text-align: left;">/ŋ̥ʷ/</th><th style="text-align: left;">/w/</th><th style="text-align: left;">/w̥/</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">唇化声母</td><td style="text-align: left;">gw</td><td style="text-align: left;">kw</td><td style="text-align: left;">nggw</td><td style="text-align: left;">nkw</td><td style="text-align: left;">ngw</td><td style="text-align: left;">hngw</td><td style="text-align: left;">u</td><td style="text-align: left;">hw</td></tr></tbody></table><h3 id="唇化声母是不是多余">唇化声母是不是多余？</h3><p>唇化声母其实主要是 g、k、ng 和 hng 与 u相拼时出现的唇化现象，可拼的韵母很少。虽然可以不分成独立声母，直接解释为与u 相拼。但如此就需要引入介音 u，穷举含 u的韵母，使韵母复杂化。故保留唇化声母，可以简单理解为声母与 u相拼即可。</p><h3 id="唇化声母为何不直接使用-u-而要用-w">唇化声母为何不直接使用 u而要用 w ？</h3><p>如果使用 u 就会出现音的归属问题。比如 /ŋkʷ/ 写作 nggu，是声母。那么nggux /ŋku⁵/可成音，它是声母还是韵母，或者声韵全拼？声母不能单独成音，所以 nggux应该不是声母，但现在就有一个声母是 nggu，所以会产生混乱。最后折中，使用w 表示唇化。</p><p>那为什么 u /w/ 声母用的是 u 不是 w ？因为已经有一个 w /v/了。如果按汉语拼音的习惯将声母 u 写成 w 就会出现声母合并现象。如Sung-ual（中华）写成 Sung-wal，但 w 是 /v/，所以 ual /wa⁸/ 会被读成 wal/va⁸/。汉语拼音可以不在意这些，因为拼音只是工具，但布努文需要规避。</p><h3 id="壮语借词的韵母怎么不见了">壮语借词的韵母怎么不见了？</h3><p>壮语借词的韵母借入后不同地方借入方式不同，有的全借，包含 t、p、k、m韵尾，有的部分借，只有t、k，有的全丢掉，所以列出会导致韵母过多，且用处不大。此外，壮语借词一般是老借词，只有通双语的人可以发出，很多人发不出正确的音，所以有些地方后来全丢掉了韵尾。特别是现在很多借词都是从汉语借入，壮语韵尾就没必要了。</p><h2 id="gwei-sherl-shiv-sher-书写规则-1">Gwei-Sherl Shiv-Sher书写规则</h2><h3 id="为什么用连字符而不是连写">为什么用连字符而不是连写？</h3><p>连写参考壮文，基本只能用混乱形容。音节文字分词是一个大问题，要么像越南国语字都不连写，要么使用汉字，参考汉语拼音则是混乱的源头。举个例子：</p><p>壮文书写习惯：</p><ul><li>Sung'ualyinlminlgungholgol</li><li>Sung'ual yinlminl gungholgol</li><li>Sung'ualyinlminlgungholgolsungyangsernghjihjil中华人民共和国中央政治局</li><li>Sung'ualyinlminlgungholgol Sungyangsernghjihjil</li><li>Sung'ual yinlminl gungholgol Sungyang sernghjih jil</li></ul><p>越南国语字书写习惯：</p><ul><li>Sung Ual Yinl Minl Gung Hol Gol</li><li>Sung Ual Yinl Minl Gung Hol Gol Sung Yang Serngh Jih Jil</li></ul><p>和布努文新规定:</p><ul><li>Sung-ual Yinl-minl Gung-hol-gol</li><li>Sung-ual Yinl-minl Gung-hol-gol Sung-yang Serngh-jih Jil</li></ul><p>哪个更好辩认不言而喻。而且最奇葩的是，有些东西还不能分词，不然有损国威，就像Jesus Christ 永远不可能缩写成 J.C. 一样。</p><p>民族固有词则更混乱。如：</p><p>gabez（手）、ga'lox（嘴）、gamongz（眼睛）</p><p>是由 ga加某一事物合成的，但是写成一个字就看不出来了，更像是外语。新规定则是：</p><p>ga-bez、ga-lox、ga-mongz</p><p>音节文字，怎么分词永远是个问题。连写是不成熟的表现，也就壮文当了小白鼠。最新的<ahref="http://www.moe.gov.cn/jyb_sjzl/ziliao/A19/201001/t20100115_75607.html"title="《汉语拼音正词法基本规则》">《汉语拼音正词法基本规则》</a>已经开始使用连字符了，放弃了以前的成语连写传统，shàngshàngxiàxià成了 shàngshàng-xiàxià。</p><p>综上，如果要规避音节文字书写规则的问题，可以参考《汉语拼音正词法基本规则》。只要里边写的规则，自己制定的都没有，那自己的书写规则可以说非常实用了。《汉语拼音正词法基本规则》有很多相互龃龉的地方，学院派作风不值得认真学习。</p><p>用连字符就比越南国语字好辨认字词的归属，而且一看便知字词的音节，不需要像壮文制定各种规则推测。</p><h3 id="为什么优先使用民族词意译">为什么优先使用民族词意译？</h3><p>因为音译是民众自发适应新事物的方式，正音便是规范化。举个例子，国名：</p><ul><li>Sung-ual Yinl-minl Gung-hol-gol</li><li>Meiv-lil-jien Hol-sungh-gol（美利坚合众国）</li><li>Dah-Buh-lel-dien jil Berl-Ngaih-ov-lanl Lienl-hol Uangl-gol</li></ul><p>可以使用民族习惯写成：</p><ul><li>Gol Gung-hol Buv-Nuh Sung-ual（国 共和 人民 中华）</li><li>Gol Si-rongh Meiv-lil-jien（国 联合 美利坚）</li><li>Gol-Wongh Si-rongh Buh-lel-dien-Langl beuv Ngaih-ov-lanl-Seu（国王联合 不列颠 大 及 爱尔兰 北）</li></ul><p>用 Seu 代替 “北” 是布努语的习惯，Seu 有“上”之意，也可使用汉借词Berl。但是出于习惯仍保留汉语顺序的国名称呼，就像 telephone保留“德律风”老翻译一样。</p><h3 id="月份大写">月份大写</h3><p>十月以上一般用特殊词汇，故不会使 hlux-Jeul-i ”十月一“与 hlux-Jeul-i”十一月“相混。</p><ul><li>十月一般作 hlux-Ngeil(-wiv)</li><li>十一月作 hlux-Ngeil-langl</li><li>十二月作 hlux-Serng ”月年“、hlux-Laz ”月腊（也有‘末月’之意）“</li></ul><p>上面指的是农历，新历十月以上常用汉借词：</p><ul><li>十月：Sil-yel</li><li>十一月：Sil-i-yel</li><li>十二月：Sil-erh-yel</li></ul><h3 id="标点符号">标点符号</h3><p>不用中文标点是因为使用的是西方字母，再使用中文标点需要换键盘，不方便。</p><h3id="具有联合意义的词为什么不强制要求大写">具有联合意义的词为什么不强制要求大写？</h3><p>因为不是所有人都知道这个词具有联合意义。</p><h3 id="为什么不允许首字母缩写">为什么不允许首字母缩写？</h3><p>布努语是音节文字，首字母缩写不知所言。比如 Berl-ging Yeul-dienhDah-yol 按首字母缩写是 BYD，或者按壮文缩写规则 B.Y.D。这个怎么读？</p><ul><li>Bi-Ya-Di，乍一看读法</li><li>Ba-Ya-Da（八-压-搭），名称音读法</li><li>Bee-Wai-Di，英文字母音读法</li></ul><p>上面除了第一个是瞎扯淡，其他两种读法都是真实存在的，“名称读”肯定是推荐读法，BYD的中文名称音读是Bie-Yi-Die（憋-依-跌）。但是我相信不会有人喜欢这种读法，否则 DNA就应该是Die-Nie-A（跌-捏-啊）。而且这种缩写方式与外文缩写相撞，不伦不类。</p><blockquote><p>不要疑惑，汉语拼音的字母有“本音”、“名称音”和“呼读音”三种，前两种都是大专家制定的。第三种是前两种在教学完全不适用后，老师们使用的“啊、波、次、的”读法，最后才被添加到字母读法中。大家所了解的一般是这种从基层发展出来、实用却没有任何地位的读法。</p></blockquote><h1 id="后语-shav-giv-njerng">后语 Shav-Giv-Njerng</h1><p>我知道文字的东西很无聊，但是当这些东西和自己联系上之后，再无聊的事自己也觉得很有意义。</p>]]></content>
    
    
    <categories>
      
      <category>SherBuvNuh</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SherBuvNuh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>五笔输入法入门</title>
    <link href="/2023/04/17/wubi-introduction/"/>
    <url>/2023/04/17/wubi-introduction/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>在现在这个智能时代，拼音输入法已经非常快了，而且在某种程度上，拼音输入法更适合普通人的输入——你怎么说就怎么打。然而专业打字或者生僻字输入，又或者小词组、单字输入，五笔的优点还是很明显的。正常情况下我都使用拼音输入法，但是碰到上面的的问题时，我基本是五笔解决。</p><p>五笔输入法有一个学习门槛。不过不是五笔难学，而是教五笔的人不知道怎么教。上来就是一堆字根，大家什么都不知道就直接背字根，自然就和背英语单词一样。</p><p>我去年曾决定学五笔，在学习过程中还是发现了很多有趣的东西。因此今天打算把五笔学习的一些技巧分享出来，可能并不科学，但我觉得对于五笔入门还是足够的。看了之后多久能够熟练打五笔我不敢说，但是看完一个小时内你能用五笔打字是肯定的。</p><p>五笔一般来说有三种：86 五笔、98 五笔和新世纪五笔。其中 86五笔出现最早，普及比较高，98五笔重码率较低，新世纪五笔，嗯，对的。我学的是 86五笔，所以后面的教程只对 86五笔有用。如果不知道自己用的是什么，一般来说就是 86 五笔。</p><h1 id="五笔入门">五笔入门</h1><h2 id="五笔的基本知识">五笔的基本知识</h2><p>开始五笔之前，我们需要回想一下小学的知识，汉字基本笔画有几笔？五笔，分别是横、竖、撇、点、折。请用小学知识，不要想“永字八笔”是哪八笔。</p><p>五笔输入法叫五笔，不是需要敲键五次，而是使用了汉字的五个基本笔画。请看下面的图：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/wubi1.jpg"alt="五笔字根图" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/wubi.jpg"alt="五笔字根分区" /></p><p>上面这个五笔字根图，将五笔分为五个区域，每个区域有五个按键：</p><ol type="1"><li>横区，G-A 五个按键，其中 G、F、D、S 和 A又分别对应汉字五笔：横、竖、撇、点、折。</li><li>竖区，H-M 五个按键，其中 H、J、K、L 和 M又分别对应汉字五笔：横、竖、撇、点、折。</li><li>撇区，T-Q 五个按键，其中 T、R、E、W 和 Q又分别对应汉字五笔：横、竖、撇、点、折。</li><li>点区，Y-P 五个按键，其中 Y、U、I、O 和 P又分别对应汉字五笔：横、竖、撇、点、折。</li><li>折区，N-X 五个按键，其中 N、B、V、C 和 X又分别对应汉字五笔：横、竖、撇、点、折。</li></ol><table><caption>五笔的结构，根据字根的第一第二划就可以找到按键</caption><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">横</th><th style="text-align: center;">竖</th><th style="text-align: center;">撇</th><th style="text-align: center;">点</th><th style="text-align: center;">折</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">横区</td><td style="text-align: center;">G</td><td style="text-align: center;">F</td><td style="text-align: center;">D</td><td style="text-align: center;">S</td><td style="text-align: center;">A</td></tr><tr class="even"><td style="text-align: center;">竖区</td><td style="text-align: center;">H</td><td style="text-align: center;">J</td><td style="text-align: center;">K</td><td style="text-align: center;">L</td><td style="text-align: center;">M</td></tr><tr class="odd"><td style="text-align: center;">撇区</td><td style="text-align: center;">T</td><td style="text-align: center;">R</td><td style="text-align: center;">E</td><td style="text-align: center;">W</td><td style="text-align: center;">Q</td></tr><tr class="even"><td style="text-align: center;">点区</td><td style="text-align: center;">Y</td><td style="text-align: center;">U</td><td style="text-align: center;">I</td><td style="text-align: center;">O</td><td style="text-align: center;">P</td></tr><tr class="odd"><td style="text-align: center;">折区</td><td style="text-align: center;">N</td><td style="text-align: center;">B</td><td style="text-align: center;">V</td><td style="text-align: center;">C</td><td style="text-align: center;">X</td></tr></tbody></table><p>二十六个字母多一个 Z，用来做万能建。</p><p>好的，五笔的知识说完了。</p><h2 id="拼字规则">拼字规则</h2><p>知道五笔的规则就行了，我们开始拼字。五笔有几个规则，之前在王码的网站能够下载五笔的教材，人家还总结了几个规则，现在找不到了，我就自己总结规则：</p><ol type="1"><li>分字根。五笔字根上经常出现的杂乱无章的部首，一般是汉字可以分化的最小单位，比如“木”。大家不用担心怎么区分字根，其实不用，就当作一个字你觉得能分几个就行了。举个例子，“字”能分成几个？多半就是“宀”和“子”，这就是字根了。</li><li>写字。用脑子写字就行了，按照字根的第一第二划找按键。要确定某个区域就看字根的第一划，要确定某个键就看第二划。比如“白”是一个字根，第一划是“丿”，在撇区（T-Q），第二划是“丨”，在TREWQ 横竖撇点折 —— 第二个，也就是R。好的，你可以看看“白”是不是在这里。再试试，“王”字在哪里？1、2、3、4、5，“王”的第一划是“一”，所以在横区（G-A），第二划是“一”，所以对应 GFDSA横竖撇点折 —— 第一个，也就是 G。看到了吧。“大” 呢？横撇 —— 所以是D。</li><li>不够四键就按照字的结构区分。字有左右、上下和杂合三种结构，分别分布在每个区的第一、二、三键。举个例子，“的”是左右结构，找第一个字根“白”是“撇竖”R，第二个字根“勹”是“撇折” Q，第三个字根是“丶” Y，所以“的”是RQY。不够四笔，加一个码，叫做“补码”，左右结构，按字的最后一笔所在的区域的第一、二、三键区分结构。“的”最后一笔在点区，还是左右结构，左右、上下、杂合在点区分别对应Y、U、I，所以就是 Y，最后确定“的”是 RQYY。</li><li>同一笔画构成的字根，有多少划，字根就在第几个按键。举个例子，“三”都是由“一”构成，有三划，所以在横区（GFDSA）的第三个，也就是D，同理“二”有两划在第二个 F，“一”只有一划在第一个G。再看“丨”在竖区（HJKLM），有一划在 H，“刂”有两划在 J，“Ⅲ” 三划，在K。有个反例是“目“”日“”口”，中间的笔画依次减少，但却在分别在H、J、K。</li><li>猛的一看，看起来差不多的字在一个区域。这就需要大家的抽象能力了。比如“五”“(青字头)”和“王”差不多，所以都在G。“川” 和 “Ⅲ”差不多所以在K，类似的还有“大”“犬”“石”和“古”，都差不多，所以在 D。</li></ol><h2 id="学以致用">学以致用</h2><p>学完了，开始打字，拼写。</p><h4 id="布">布</h4><p>可以分为(横撇)、冂和丨。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230419111543.png"alt="布 字字根" /></p><ol type="1"><li>(横撇)：第一第二划“横撇”在横区（GFDSA）第三个，即 D。</li><li>冂：第一第二划“竖勾”在竖区（HJKLM）第五个，即 M。</li><li>丨：“竖”在竖区（HJKLM）第一个，即 H。</li><li>结构：最后一笔在竖区，是上下结构（(横撇)和巾），对应第二个 J。</li></ol><p>“布”的五笔是 DMHJ。</p><h4 id="努">努</h4><p>可以分为女、又和力。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230419111840.png"alt="努 字字根" /></p><ol type="1"><li>女：第一第二划“折撇”在折区（NBVCX）第三个，即 V。</li><li>又：第一第二划“折捺（点）”在折区（NBVCX）第四个，即 C。</li><li>力：特殊记忆，“力”在 L 键，毕竟它读作 LI。</li><li>结构：上下结构，最后一划是丿但是 86五笔搞错了，把笔画弄成了最后一笔是折勾，所以最后一笔在折区（NBVCX），上下结构在第二个，即B。</li></ol><p>“努”的五笔是 VCLB。</p><blockquote><p>这里的“努”字三个码就可以打完了，因为它是常用字，可以三个码打完叫三级简码。同理，还有二级简码和一级简码，分别只需要敲两个码和一个码。</p></blockquote><p>从这里可以看到，86五笔还是有点问题的，特别是笔画上存在毛病。不过问题不大，因为只打前面三个就出现“努”了。</p><p>除此之外，竖区域的字根分布不是很规范，竖区一般特殊记忆，因为竖区很多和“口”字有关。</p><h4 id="语">语</h4><p>可以分为讠、五和口。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230419112321.png"alt="语 字字根" /></p><ol type="1"><li>讠：讠和“言”相似，根据规则五，可以知道“言”的第一第二划是“点横”，在点区（YUIOP）第一个，即Y。</li><li>五：五和王相似，根据规则五，可以知道“王”在 G, 所以五也在 G。</li><li>口：目、日、口特殊记忆，在 H、J、K 键，笔画依次减少，也可以说“口”是K 音（kou），即 K。</li><li>结构：左右结构（言和吾）。最后一笔是横，在横区（GFDSA）第一个，即G。</li></ol><p>“语”的五笔是 YGKG。</p><h4 id="是">是</h4><p>可以分为日、一和止。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230419114109.png"alt="是 字字根" /></p><ol type="1"><li>日：目、日、口特殊记忆，在 H、J、K 键，笔画依次减少，所以是 J。</li><li>一：只有一划，在横区（GFDSA）第一个，即 G。</li><li>止：第一第二划是竖横，在竖区（HJKLM）第一个，即 H。</li><li>结构：上下结构。最后一划捺（点）在点区（YUIOP），上下结构是第二位，所以是U。</li></ol><p>“是”的五笔是 JGHU。“是”属于一级简码，只需要一个 J, 也可以当作三级简码JGH，或者全码 JGHU。</p><h4 id="中">中</h4><p>可以分为口、丨。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230419112404.png"alt="中 字字根" /></p><ol type="1"><li>口：目、日、口特殊记忆，在 H、J、K 区，口是 K。</li><li>丨：第一划是竖，位于竖区（HJKLM），笔画是一，所以是 H。</li><li>结构：杂合结构，最后一划是竖，在竖区（HJKLM）第三个，即 K。</li></ol><p>“中”的五笔是 KHK。“中”字属于一级简码，只需要一个 K即可，也可以当作二级简码，也就是 KH，或者三级简码 KHK。</p><h4 id="国">国</h4><p>可以分为囗、王和丶。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230419112814.png"alt="国 字字根" /></p><ol type="1"><li>囗：特殊记，在L，这和“口”不是一个字，是“围”的古字“囗（wei）”，全包围结构使用，“口（kou）”用于偏旁。</li><li>王：第一划第二划是横横，位于横区（GFDSA）第一个，即 G。</li><li>丶：只有一划是点，位于点区（YUIOP）第一个，即 Y。</li><li>结构：杂合结构。最后一笔点，杂合结构在点区（YUIOP）第三个，即I。</li></ol><p>“国”的五笔是 LGYI。“国”字属于一级简码，只需要一个 L即可，也可以是三级简码 LGY，或者全码 LGYI。</p><p>这里又出现了竖区（HJKLM）的特殊字符“囗（wei）”，位于L，同在这里的还有“力”“田”“甲”“车”“皿”“罒”“四”，这些字都差不多。例如“皿”“罒”和“四”，“田”“甲”和“车”。当然，有人肯定会疑惑，“车”哪像了？相信我，真的像。</p><h4 id="少">少</h4><p>可以分为小、丿。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230419114943.png"alt="少 字字根" /></p><ol type="1"><li>小：“小”类似“氺”和”水“，”水“类似于”氵“所以三点水由三个点构成在点区（YUIOP），满足规则四，不用找了，我下面附有。所以是I。</li><li>丿：撇区（TREWQ）第一个，所以是 T。</li><li>结构：上下结构，最后一划在撇区（TREWQ），上下结构是第二个，即R。</li></ol><blockquote><ol start="4" type="1"><li>同一笔画构成的字根，有多少划，字根就在第几个按键。举个例子，“三”都是由“一”构成，有三划，所以在横区（GFDSA）的第三个，也就是D，同理“二”有两划在第二个 F，“一”只有一划在第一个G。再看“丨”在竖区（HJKLM），有一划在 H，“刂”有两划在 J，“Ⅲ” 三划，在K。有个反例是“目“”日“”口”，中间的笔画依次减少，但却在分别在H、J、K。</li></ol></blockquote><p>“少”的五笔是 ITR，属于二级简码可以 IT 打出，也可以当作三级简码 ITR打出。</p><h4 id="数">数</h4><p>可以分为米、女和攵。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230419115841.png"alt="数 字字根" /></p><ol type="1"><li>米：米有四个点，和“灬(四点底)”有点类似，都是点，还有四划，按照规则四知道在点区（YUIOP）第四个，即O。类似的字体还有”火“、“亦”字底、“业”字头。</li><li>女：第一第二划是折撇，在折区（NBVCX）第三个，即V。同键盘的还有“巛””九““刀”“彐”和”臼“。"刀"类似于”九“，”彐“类似于”臼“。</li><li>攵：第一第二划是撇横，在撇去（TREWQ）第一个，即 T。</li><li>结构：左右结构，最后一划是捺（点），在点区（YUIOP），左右结构是第一个，所以是Y。</li></ol><p>”数“的五笔是 OVTY。这是一个三级简码字，可以 OVT 打出，也可以使用全码OVTY 打出。</p><h4 id="民">民</h4><p>可以分为巳和七。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230419121412.png"alt="民 字字根" /></p><ol type="1"><li>巳：第一第二划是折横，在折区（NBVCX）第一个，即N。类似的还有“已”、“眉“字头和”心“”忄“”忝“字底和”羽“。”羽“字在这里可能和日常书写中”羽“字一般都写成”ᴲᴲ(两个反过来的E)“有关。</li><li>七：”七“类似于”匚“，所以是横折，在横区（GFDSA）第五个，即A。类似的还有“弋”“工”“戈”“廿”和“(黄字头)”。从“(黄字头)”又衍生出“艹(草字头)”。</li><li>结构：杂合结构，最后一笔是勾（折），在折区（NBVCX），杂合是第三个，即V。</li></ol><p>“民”的五笔是 NAV。二级简码，可以直接 NA 打出，也可以当作三级简码 NAV打出。</p><h4 id="族">族</h4><p>可以分为方、(撇横)、(撇横)和大。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230419122921.png"alt="族 字字根" /></p><ol type="1"><li>方：第一第二划是点横，在点区（YUIOP）第一个，即 Y。</li><li>(撇横)：第一第二笔是撇横，在撇区（TREWQ）第一个，即 T。</li><li>同上。</li><li>大：第一第二笔是横撇，在横区（GFDSA）底三个，即 D。</li></ol><p>“族”的五笔是 YTTD。三级简码，可以直接 YTT 打出，也可打全码 YTTD。</p><h3 id="需要注意的东东">需要注意的东东</h3><h4 id="字根很多">字根很多</h4><p>我们上面拼字很幸运，没有碰到难字，不过这还是难以避免的，比如“繁”“藏”“疆”“癰”“龘(三个龙的繁体)”。</p><p>五笔拼字的更多规则：</p><ol type="1"><li>字根数多于四个，只选择第一、二、三和最后一个字根。比如“繁”，按照正常拼写是T（撇横）X（母，没有两点与横）G（一）U（冫，两点）T（攵）X（幺）I（小）。直接选取前三码和最后一码，即TXGI。</li></ol><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230419155042.png"alt="繁 字字根" /></p><ol type="1"><li>打词组时，二字词组各打前两个码。例如“放假”是YTWN（方攵亻己）。三字词组前两二字打一码，后一个字打两码。比如“天然港”是GQIA（一夕氵廿）。四字词组每个字各打一个码，比如“刚正不阿”，直接是MGGB（冂一一阝）。多字词组，即四字以上，则打前三个字的第一个码和最后一个字的第一个码。如“中华人民民主共和国”是KWWL（口亻人囗），“美利坚合众国”是UTJL（丷禾刂囗）。注意，打词组不能使用一级简码。</li></ol><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230419162102.png"alt="刚正不阿" /></p><ol type="1"><li><p>打字第一定律：能少打一个码就少打一个码。比如“是”，J可以做到就尽量不选择JGHU。使用空格键上屏。一级简码字在文章开始第二张图每个字母旁。一共二十五个，不用记，自己试试只打一个键，出来的就是一级简码，用久了自然就记得。</p></li><li><p>每个区域的笔画名称可以通过区域首个键双击和 LL打出。比如横（一）是 GGLL，竖（丨）是 HHLL，撇（丿）是 TTLL，点（丶）是YYLL，折（乛）是 NNLL。</p></li><li><p>键名。键名指的是按键上可以独立成字的字，位于字根表的左上角。例如“木”在S 键怎么打出？敲打四次 S 即可，即 SSSS。再如“大”在 D，所以“大”是DDDD。</p></li><li><p>偏旁。偏旁是指汉字的组成部分，不是字根，只是和字根很像。比如“幺（绞丝旁）”在X键怎么打出？简单，先敲一次偏旁所在的键，然后按照笔画一笔一笔拼出。笔画超过四码就取最后一码做第四码。比如“丁”在 S 键，要打出“丁”需要先打 S，然后是横竖（一丨），所以是 SGH。再如“耳”在 B 键，先打 B键，然后是横竖竖横横横（一丨丨一一一），所以取前两码加最后一码，即BGHG。 再如“攵”在 T 键，先打T，然后是撇横撇捺（点）（丿一丿乀），选前两码加最后一码，即TTGY。</p></li></ol><h4 id="练五笔的技巧">练五笔的技巧</h4><ol type="1"><li>五笔是不是得会写字？</li></ol><p>刚学五笔会觉得很无力，因为自己都不会写字了还怎么想字怎么写？其实五笔就是一个习惯的问题。我现在打五笔，一般不会想这个字怎么写，而是习惯就打出来。如果有人问我“不”字怎么打，我可能会卡顿，但是给我一个键盘我就会敲—— 事实如此。</p><p>刚学五笔的时候也碰到过打字太慢的问题，所以练五笔的那一阵子我都没有发博客，因为速度太慢了，我没那么多时间，但是久了习惯了速度自然就上来了。</p><ol start="2" type="1"><li>打词组还是单字？</li></ol><p>这个看个人。我刚开始也觉得先练单字，习惯了再换二字、三字……但是我发现自己没有习惯的那天，而是某次誊抄词条发现，自己打词组速度似乎更快。</p><ol start="3" type="1"><li>是不是看了这些技巧就不用记字根了？</li></ol><p>不然，练五笔最终还是会回到记词根那一步。但是，但是，学会五笔才知道字根为什么这样，而不是背完字根就知道五笔了。等到你习惯五笔了，你就会知道，原来字根是拿来总结的，不是拿来初学的。即使是现在我也不能说出各个词根在哪里，至少说不全。所谓“王旁青头兼五一，夏芒芒夏暑相连，秋处露秋寒霜降……”</p><ol start="4" type="1"><li>怎么学五笔？</li></ol><p>学五笔需要一个字根表，一个网站用于查询五笔。为什么？因为五笔，无论是86 五笔还是 98五笔、新世纪五笔，总有一些设计上的不足，顾虑不到汉字的书写顺序。所以你即使拼对了但就是打不出来。五笔，复杂字很轻松就可以打出来，但是简单的字一般就比较难了，所以你需要一个可以查询五笔码的<ahref="https://www.52wubi.com" title="五笔码查询">网站</a>。</p><p>此外，要善用 Z键。我说过这是一个万能键，实际上是学习键。在大多数输入法中，对于一个你不会拼的字，你可以先输入Z，然后打拼音，输入法就会提示你这个字的五笔</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230419193537.png"alt="Z 键学习键" /></p><p>举个例子，“龘（三个繁体龙）”只需要UEGD（立月一三），“闘”大家多半不会读，但是只需UGKF（门一口寸）即可，谁在乎它读作什么？“卐（万字符）”只需NGHG（乙一丨一）。</p><p>但简单的字五笔就有点不得行了：戌、戍、戊、戎。我知道有些人连这些字都分不清：横戌(xǖ)点戍(shù)戊(wù)中空，十字交叉读作戎(róng)。</p><p>正确拼法是：</p><ol type="1"><li>戌，DGN 丆一乀</li><li>戍，DYNT 丆丶乀丿</li><li>戊，DNY 丆乀丶</li><li>戎，ADE 弋（横撇），杂合结构</li></ol><p>所以多练吧。马克思保佑你！</p><h1 id="后语">后语</h1><p>网上的五笔字根图都是有水印的，自己一直没有做五笔教程就是因为使用别人的图需要带水印。前一阵子想自己做一个字根图，但是上面的字根很多都是打不出来的。我也想知道网上的字根图怎么做的，但是没办法，找不到制作方法。</p><p>后来索性，一不做二不休，通过遮挡的方式制作字根，也就是选好一个字，然后使用同背景色的东西遮住，勉强做成字根。但是太费时间了，我没有那么多功夫，所以直接作罢，随便到网上选了一张没有水印的，想找一张没有水印的图确实很难。</p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>五笔</tag>
      
      <tag>输入法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>布努文介绍</title>
    <link href="/2023/04/16/sher-buv-nuh-gaih-sauh/"/>
    <url>/2023/04/16/sher-buv-nuh-gaih-sauh/</url>
    
    <content type="html"><![CDATA[<h1 id="前言-shav-ha-deh">前言 Shav-Ha-Deh</h1><p>原是本想着先写 Arch Linux系统里的双显卡和五笔教学，但是后来发现双显卡内容太复杂了，自己要是真写，可能篇幅很大；而我又一直没有一个属于自己的五笔字根图，用别人的总是有水印，又不能去掉。因此这两者我打算先搁置，直接切入布努文。</p><p>Ha-deh shiangv-shiv Arch Linux hih-dungv waic shuang-sienv-kav ronghzu-bil jauh-yol. Zhax-gul nggongx shuang-sienv-kav waic shavhungv-ndaux, yav sen shiv kov-nerngl sher njerc hai mungz; jungv yic gavmongh-mongh gav waic dul-zu-bil, yungc muh waic hnyi-mongh sheiv-yinl,yic mah-daux daiv-ov. Nu-hu, shav-nauv jungv shiangv nzol-nzeuz,sheuc-sheuz gox-beuc sher-buv-nuh.</p><h1 id="布努文的发展-sher-buv-nuh-waic-fal-sienv">布努文的发展Sher-Buv-Nuh Waic Fal-Sienv</h1><p>原先是打算好好收集布努语的资料，然后写一篇类似于综述的文章对布努语做一个简要的概述，但是现在没有时间了，只能打消这个计划。</p><p>首先讲讲布努语是什么人在用。在我国的民族区分里，布努人属于瑶族人，一般称之为“布努瑶”。国内瑶族主要分为三种：自称“勉”的勉瑶，自称“布努”的布努瑶和自称“拉珈”的拉珈瑶，分别使用勉语、布努语和拉珈语，民族人数也依次减少。</p><p>三种语言在建国之后在政府的帮助下都创建了自己的拉丁文字。勉瑶在国外也有分布，所以国外政府也为勉瑶创建了文字，与国内不大相同。1984年，美、泰等国的勉瑶代表团访问中国，与相关勉文工作者商讨，最后在世界范围内统一了勉文。</p><p>在国外勉瑶的推广下，勉文发展还是不错的。不过布努瑶和拉珈瑶没有那么强大的海外同胞，直接被淹没在历史的海洋中。当现代人听到“瑶文”“瑶语”时，一般指的是勉文、勉语。想要布努文发展壮大，现在看来只能是让哪个国家突然创造出一种不同于国内的文字，政府才把它当宝。</p><p>闲话少叙。布努文是拼音文字，南方是出了名的“隔山不同语，过河非乡音”，拼音文字想在南方一统天下，除非政府强力推行，否则根本行不通。最简单的例子就是拉丁壮文作为广西壮族自治区的官方文字之一，基本没几个人看懂。一般学了拉丁壮文的人最后还是用拉丁壮文当作拼音去输入壮族人的方块壮字，也就是老壮文。方块壮文叫做“字生”，和越南的“字喃”基本一个构词方式。</p><p>创造拼音文字又不进行正音，所以除了勉文，其他两种文字基本没啥影响。在不正音的情况下，布努文有三个标准音，也就是以三个地区的口音制定文字方案，重点是还不进行推广。我所能找到的瑶文课本可以追溯到1988 年盘承乾老先生的《苗瑶课本》，然后就没了到现在。</p><p>2008年，著名的苗瑶学者蒙朝吉和蒙凤姣共同编著的《瑶汉词典（布努语）》出版，布努语才有了较为系统的、与汉语相对的词典。然而这本词典是基于弄京语音，也就是三大标准之一，与其他的标准音不大一样。在编撰前言两位先生也说了原因，但是我觉得还是有点可惜。</p><p>壮文在改武鸣音之前使用的是都安音，导致很多壮族人的口音都趋向都安口音。结果不知何时汉人专家介入标准音的制定，将标准音扯到了离首府比较近的武鸣地区，导致现在的标准壮话说起来像官话、白话，因为武鸣音实际上受官话影响很大。</p><p>武鸣音标准化有汉人介入，也就导致了很多想当然的壮文对话。举个例子，壮文教程会告诉你，两个壮族人见面会说“Mwngzndei”，这相当于什么呢？很简单，两个英国人见面说“Yougood”，这是“你好”的直译。“医院”壮文写作yihyen，这是西南官话“医院”的音译，而与壮语类似的泰语是合成词，写成壮文是ranzmo，训成汉字即为“家巫（医）”，也就是“巫医的家”。壮族有生病找魔公（boujmo）的习惯，所以魔公一般懂医。</p><p>直接使用汉语方言不是不行，只是没必要。有些人说，翻译成ranzmo，民间也不会使用，因为民间已经习惯了使用转音。我觉得不然。中国一直以来都有官方修史、修典的习惯，清末刚开始接触西方物件的时候，清政府没有时间重新为洋人修一本字典，所以当时人们直接把telephone叫做“德律风”。难道现在也要有人反驳我说：就算翻译成“电话”，民间也不会使用，因为民间已经习惯了使用音译？</p><p>如果新中国修字典的时候只写“德律风”，大家肯定都不会使用“电话”一词。我们改变不了，但可以给予它更多的选择，例如在编写壮文字典的时候标注“医院”可以写成yihyen 和 ranzmo两种形式，就像字典把“德律风”和“电话”都标注出来一样。</p><p>说到这里我就想到布努语中一个很奇葩的现象，就是布努人面对新事物的无奈之举。在布努语中，白菜叫做va berl-shaih，训做“菜 白菜”。也就是说，白菜一词进入布努语时，当地人不知道“白菜”中的“菜”是什么意思，就以为是个名字，所以出现这种标注式汉词借入。</p><p>花很大篇幅讲壮文，其实就是想说，音节文字拼音化不是一个好选项。越南文能够拼音化是因为越南语没有我们想象中的那么多多音字。然而壮语不同，壮语比汉语还倾向于使用单音节词，这种时候拼音化区别真的很大——你得读出来才知道是啥意思，基本就和日本音译外语假名一样。同样，作为比壮语还要奇葩的布努语—— 可以多达 12、13 个声调 ——拼音化的后果更加严重。即使是学了布努文并用来写字的我，在看自己的字时都觉得根本不能跳读，得从头看完整句话。</p><p>截至目前，我基本还是没有谈到太多关于布努语、布努文的事，下面我会说说拉丁布努文的缺点，而且是自己切实感觉到的。</p><h2 id="同义不同音-yih-sheu-hlaiv-ga-heu-ndux-hlaiv">同义不同音 Yih-SheuHlaiv Ga-Heu Ndux-Hlaiv</h2><p>布努语三大标准音：弄呈、弄京和梅珠。前两者离得比较近，自称bov-noh(包瑙)，梅珠音才是buv-nuh(布努)，所以布努瑶以前的标准音之首是梅珠。只是后来有人觉得梅珠口音受壮语影响大，所以又觉得两弄更适合作为布努人的标准音。</p><p>个人的看法，梅珠音还是应该是标准音，这就要从音变说起。今天的第一个词：buv。buv在布努语中是“父”的意思，属于词头，用来和一些字组合，例如buv-njerngc(男性)，buv-mpal(女性)，buv-nggah(走兽)，buv-yerngx(飞禽)。同时，buv也可以弱化成 bu，所以上的词都可以说成 bu-njerngc, bu-mpal, bu-nggah 和bu-yerngx。然后问题就出现了，来源相同，但是拼音化后却成了不同的词，这就像汉语中的“子”“儿”一样，拼音化后成了z 和 r, 不同于 zi, er。</p><p>这是单一标准音内的问题，可以理解。接下来就是不同标准音了。在两弄地区，bu(v)不是发这个音，而是出现音变：u -&gt; o。所以他们会把自己叫做bov-noh，就是音变了。同时音变的还有 o -&gt; a。因此原本的 bu(v) 就变成了bo(v) 和ba(v)。这三个音都是一个源头，但是写起来都不一样。虽然西南官话把“介”读作gai, 但是写下的仍是“介”，这是汉字真正的书同文。</p><p>u -&gt; a(o) 是一个现象，还有 eu -&gt; u。例如deuh(说)，在两弄地区叫做duh。这种一个音一个字的现象应该被避免，但是实际上拉丁化就存在这样的问题。两弄地区也有区别，例如o 和 or，因为弄呈有长元音，所以 or 代表长元音。因此用弄呈的 shuu(书)与弄京的 shu是不同的字但是一个东西。因此拉丁文字的创造实际上没有解决文字的问题，最后还只是使用国际音标记音。相反看汉字，你可以随便怎么读它，它都那么写。汉字是实现文字统一最好的方式。</p><h2 id="多音-heu-njerc">多音 Heu-Njerc</h2><p>除了上面无缘无故产生的多字，还有一个问题是汉藏语系的痛点：多音。布努语所属的苗瑶语族是非常复杂的语族，世界上声调最多的语言就是苗瑶语族的分支。梅珠布努语有8 + 3 = 11 个声调。8 个基本声调，3 个变调。与汉语的轻声调不同，3个变调实际上是独立存在的。壮话有 8个声调，但是有两个声调很少使用，所以教学的时候基本不会独立强调，然而布努语中的11 个声调是实打实的声调。</p><p>举个例子，berv(碗) 和 berv(死) 书写上同属于第三调 v，但前者实际上是 3ٰ调，也就是第三变调。根据瑶文方案，它们都写作berv，这样在书写上是无法区分它们的。你需要先拼出 berv的音，然后根据句子猜出它的意思是 碗，最后得出 berv(碗)的音。原本多音字就多，现在还来个同调不同声，难度可想而知。</p><blockquote><p>布努语中的“死”，一般用 doc 不用 berv。berv 是戏谑用语，例如 :</p><p>1: Yang-nyiv ei, gaux yav-doc mungz. 慢点走好不好，累得要死。</p><p>2: Berv go laih? ndux-berv sheuc mungz-hai-nyiv.死了没？没死就走快点。</p><p>一般只在调侃中使用，真正的“死”还是使用 doc。</p></blockquote><p>不过虽然布努语的声调很多，但由于布努人历来没有文字，所以能保留下的音很少，很多时候是一个字一两个音而已，这倒是没有文字的优点—— 呵呵。</p><h2id="拉丁文辨识度不高-sher-la-ding-nggongx-mah-dec-ov">拉丁文辨识度不高Sher-La-Ding Nggongx Mah-Dec-Ov</h2><p>国人普遍接受汉文教育，因此很多人都会习惯用看汉文的技巧看文字，比如直接扫读。国人看文字只需要抓住几个关键字就知道意思了，然而拉丁文民族则需要整体认读才明白——这不是说使用拉丁文的民族不能扫读，只是说通习汉字的民族看拉丁文字的时候会以看汉字的习惯阅读，这种时候对文字的辨识度就不高。</p><p>我用布努文写过一些东西，但是事后即使是自己的文字，脑子里已经有了大体意思，看的时候还是很吃力。一个是确实不习惯文字的拼写，另一个是，我们习惯了汉字思维。</p><h2 id="用什么文字-yungc-sher-bi-siv">用什么文字？ Yungc Sher Bi-Siv?</h2><p>拉丁文字不行，那有没有其他选择，比如直接使用汉字训读？这是可以的，但不好。举个例子：</p><p>布努：Lerc-werngc fal-mongc, nuh ung ta nyi njerc dangndux-dec-rongc.</p><p>训文：蓦然 回面，人 那 却 在 处 灯 不太明。</p><p>汉文：蓦然回首，那人却在灯火阑珊处。</p><p>可以看到，如果使用训读，训文可读性要高很多，但问题是，这会和汉语冲突。举个例子，一个布努瑶看到“我”，他是应该读作wŏ 还是 jungv？如果使用汉字并训读，那他会认为那是 jungv,然后和汉人交流。汉人肯定听不懂 jungv是什么意思，但布努瑶不知道，因为他受到的教育告诉他，“我”读作jungv。这就只能进行笔谈了。而由于语序不同 —— 布努语一般修饰词在后 ——要进行笔谈也很困难。</p><p>举个例子，水沸(ang-mbax)在汉语中是“水沸了”，但是在布努语中是“沸水”。因此使用汉字训读会造成混乱。这也就是为什么广西在编写古壮文字典的时候会尽量使用与汉字不同的字作为正体，不是什么提高民族自信或者觉得羞耻，而是使用汉语常用字会造成混乱，所以尽量避免使用汉语常用字。在方块布努文中，“仲(jungv)”是“我”的意思，如果使用方块瑶文，那就会出现瑶文的“仲”和汉文的“仲”冲突的现象。因此，汉字可以用来训读，但是不好，容易产生混乱。</p><p>布努语很多结构与汉语相似，例如 jih-nggungh la-dic(训：下天大地)就是天下大地的意思，所以使用汉字不大合适，但可以使用汉字的近亲，如其他汉字变体。一个比较好的选择，我觉得是女书。女书在书写上来源于汉字，只是字形有所改变。如果可以用女书来书写布努文，那多音的事便可以迎刃而解。不管大家读的是什么，写起来都一样，且苗人本就有使用女书。</p><p>这里为什么提到苗族人？因为布努瑶和苗族其实更接近，勉瑶和布努瑶基本没有相似之处。布努语在分支上属于苗瑶语族的苗语支，而勉语属于瑶语支。</p><h2 id="今后的计划-uoc-nauv-waic-jih-uah">今后的计划 Uoc-Nauv WaicJih-Uah</h2><p>今天只是大概聊聊布努语的闲事，甚至没有标明出处。此后我的打算是，先把整理的布努语的声母和韵母列出，今后再慢慢写基本的教程。</p><h1 id="后语-shav-jiv-njerng">后语 Shav-Jiv-Njerng</h1><p>修正一门文字不是一件简单的事，但是我希望自己能够把这东西记录下来，也许等到以后还可以回头看看自己都干了些什么。后面附上李白的一首诗：</p><div class="line-block">Vos jungv mungz waic, mil-hnong da-nongz nduxhungv nzol;<br />弃 我 去 者 , 之日 时昨 不 可 留<br />Lunc jungv shienv waic, mil-hnong da-nauv heuv njerc ndaux.<br />乱 我 心 者 , 之日 时今 烦 多 甚<br />Jix-langl wanc-liv shongx nangc-shiau,<br />风大 万里 送 雁秋<br />dex nauv daux nyi lauz heul-njuv.<br />对 此 可 于 楼 畅酒<br />Shav-sher gauh hlaiv shongv Jienh-ngan,<br />章文 你 似 骨 建安<br />sheu jungv ta hlaiv shingv Yeh Yaul.<br />诗 我 又 似 清 谢朓<br />Nju-mongh bu-angx ngiz-langl jerngx,<br />俱怀 者兴 思壮 飞<br />yav njix nggungh-nzeuh nggweiz hlux-rongc.<br />欲 上 天青 揽 月明<br />Chos deu mbul ang ang hnyungv doh,<br />抽 刀 断 水 水 更 流<br />songx bei shiau heuv heuv hnyungv njerc.<br />举 杯 消 愁 愁 更 多<br />Nuh mongh nyi-sac shav ndux-ngaic,<br />人 生 在世 事 不易<br />da-guz shanx-dla nyungx ja-reuz.<br />时醒 散发 坐 扁舟</div>]]></content>
    
    
    <categories>
      
      <category>SherBuvNuh</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SherBuvNuh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过休眠在 Linux 和 windows 之间无缝切换</title>
    <link href="/2023/04/15/seamless-switch-betweem-Linux-and-windows-through-hibernation/"/>
    <url>/2023/04/15/seamless-switch-betweem-Linux-and-windows-through-hibernation/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>Linux 电脑挂了一个 Windows 虚拟机，但是有些东西还得是真机才管用，比如Windows大型独占软件，或者备份国内某空间占用贼大但只要你一找文件它就告诉你文件已过期的社交软件的聊天记录。备份可以在虚拟机中完成，但是只能是电脑连接手机热点，速度太慢了咱没那时间。</p><p>很多时候自己可能刚在 Linux 上工作或者刚在 Windows上玩游戏，但是突然接到任务要在 Windows 上运行某个东西或者要换到 Linux上办公，我不希望关掉 Linux 或者 Windows系统，因为任务并不复杂，很快就弄好了。此外，自己的电脑布局可能很多，开机回来再一个一个打开可能太慢了。</p><p>这时可以选择休眠，休眠会保存系统的运行状态，直到下次开机它才帮你恢复。这也就是本篇文章的主要内容：在Windows 和 Linux 系统设置休眠，保存系统状态。</p><h1 id="设置休眠">设置休眠</h1><p>电脑系统存在多种挂起的方案，其中比较重要的是：</p><ol type="1"><li>Suspend to RAM, suspend.挂起，一般就是电脑显示的挂起，它把状态保存到 RAM （random accessmemory），也就是内存当中。这个状态就是离开你电脑不久它自动进入的熄屏状态。</li><li>Suspend to disk, hibernate.休眠，一般休眠之后会关机，它把状态保存到硬盘，实际上是交换空间（swapspace），也就是交换分区（swappartition）。这个状态一般不会自动进行，而且由于把状态保存到交换分区，它可以实现电脑开机后恢复关机前状态。</li></ol><h2 id="linux-休眠">Linux 休眠</h2><p>在安装 Linux的时候会有一个分区过程，一般分根分区（root）、家分区（home）和交换分区（swap）三个分区，根分区占十分之三，交换分区是电脑内存的一倍到两倍，剩下的给家分区。这里说的电脑内存是RAM, 一般叫做运存 —— 手机上这么叫。比如我的电脑内存是8G，那交换分区一般可以给 8G 或者 16G。</p><p>很多人会说，现在什么年代了还用交换分区？交换分区确实刚开始是为了解决内存太小出现的，但是人家也可以用来做其他的事，比如现在要说的休眠。一般来说，交换分区应该是内存的两倍，这样当休眠时，交换分区刚好可以保存运行状态的所有的数据，而且还有盈余，所谓宁滥勿缺。</p><p>不过我倒霉了，我后来给自己的电脑加了一个内存条，内存变成了16G，而我的交换分区也只有8G。不过不用担心，一般来说问题不大，因为还是有机会的。我一直正常使用也没出现问题。</p><h3 id="配置根文件系统">配置根文件系统</h3><p>Linux启动涉及到比较复杂的过程，其中大部分需要使用到一个比较小的、完整的系统，叫做initramfs(initial RAMfilesystem)，根文件系统。如果我们需要在开机的时候恢复上次关机前电脑的状态，那就需要在这里给根文件系统任务。</p><p>首先打开 <code>/etc/mkinitcpio.conf</code>，找到 HOOKS 一行，添加<code>resume</code> 钩子：</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">$ vim /etc/mkinitcpio.conf<br>...<br><span class="hljs-comment">#HOOKS=(base udev autodetect modconf kms keyboard keymap block filesystems fsck) </span><br>HOOKS=(base udev autodetect modconf kms keyboard keymap block filesystems resume fsck)<br>...<br></code></pre></div></td></tr></table></figure><p>我上面把原来的钩子注释点，然后再添加一行，这样避免出错无法还原。<code>resume</code> 需要在 <code>udev</code>后面，因为这些钩子是按顺序调用的，交换分区需要 <code>udev</code>检查，如果在调用 <code>udev</code> 之前使用<code>resume</code>，那系统就找不到交换分区了，得先让 <code>udev</code>把交换分区找出来。</p><p>我把 <code>resume</code> 放在 <code>fsck</code>（文件检查）之前，<code>udev</code>之后，不知道有什么深意，俺忘了。不过不重要，只需要记住在<code>udev</code> 之后即可。</p><p>写好的之后需要重新生成 initramfs，即在命令行上调用<code>sudo mkinitcpio -P</code>。命令会诱发很多的输出，不过这不重要。</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">$ sudo mkinitcpio -P<br></code></pre></div></td></tr></table></figure><h3 id="设置内核参数">设置内核参数</h3><p><code>initramfs</code> 配置的是钩子，也就是 <code>resume</code>后需要处理的东西，我们需要在内核参数（kernelparameters）上告诉系统从哪里恢复上次的状态。</p><p>首先确认自己的交换分区是哪个分区，一个简单的办法是使用<code>sudo fdisk -l</code>：</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">$ sudo fdisk -l<br>...<br>Device         Start        End    Sectors   Size Type<br>/dev/sda1       2048  275800063  275798016 131.5G Microsoft basic data<br>/dev/sda2  292577280  502292479  209715200   100G Linux filesystem<br>/dev/sda3  502292480 1953525134 1451232655   692G Linux filesystem<br>/dev/sda4  275800064  292577279   16777216     8G Linux swap<br>...<br></code></pre></div></td></tr></table></figure><p>上面可以看到，有个 Type 写的是 Linux Swap, 这就是交换分区，是<code>/dev/sda4</code> 分区。</p><p>也可以使用 <code>cat /etc/fstab</code> 查看：</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">$ <span class="hljs-built_in">cat</span> /etc/fstab<br><span class="hljs-comment"># &lt;file system&gt; &lt;dir&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt;</span><br>...<br><span class="hljs-comment"># /dev/sda4 LABEL=ArchLinuxSwap</span><br>UUID=92b7f976-98c5-4eef-9fc7-ba037fd8552e       none            swap            defaults        0 0<br>...<br></code></pre></div></td></tr></table></figure><p>也可以看到注释上写的 <code>/dev/sda4</code> 就是交换分区。</p><p>用编辑器打开 <code>/etc/default/grub</code>，找到 GRUB_CMDLINE_LINUX一行，如果没有就自己添加一行，在这行的末尾引号内添加<code>resume=你的交换分区</code>。我的是 <code>/dev/sda4</code> 所以写<code>resume=/dev/sda4</code> ，也可以用 UUID 替代，也就是<code>resume=UUID=92b7f976-98c5-4eef-9fc7-ba037fd8552e</code>。</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">$ vim /etc/default/grub<br>...<br>GRUB_CMDLINE_LINUX_DEFAULT=<span class="hljs-string">&quot;loglevel=3 quiet&quot;</span><br>GRUB_CMDLINE_LINUX=<span class="hljs-string">&quot;nvidia_drm.modeset=1 resume=/dev/sda4&quot;</span><br>...<br></code></pre></div></td></tr></table></figure><p>如此保存退出即可。保存之后需要重新生成 <code>grub</code>文件，也就是在命令行输入:</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">$ sudo grub-mkconfig -o /boot/grub/grub.cfg<br></code></pre></div></td></tr></table></figure><p>同样也有一堆输出。</p><h3 id="尝试-linux-休眠">尝试 Linux 休眠</h3><p>弄好之后，Linux 休眠可以通过 <code>systemctl</code>来启动。在命令行上输入：</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">$ sudo systemctl hibernate<br></code></pre></div></td></tr></table></figure><p>然后电脑就会进行休眠，等到屏幕和键盘灯都灭了就可以开机进入 Windows进行休眠设置了。</p><h2 id="windows-系统休眠">Windows 系统休眠</h2><p>关机后启动 Windows系统，打开搜索，搜索电源选项，然后选择“选择电源按钮的功能”，将电源按钮的功能改为“休眠”。下面是Windows7 的演示：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023043/20230415155931.png"alt="搜索电源选项" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023043/20230415160008.png"alt="将电源按钮的功能改为“休眠”" /></p><p>Windows10 和 Windows11也是一样，只是可以设置的可能更多，例如接通电源如何、使用电池如何、睡眠按钮如何、关闭盖子如何，只要按自己的想法就可以了。</p><p>Windows配置好之后，不要关闭控制面板，留着直接按电源键进行休眠。休眠后重新启动进入Linux，看看是不是保留着原本的工作状态，如果是，可以再休眠进入 Windows看自己的控制面板还在不在。</p><p>对于 Windows，把电源键改成了休眠该怎么真的关机？可以直接使用快捷键<code>alt+f4</code>，然后选择关机或者重启即可。</p><h1 id="后语">后语</h1><p>一篇文章控制在 2000 字左右差不多了，后面的计划是写在 Linux 上使用Nvidia 显卡。 GNOME 桌面对 Nvidia 显卡的支持更好一点，而且我也没在 KDE上试过 —— 我更喜欢 GNOME 桌面，所以后面的设置主要针对的是 GNOME的显示管理器 GDM（GNOME Display Manager）。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hibernation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 中开启大内存页</title>
    <link href="/2023/04/15/enable-hugepages-in-Linux/"/>
    <url>/2023/04/15/enable-hugepages-in-Linux/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p><ahref="https://chunshuyumao.github.io/2023/04/14/using-windows7-as-guests-of-QEMU/">上篇文章</a>说到，使用QEMU/KVM可以开启大内存页（Hugepages），以获得更好的虚拟机性能。不过当时篇幅太长没有继续写下去，今天打算补一下。</p><p>本篇文章基本参照 <ahref="https://wiki.archlinux.org/title/KVM#Enabling_huge_pages"title="Arch KVM">Arch KVM Wiki</a>的步骤进行配置，说句不好听的，可能只是翻译成了中文，如果有能力可以直接看原文的请按提供的网址查看。</p><h1 id="启用大内存页">启用大内存页</h1><p>大内存页允许操作系统提供更大的内存申请，一般大内存页大小在 2M以上，默认的内存页是 4K。<ahref="https://docs.oracle.com/database/121/UNXAR/appi_vlm.htm#UNXAR391"title="Hugepages in Kernel">大内存页在 Linux2.6之后就默认编入内核，只要内核不太老，一般没啥需要担心的</a>。</p><h2 id="什么时候用大内存页">什么时候用大内存页</h2><p>进程向操作系统申请内存不是用多少申请多少而是有一个申请原子值，也就是最小的申请值。比如有一个0.9K 大小的文件，不是说它在内存中就占用0.9K，而是系统直接给它分配默认值大小的空间，一般是4K。因此很多时候，0.9K 和 3K占用的空间是一样的。现在的操作系统在使用上肯定有所优化，但是基本道理如此。</p><p>进程对内存操作的时候也会返回一部分内存给操作系统。假设有一个进程占了4K，下一个进程就要从 4K 开始使用内存，第一个进程又申请了4K。此时如果第二个进程将内存返还给了操作系统，系统的内存不会自动对齐，而是保留原来的状态，即第一个4K 和第三个 4K 被第一个进程使用，第二个 4K则为空闲。这就是内存不连续。</p><p>第一个进程怎么知道自己使用的内存在哪里？这就涉及到寻址，为了找到自己使用的空间，第一个进程需要慢慢找到。怎么找？按照一个字节一个字节找也可以，但是太慢了。这时人为规定，内存页以4K 对齐，按照 4K找！然后进程只需要走两步就找到了自己使用的第二块内存，这比一个一个字节快很多。这里的4K 是人为规定的，是经验值。</p><p>如果进程需要进行大规模的内存申请和释放，例如现在的人工智能学习和虚拟机运行，就会造成大量的内存不连续。内存不连续寻址会变慢，而且由于内存频繁申请和释放，操作系统也会更加繁忙。</p><p>为了应对这种内存频繁申请和释放的情况，一个比较好的方法是，一开始就划分一个大内存，叫做内存池，比如16K,直接分配给进程，这样进程的内存就连续了，也不会花太多时间进行寻址。那上面的例子来说，第一个进程第一次只需要4K, 我们给了 16K。第二个进程需要 4K, 我们也给另外的16K。等到第一个进程需要另外的 4K时就不需要分配内存了，因为我们给它的够多了，它可以继续在自己的 16K里使用另外所需的4K。这样第二个进程申请和释放内存和第一个关系不大，没啥影响也就避免了内存断裂和频繁将计算机算力用在寻址上。</p><p>这样虽好，但是我们也看到，第一个进程只用到 8K，第二个4K，合起来也就是 12K，但是我们总共分配出去32K，很多内存根本用不到！因此大内存页一般只用于对内存操作频繁的地方，这正是虚拟机的用武之地。</p><h2 id="检查大内存页是否已经启用">检查大内存页是否已经启用</h2><p>在启用之前，我们需要确认自己的电脑是否已经启用了大内存页。一般是没有的，但过程还是要走。打开控制台输入<code>file /dev/hugepages</code>。如果出现</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">$ file /dev/hugepages<br>/dev/hugepages: sticky, directory<br></code></pre></div></td></tr></table></figure><p>则表明你的 Linux 系统已经启用了大内存页，后面不必折腾了，直接跳到<ahref="#分配内存大小">分配内存页个数</a></p><p>如果出现</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">$ file /dev/hugepages<br>/dev/hugepages: cannot open `/dev/hugepages<span class="hljs-string">&#x27; (No such file or directory)</span><br></code></pre></div></td></tr></table></figure><p>那就说明没有启用，我们需要创建这个目录，输入</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">$ sudo <span class="hljs-built_in">mkdir</span> -v /dev/hugepages<br><span class="hljs-built_in">mkdir</span>: created directory <span class="hljs-string">&#x27;/dev/hugepages&#x27;</span><br>$ <span class="hljs-built_in">ls</span> -l /dev<br>drwxr-xr-x   2 root         root           40 Apr 15 09:08 hugepages<br></code></pre></div></td></tr></table></figure><p>创建好目录看到目录权限是第一排的 0755，属于 root 用户和 root用户组，我们需要修改权限。</p><p>用自己喜欢的编辑器打开 <code>/etc/fstab</code> ，添加：</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">$ vim /etc/fstab<br>hugetblfs  /dev/hugepages  hugetblfs  mode=01770,gid=kvm  0  0<br></code></pre></div></td></tr></table></figure><p>这是让系统开机之后自动帮你挂载这个目录并修改权限，目录属于 kvm组，<code>gid</code> 表示目录所属的组 ID。</p><p>查看电脑是否有 kvm 组，输入 <code>grep kvm /etc/group</code>:</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">$ grep kvm /etc/group<br>kvm:x:992:qemu,chunshuyumao<br></code></pre></div></td></tr></table></figure><p>出现这样的信息说明有 kvm组，如果没有出现，那就是没有，我们需要新建一个 kvm组，然后把自己的账号加入其中。</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">$ sudo groupadd kvm<br>$ sudo usermod -aG kvm chunshuyumao<br>$ <span class="hljs-built_in">groups</span> chunshuyumao<br>wheel kvm chunshuyumao<br></code></pre></div></td></tr></table></figure><p>第一行是添加新的组，第二行是把用户（chunshuyumao）添加（a）到 kvm组（G），第三行是查看用户（chunshuyumao）所在的组（groups）。我的用户属于三个组，分别是wheel、kvm 和同名组 chunshuyumao。</p><h2 id="挂载大内存页">挂载大内存页</h2><p>上面设置好后，在命令行上输入：</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">$ sudo umount /dev/hugepages<br>$ sudo mount /dev/hugepages<br>$ mount | grep hugepages<br>hugetlbfs on /dev/hugepages <span class="hljs-built_in">type</span> hugetlbfs (rw,relatime,gid=992,mode=1770,pagesize=2M)<br></code></pre></div></td></tr></table></figure><p>看到上面的结果就说明没啥问题了。可能输出和我的不大一样，但有输出就说明没问题。</p><p>接下来可以看看大内存页的信息，输入</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">$ grep -i hugepages /proc/meminfo<br>AnonHugePages:    731136 kB<br>ShmemHugePages:        0 kB<br>FileHugePages:    256000 kB<br>HugePages_Total:    2050<br>HugePages_Free:     2050<br>HugePages_Rsvd:        0<br>HugePages_Surp:        0<br>Hugepagesize:       2048 kB<br></code></pre></div></td></tr></table></figure><p>可以看到，内存页大小（Hugepagesize）是 2M，总共有 2050个内存页，也就是 2 x 2050 / 1024 ⋍ 4G，大内存页总共有 4G。这是当初运行Windows10 虚拟机的内存大小的两倍。因为电脑已经设置了大内存页个数，所以<code>HugePages_Total</code> 是 2050个大内存。如果之前电脑没有开启过大内存页，这里应该是 0。</p><p>一般来说，给自己的虚拟机几个 G 内存，内存页就应该是其两倍。我给了 4G是以前虚拟机所需内存的两倍。现在使用 Windows7 可以把内存页缩小到2G，但是保留着也没啥。</p><p>分配内存的时候也不要太死板，不是 2G 就铁定了 1024,可以稍微扩大一点，例如 1030 取个整，因此我的 4G 原本应该是2048，但我取了整，选择 2050。</p><h2 id="分配内存页个数">分配内存页个数</h2><p>上面我们挂载了内存页，现在需要给内存页分配大小了。比如我分配 4G，就是2050 个 2M。在控制台上输入：</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">$ <span class="hljs-built_in">echo</span> 2050 | sudo <span class="hljs-built_in">tee</span> /proc/sys/vm/nr_hugepages<br></code></pre></div></td></tr></table></figure><p>Linux 上无法使用 <code>sudo echo</code>，所以我们用 <code>tee</code>作为中介，这是一个技巧。完成后可以输入</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">$ grep hugepages /proc/meminfo<br>AnonHugePages:    731136 kB<br>ShmemHugePages:        0 kB<br>FileHugePages:    256000 kB<br>HugePages_Total:    2050<br>HugePages_Free:     2050<br>HugePages_Rsvd:        0<br>HugePages_Surp:        0<br>Hugepagesize:       2048 kB<br></code></pre></div></td></tr></table></figure><p>查看。原本应该是 0 的 <code>HugePages_Total</code> 此时应该是 2050了。</p><h2 id="在-qemu-中使用大内存页">在 QEMU 中使用大内存页</h2><p>打开自己的虚拟机启动脚本 setup.sh，在选项处添加:</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">$ vim setup.sh<br>...<br>...<br><br>options=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;options&#125;</span> -mem-path /dev/hugepages&quot;</span><br>&#123;<br>  /bin/taskset -c 9-11 /bin/qemu-system-x86_64 <span class="hljs-variable">$&#123;options&#125;</span><br>&#125;&amp;<br><span class="hljs-built_in">unset</span> options<br></code></pre></div></td></tr></table></figure><p>打开虚拟机，查看是不是刚好用了那么多内存。</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">$ grep -i hugepages /proc/meminfo<br>AnonHugePages:    757760 kB<br>ShmemHugePages:        0 kB<br>FileHugePages:    256000 kB<br>HugePages_Total:    2050<br>HugePages_Free:     1542<br>HugePages_Rsvd:        4<br>HugePages_Surp:        0<br>Hugepagesize:       2048 kB<br></code></pre></div></td></tr></table></figure><p>可以看到，我的虚拟机开机后使用的 2M 大内存页 2050 - 1542 = 508个，差不多是 1G 内存。</p><h2 id="大内存页持久化">大内存页持久化</h2><p>直接修改 <code>/proc/sys/vm/nr_hugepages</code>只会影响现在的电脑状态，重新开机后内存页又变成0。为了让内存页持久化，我们需要让系统开机的时候自己设置内存页个数，也就是所谓的持久化。</p><p>用编辑器打开 <code>/etc/sysctl.d/40-hugepage.conf</code>，如果没有40-hugepage.conf 就创建一个:</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">$ vim /etc/sysctl.d/40-hugepage.conf<br>vm.nr_hugepages = 2050<br></code></pre></div></td></tr></table></figure><h1 id="后语">后语</h1><p>我发现自己发的博客，科普占了很大的内容，好像真正操作蛮简单的样子。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hugepages</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在 QEMU 中安装 Windows7 虚拟机</title>
    <link href="/2023/04/14/using-windows7-as-guests-of-QEMU/"/>
    <url>/2023/04/14/using-windows7-as-guests-of-QEMU/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><a href="/2023/04/13/after-a-year-of-using-linux-as-the-main-computer/" title="使用 Linux 作为主力机一年后">使用 Linux 作为主力机一年后</a><p>提到可以使用<a href="https://www.qemu.org">QEMU</a> 虚拟一个 Windows系统，在里边使用国产毒瘤，干净又卫生，今天它来了。</p><p>本次教程主要虚拟的是 Windows7，因为 WindowsXP太老了，自己不知道怎么安装；Windows10 太高级了，装了卡得不要不要的；至于Windows8 这种系统单纯就是觉得太垃圾了，没必要安装。</p><p>开始之前，我们需要一些东东：</p><ol type="1"><li>QEMU, Quick EMUlator. 按照组词习惯，我一般读作 /kju: 'emju/. QEMU是一个开源的虚拟机和模拟器。据<a href="https://wiki.qemu.org/Main_Page"title="QEMU Wiki">官网</a>所说，它可以模拟不同架构的机器和拥有可以媲美原生系统性能的虚拟能力。</li><li><a href="https://www.linux-kvm.page/Main_Page" title="KVM">KVM</a>,Kernel-based Virtual Machine. 基于 Linux 内核的虚拟机。KVM 内建于 Linux,一般作为模块（Modules）编译，是高效利用宿主机资源的开源虚拟化技术，使用QEMU 一般会开启 KVM 提供更好的性能。</li><li>Windows7 系统镜像。虚拟一个 Windows 系统自然需要一个镜像。现在的Windows7 似乎已经无法在微软官网上找到了，所以推荐到 <ahref="https://msdn.itelyou.cn" title="MSDN I tell you">MSDN I tellyou</a> 下载原版镜像。这个 MSDN 与微软的 MSDN不同，它只是一个提供了微软系统原版镜像和各种工具下载的网站。</li><li><a href="https://wiki.libvirt.org/Virtio.html"title="VirtIO">VirtIO</a>,一个提供虚拟机优秀读写性能的虚拟化标准，包括磁盘读写和网络传输等。要是没记错应该是红帽公司（RedHat）设计以提高虚拟机性能的，但是忘了出处。</li><li>一台 Linux 电脑。我使用的是 Arch Linux, 本身已经将 KVM编好成模块。</li></ol><p>以上便是需要准备的东西了。</p><h1 id="安装-windows7-虚拟机">安装 Windows7 虚拟机</h1><h2 id="下载-windows7-镜像">下载 Windows7 镜像</h2><p>到 MSDN 选择系统镜像，找到 Windows7镜像，选择合适的版本和语言，点开详细信息复制下载链接，用迅雷下载，迅雷刚开始可能没有速度，但是可能有些时候会碰上狗屎运，变得很快。请不要下载百毒上的Windows7 镜像，因为那些一般都是 Ghost 镜像，需要使用 WinPE安装。Windows7不需要专业版或者旗舰版，毕竟只是为了安装一些毒瘤而已，能用就行，不必挑剔。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414150441.png"alt="MSDN 上的 Windows7 镜像。这些都是原版镜像，与官网一样，甚至安装完你还需要激活。可以选择中文版本" /></p><h2 id="下载-qemu-和-virtio">下载 QEMU 和 VirtIO</h2><h3 id="qemu">QEMU</h3><p>使用自己的 Linux 系统的安装 QEMU. Arch Linux 上的 QEMU 在 7.0后对包进行了<ahref="https://archlinux.org/news/qemu-700-changes-split-package-setup/"title="QEMU change">分割</a>，分为 qemu-base、qemu-desktop 和 qemu-full.为了尽量少的安装软件，我选择了安装 qemu-base, 基本满足使用即可。此外qemu-base 只有一个 qemu-ui-spice 对系统进行图形操作，所以我还安装了qemu-ui-gtk包使用图形界面。这些信息可以通过查找自己系统的软件包查看信息。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414152322.png"alt="Arch Linux 上对 QEMU 分包的消息" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414152045.png"alt="使用 pacman -Si 查看 qemu-base 包含的包，只有一个支持 spice 协议的图形界面" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414152224.png"alt="qemu-ui-gtk 的详细信息" /></p><p>Arch Linux 的安装命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo pacman -Syu --noconfirm qemu-base qemu-ui-gtk<br></code></pre></div></td></tr></table></figure><p>如果不想使用系统仓库编译的 QEMU 也可以去 QEMU官网直接下载源码编译。QEMU很小的，编译也很快，可以根据官网的教程进行编译。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414152738.png"alt="QEMU 官网介绍" /></p><p>待下载完成再下载 VirtIO.</p><h3 id="virtio">VirtIO</h3><p>VirtIO 一般 Linux 系统会编译成模块启用即可，但是 Windows 没有将VirtIO 编入内核，需要下载额外的镜像安装驱动才行。这里说的下载 VirtIO其实是下载 Windows 系统需要的 VirtIO 驱动。直接到 <ahref="https://github.com/virtio-win/virtio-win-pkg-scripts/blob/master/README.md"title="VirtIO 驱动">GitHub 仓库</a> 下载驱动即可。</p><h2 id="安装虚拟机">安装虚拟机</h2><h3 id="准备工作目录">准备工作目录</h3><p>下载完所有东西后打开 Linux命令行，新建一个工作目录，把需要的东西放好：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">mkdir</span> ~/Downloads/QEMU &amp;&amp; <span class="hljs-built_in">cd</span> ~/Downloads/QEMU<br>$ <span class="hljs-built_in">mkdir</span> -v ISOS VirtIO Win7<br><span class="hljs-built_in">mkdir</span>: created directory <span class="hljs-string">&#x27;ISOS&#x27;</span><br><span class="hljs-built_in">mkdir</span>: created directory <span class="hljs-string">&#x27;VirtIO&#x27;</span><br><span class="hljs-built_in">mkdir</span>: created directory <span class="hljs-string">&#x27;Win7&#x27;</span><br>$ tree<br>.<br>├── ISOS<br>├── VirtIO<br>└── Win7<br><br>4 directories, 0 files<br>❯ tree<br>.<br>├── ISOS<br>│   └── w7-64bit.iso<br>├── VirtIO<br>│   └── virtio-win-0.1.225.iso<br>└── Win7<br><br>4 directories, 2 files<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414154956.png"alt="查看工作目录，QEMU 目录下创建 ISOS、VirtIO和 Win7 目录" /></p><p>上面是我已经建好的目录，接下来的启动文件主要放到 Win7 文件夹中。</p><h3 id="创建-windows-磁盘">创建 Windows 磁盘</h3><p>开始之前我们需要准备一个 Windows 磁盘用于安装系统。在命令行上输入</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> Win7<br>$ <span class="hljs-built_in">pwd</span><br>/home/chunshuyumao/Downloads/QEMU/Win7<br>$ qemu-img create -f qcow2 windows7.qcow2 40G<br>Formatting <span class="hljs-string">&#x27;windows7.qcow2&#x27;</span>, <span class="hljs-built_in">fmt</span>=qcow2 cluster_size=65536 extended_l2=off compression_type=zlib size=42949672960 lazy_refcounts=off refcount_bits=16<br>$ <span class="hljs-built_in">ls</span><br>windows7.qcow2<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414155509.png"alt="进入 Win7 目录并创建一个 40G 大小的磁盘，命名为 windows7.qcow2" /></p><p>后面的工作目录都在 Win7 中。使用 <code>qemu-img</code>创建一个磁盘，大小是 40G. 这个大小随意，30G 也是可以的，使用 qcow2格式是可以调整大小，也就是后边如果觉得 40G太大了太小了都可以调整。这里给予 40G是为了后边分出一个数据盘，因为有些操作不允许在 C盘（系统盘）上进行，所以开个新的盘作为系统盘即可。</p><blockquote><p>qcow2 是 QEMU上常用的磁盘格式，支持同时读写（copy-on-write）。不用担心给的空间太大，qcow2是根据你的使用量使用空间的。举个例子，给了 40G qcow2格式的空间，其实这个磁盘没有占用那么多空间，如果你只用到1G，那这个磁盘就只有 1G 大小，给的 40G表示的是虚拟机能用的最大空间，不是你直接划分这么多给虚拟机。</p></blockquote><h3 id="编写启动脚本">编写启动脚本</h3><p>在 Wind7 目录下编写一个新的启动脚本：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">pwd</span><br>/home/chunshuyumao/Downloads/QEMU/Win7<br>$ <span class="hljs-built_in">touch</span> setup.sh<br>$ <span class="hljs-built_in">ls</span><br>setup.sh  windows7.qcow2<br>$ vim setup.sh<br><span class="hljs-comment">#!/bin/env bash</span><br><span class="hljs-comment"># encoding: utf-8</span><br><span class="hljs-comment"># ========================================================</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># File: setup.sh</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Author: chunshuyumao</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Description: </span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># ========================================================</span><br><br><span class="hljs-built_in">declare</span> options=<span class="hljs-string">&#x27;&#x27;</span><br><br>options=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;options&#125;</span> -name &#x27;windows7&#x27;&quot;</span><br>options=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;options&#125;</span> -m 1G&quot;</span><br>options=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;options&#125;</span> -enable-kvm&quot;</span><br>options=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;options&#125;</span> -cpu host,hv_relaxed,hv_spinlocks=0x1fff,hv_vapic,hv_time&quot;</span><br><br>options=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;options&#125;</span> -boot order=dc&quot;</span><br>options=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;options&#125;</span> -vga virtio&quot;</span><br>options=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;options&#125;</span> -display gtk,grab-on-hover=on,show-menubar=off,zoom-to-fit=off&quot;</span><br>options=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;options&#125;</span> -rtc clock=host,base=localtime&quot;</span><br>options=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;options&#125;</span> -smp 1,sockets=1,cores=1,threads=1,maxcpus=1&quot;</span><br>options=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;options&#125;</span> -drive file=/home/chunshuyumao/Downloads/QEMU/ISOS/w7-64bit.iso,index=1,media=cdrom&quot;</span><br>options=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;options&#125;</span> -drive file=/home/chunshuyumao/Downloads/QEMU/VirtIO/virtio-win-0.1.225.iso,index=2,media=cdrom&quot;</span><br>options=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;options&#125;</span> -drive file=/home/chunshuyumao/Downloads/QEMU/Win7/windowns.qcow2,index=3,media=disk,if=virtio,aio=native,cache.direct=on&quot;</span><br>options=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;options&#125;</span> -machine usb=on&quot;</span><br>options=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;options&#125;</span> -device usb-tablet&quot;</span><br>options=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;options&#125;</span> -device virtio-net,netdev=vmnic&quot;</span><br>options=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;options&#125;</span> -netdev user,id=vmnic,smb=/home/chunshuyumao/Downloads&quot;</span><br><br>/bin/taskset -c 9-11 /bin/qemu-system-x86_64 <span class="hljs-variable">$&#123;options&#125;</span><br><span class="hljs-built_in">unset</span> options<br><br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414163402.png"alt="编写脚本" /></p><p>setup.sh 脚本是后面编写的主要部分。下面一行一行解析：</p><ol type="1"><li>首先，声明了一个变量叫做 options, 后面主要用于编写 QEMU的选项。</li><li>给系统取名字叫做 windows7. 这里取名最好不要有空格。</li><li><code>-m 1G</code> 是给予电脑的内存大小，1G 足矣。</li><li><code>-enable-kvm</code> 用于启用 KVM.</li><li><code>-cpu</code> 那一行，<code>host</code> 表示虚拟机使用的 CPU和主机一样，后面一连串 <code>hv</code> 开头的选项是参考 <ahref="https://wiki.archlinux.org/title/QEMU#Improve_virtual_machine_performance"title="hv_ options">Arch Wiki</a>，据说可以提高 Windows系统的性能。</li><li><code>-boot</code> 一行选择了启动顺序，即先从 CD启动再试试硬盘。</li><li><code>-vga</code> 选择的是 virtio，这是显卡，因为使用 VirtIO,我们就选它。</li><li><code>-display</code> 那一行选择我们安装的 UI，也就是 GTK.后面的选项是这个 UI提供的选项。第一个表示启动后之后直接让虚拟机锁定鼠标，这样鼠标就被限制在虚拟机内部了。第二个选项是不显示窗口的菜单栏，因为菜单栏占用的空间太多了。第三个选项则是关闭界面自适应，不然窗口会自动伸缩。我们可以在虚拟机里调整虚拟机的分辨率，不需要它自己改变。</li><li><code>-rtc</code> 这是 Real-TimeClock，实时时钟的缩写，用来修正虚拟机的时间。选择和宿主一样即可。</li><li><code>-smp</code> 设置虚拟机的 CPU 个数。选择一个 CPU即可。后面的参数刻有可无。</li><li><code>-drive</code> 用于配置镜像，一个是 Windows7 镜像，一个是VirtIO 驱动，一个是 Windows7 的硬盘/磁盘。前两个后面可以注释掉。</li><li><code>-machine</code> 用于开启 USB,也就是可以直接使用宿主鼠标。</li><li><code>-device usb-tablet</code> 用于确定鼠标位置。</li><li><code>-device virtio-net,netdev=vmnic</code> 给电脑配置一个 VirtIO网卡。</li><li><code>-netdev</code> 用于配置 <a href="https://www.samba.org"title="Samba">Samba</a> 位置。也就是虚拟机可以通过 Samba访问主机的内容，<code>smb</code>后的地址可以改成自己的地址，例如让虚拟机访问用户主目录<code>smb=/home/chunshuyumao</code>. 相当于共享目录。记住，宿主机要安装Samba，例如 Arch Linux 使用 <code>sudo pacman -Syu samba</code>进行安装。</li><li><code>/bin/qemu-system-x86_64</code> 用于启动虚拟机。前面的<code>/bin/taskset</code> 是限制虚拟机使用的 CPU 是哪几个。如果 Linux系统很繁忙，负载过高会随即杀掉几个程序，而且 Linux系统的任务一般都是随机跳跃的，很可能会导致 12 个 CPU里只有一个是繁忙的其余都是空闲的（夸张了）。所以我们把自己的虚拟机限定在这些CPU上工作，避免意外被系统杀掉。使用绝对路径是为了避免一些不必要的麻烦，其实也可以直接使用<code>qemu-system-x86_64</code> 和 <code>taskset</code>。</li><li>最后用 <code>unset</code> 删掉我们创建的变量。</li></ol><p>上面是我虚拟机使用的命令，比较多。QEMU 支持的命令很多，可以通过<code>man qemu</code>查看相关的命令和说明，或者直接到官网上查看说明书也行。</p><h3 id="启动安装-windows-系统">启动安装 Windows 系统</h3><p>首先赋予脚本可执行权限，然后启动脚本，按照提示进行安装。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">chmod</span> +x setup.sh<br>$ <span class="hljs-built_in">ls</span><br>setup.sh  windows7.qcow2<br>$./setup.sh<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414165158.gif"alt="赋予脚本可执行权限，并启动" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414165652.png"alt="选择键盘和语言安装 Windows7" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414165751.png"alt="选择立即安装，此时是载入界面" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414165851.png"alt="同意用户协议什么的" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414165939.png"alt="选择自定义安装" /></p><p>选择自定义安装后进入安装界面，但是记住，我们说过 Windows 没有 VirtIO的驱动，所以此时它并没有正确识别我们的硬盘，我们需要安装驱动。此时它的界面如下：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414170112.png"alt="Windows 系统无法正确识别硬盘" /></p><p>选择加载驱动器，浏览 virio-win 镜像，然后在 amd64 里找到 w7选择即可。添加之后点击下一步进行安装。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414170254.gif"alt="给 Windows7 安装 VirtIO 驱动" /></p><p>等驱动安装完成，VirtIO 硬盘就会被 Windows正确识别。直接进行下一步安装:</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414170817.png"alt="VirtIO 硬盘被成功识别" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414170911.png"alt="安装系统，安装过程需要点时间" /></p><p>安装过程比较久，可以先到浏览器下载需要在 Windows7 里安装的软件，例如QQ 和微信的安装包。下载的时候要选择 Windows 安装包，因为待会要安装到Windows 虚拟机里。下载好之后可以把安装包移动到 Samba 共享目录下。我的Samba 目录是 <code>/home/chunshuyumao/Downloads</code>,这样浏览器下载的东西可以直接从虚拟机中看到，虚拟机也可以直接把需要交流的文件放到该目录下分享给宿主机。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414173220.png"alt="重新启动" /></p><p>安装完成后的重新启动，请不要再在启动界面按任何按键，否则会进行重新安装！如果不知道这是什么意思，那就在出现上面重新启动界面后什么也不要动，直到出现下面的界面：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414173349.png"alt="自动重启后的界面" /></p><p>重启后仍会进行安装，因为安装没有彻底完成，还需要一些步骤。不过也不需要碰什么了，只需要看就行了，喝杯茶什么的。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414173546.png"alt="完成安装" /></p><p>安装完成后设置用户名和密码，密码可以不用设置直接下一步，也可以设置密码。我觉得不设密码没啥问题。密钥直接跳过。对于更新设置，随便，我觉得选以后再询问也可。后面可以按照提示一步一步完成设置。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414191438.png"alt="设置用户名" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414191537.png"alt="设置虚拟机密码，无所谓，可以直接下一步" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414191617.png"alt="添加密钥，直接选择下一步，后面再激活" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414191701.png"alt="更新设置，选择以后再询问" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414191724.png"alt="按提示继续选择即可" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414192156.png"alt="完成安装并成功启动！" /></p><h3 id="安装-virtio-网络驱动">安装 VirtIO 网络驱动</h3><p>因为网络设备我们选择了 VirtIO, Windows系统一样无法正确识别，所以我们需要安装 VirtIO 的网络驱动。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414192439.png"alt="Windows 系统无法识别 VirtIO 网络设备，需要安装驱动" /></p><p>按 Windows 键搜索 设备管理器 ，选择 其他设备 -&gt; 以太网控制器进行更新。更新程序时选择挂载的 VirtIO CD作为查找目录，查找之后会提示是否安装，选择安装即可。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414192705.png"alt="打开设备管理器，选择以太网设备准备安装" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414192742.png"alt="右键选择更新驱动程序" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414192827.png"alt="选择浏览计算机以查找驱动程序软件" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414192933.png"alt="浏览挂载的 VirtIO CD, 选择它进行驱动查找" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414193028.png"alt="正在查找驱动" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414193052.png"alt="选择安装驱动" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414193331.png"alt="安装驱动完成，可以上网了" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414193401.png"alt="选择网络模式，就按自己的选即可，我选择家庭模式" /></p><p>安装完之后就自动连上了网络，可以上网了。不过 Windows7 的 IE浏览器很古老，没必要使用，可以通过宿主机下载完东西后直接在虚拟机使用。</p><h3 id="挂载-samba-目录">挂载 Samba 目录</h3><p>记得我们启动虚拟机的时候给它分享了一个目录，我们需要挂载起来。打开文件管理器，在计算机 右键选择 添加一个网络位置 ，选在自定义位置后在地址栏输入<code>\\10.0.2.4\qemu</code>，并给这个位置取个名字。这个地址是添加 Samba服务的默认地址，具体可以查看 QEMU 的帮助。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414193825.png"alt="在“计算机”上右键添加网络位置" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414193916.png"alt="选自自定义位置" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414193950.png"alt="在地址栏输入 \\10.0.2.4\qemu, 这是 Samba 的默认地址" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414194028.png"alt="随意给分享目录一个名字，这里我不修改，直接保留默认名字" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414194439.png"alt="挂载 Samba 目录完毕" /></p><p>挂载完毕，可以直接看到共享目录的文件。</p><h3 id="激活-windows7-系统">激活 Windows7 系统</h3><p>准备完毕后可以选择激活系统。我的分享目录下有一个<code>win7active.zip</code>文件，里边有激活环境需要的东西。可以直接在共享目录下双击打开，但是有些文件不幸，可以通过复制到虚拟机的其他位置再解压或者安装。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414195121.png"alt="直接在共享目录打开压缩包" /></p><p>解压后随便运行其中的 licence1 或者 licence2, 这里我选择了 1,激活后会直接重启。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414195226.png"alt="选择确定激活" /></p><p>重启后打开控制面板可以看到系统已经激活了：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414195606.png"alt="控制面板查看系统是否成功激活" /></p><p>完成激活后可以进行个性化设置，比如觉得默认分辨率太小可以选择更高的分辨率。</p><h3 id="分区">分区</h3><p>前面我们说了，有些操作 Windows是不让在系统盘进行的，所以我们可以给电脑来个分区，分出一个盘主要用于数据的保存。</p><p>首先打开搜索，查找 分区，打开 磁盘管理。可以看到系统盘 C 盘有40G。我们可以</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414195947.png"alt="打开磁盘管理进行分区" /></p><p>在 C 盘右键选择压缩卷，然后输入需要压缩的大小，就是想要给 C盘保留多少。我觉得 20G 给 C 盘差不多了。这里直接默认选了，刚刚好：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414200040.png"alt="选择压缩卷" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414200448.png"alt="数据盘和系统盘对半分" /></p><p>看到有个属于未分配，我们需要把它变成数据盘。在未分配的盘右键选择新建简单卷，选择之后直接一路默认确定即可。可以修改卷标，我改为Data, 默认是 “新建卷”。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414200616.png"alt="新建简单卷" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414200834.png"alt="修改卷标" /></p><p>创建完毕可以在文件管理器查看新建的数据盘。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414200943.png"alt="文件管理器查看数据盘" /></p><p>完成所有的操作之后关键，一定要从菜单关机，而不是直接把虚拟机的窗口关掉。因为如果直接关闭虚拟机窗口，相当于你的电脑直接拔掉电源，有些数据可能会损坏，所以下次启动的时候电脑会启动修复，浪费时间。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414201054.png"alt="关机" /></p><h1 id="后续设置">后续设置</h1><h2 id="备份虚拟机以防万一">备份虚拟机以防万一</h2><p>虚拟机安装完了，我们可以给它弄个备份，比如下次我们搞老鼠搞鸟把系统弄坏了，重新安装又太慢，我们可以直接恢复原始状态，简而言之就是给它来个快照snapshot。</p><p>打开控制台，进入 windows7.qcow2 所在的位置，输入</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">ls</span><br>setup.sh  win7.desktop  win7.png  windows7.qcow2<br>$ qemu-img snapshot -c DoneInstall windows7.qcow2<br>$ qemu-img snapshot -l windows7.qcow2<br>Snapshot list:<br>ID        TAG               VM SIZE                DATE     VM CLOCK     ICOUNT<br>1         DoneInstall           0 B 2023-04-14 20:16:19 00:00:00.000          0<br></code></pre></div></td></tr></table></figure><p><code>-c</code> 是创建（create）快照，快照叫做DoneInstall。<code>-l</code>是列出（list）快照。我们只给电脑来了一个快照，所以这里只有一个快照。下次要恢复就使用</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ qemu-img snapshot -a ID windows7.qcow2<br></code></pre></div></td></tr></table></figure><p>其中 ID 是上面的数字，例如 1 。更多操作可以通过<code>man qemu-img</code> 查看。</p><h2 id="完善脚本">完善脚本</h2><p>我们的脚本是从终端启动的，也就是必须开着一个终端。这样太麻烦了，我们把脚本倒数第二行改成</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">&#123;<br>  /bin/taskset /bin/qemu-system-x86_64 <span class="hljs-variable">$&#123;options&#125;</span><br>&#125;&amp;<br></code></pre></div></td></tr></table></figure><p>这样就把虚拟机放到了终端之外运行了。下次要启动虚拟机只需要打开虚拟机目录，然后输入<code>./setup.sh</code> 就可以关闭命令行了。</p><p>同时注释掉以下行：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#options=&quot;$&#123;options&#125; -boot order=dc&quot;</span><br><span class="hljs-comment">#options=&quot;$&#123;options&#125; -drive file=/home/chunshuyumao/Downloads/QEMU/ISOS/w7-64bit.iso,index=1,media=cdrom&quot;</span><br><span class="hljs-comment">#options=&quot;$&#123;options&#125; -drive file=/home/chunshuyumao/Downloads/QEMU/VirtIO/virtio-win-0.1.225.iso,index=2,media=cdrom&quot;</span><br></code></pre></div></td></tr></table></figure><p>因为已经安装完成了，这些东西可以不要了，删掉或者直接像上面一样注释掉都可以。</p><h2 id="设置桌面图标">设置桌面图标</h2><p>安装完成并配置好后，我们可以给虚拟机一个图标，这样直接从启动菜单启动虚拟机，而不是命令行，比如下面的效果：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414172242.png"alt="Windows7 虚拟机的启动菜单图标" /></p><p>首先下载一个 Windows7 的图片，用于做标识。我选择了 PNG格式的图片，这个网上随便搜搜即可:</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414172415.png"alt="Windows7 图片，用于做图标" /></p><p>编写图标文件：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">ls</span><br>setup.sh  win7.desktop  win7.png  windows7.qcow2<br>$ vim win7.desktop<br>$ <span class="hljs-built_in">cat</span> win7.desktop<br>[Desktop Entry]<br>Name=Windows 7<br>Comment=Windows 7 virtual machine<br>Icon=/home/chunshuyumao/Downloads/QEMU/Win7/win7.png<br>Exec=/bin/bash /home/chunshuyumao/Downloads/QEMU/Win7/setup.sh<br>Terminal=<span class="hljs-literal">false</span><br>Type=Application<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414172743.png"alt="编写图标文件" /></p><p>写好之后，把文件移动到</p><p><code>/home/chunshuyumao/.local/share/applications</code></p><p>之下。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">mkdir</span> -pv ~/.local/share/applications<br>$ <span class="hljs-built_in">mv</span> win7.desktop ~/.local/share/applications<br></code></pre></div></td></tr></table></figure><p>打完收工！这样，GNOME 用户就可以直接从菜单中启动了。</p><h2 id="安装国产毒瘤">安装国产毒瘤</h2><p>安装是一个简单的事情，这里就不进行演示了，不过还是说说怎么使用共享目录。首先，使用宿主机下载虚拟机需要用的安装包后打开虚拟机，从虚拟机里打开共享目录，然后把安装包复制到虚拟机的其他位置，例如数据盘，然后再安装。</p><p>为什么这么麻烦？因为 Windows系统为了安装起见是不会让你强行运行不明不白的文件的。</p><p>安装完软件之后，可以修改下载目录到共享目录，例如：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2023042/20230414203148.png"alt="阿里云盘的下载位置改为共享目录" /></p><h1 id="后语">后语</h1><p>为了虚拟机的性能，我们可以给宿主机来一个 hugepages ——大内存页，然后提供给虚拟机。不过这篇文章太长了，没必要再添加了，下次再做一篇新的也可。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>QEMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Linux 作为主力机一年后</title>
    <link href="/2023/04/13/after-a-year-of-using-linux-as-the-main-computer/"/>
    <url>/2023/04/13/after-a-year-of-using-linux-as-the-main-computer/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>一年前，当我把自己的电脑系统改成 Linux时，我就想着一年快过去、快过去， 我要写一篇文章讲讲自己用 Linux系统如何了！然后真到了一年后，我却懒得写了。现在抽出时间，恰好可以圆一下去年的梦。作为一个总结，我会聊聊两个问题，一个说说自己的感受，一个说说使用 Linux 作为主力机需要的 Windows替代品。</p><h1 id="使用-linux-作为主力机感觉如何">使用 Linux作为主力机感觉如何？</h1><p>首先的评价，Linux 作为主力机其实和 Windows是差不多的。很多人总是在比较 Windows 和 Linux的优缺点，但是很少注意到一点：普通人使用电脑从来不是单单使用系统。论操作系统，BSD 系统可以说是最完美、最优雅的，和 Linux 比没有那么分裂，没有成千上万的发行版动不动就互掐；和 Windows比则更加优雅，而且 还是开源的。但现在个人电脑基本没有几个用 BSD 系，甚至BSD 系的大哥 FreeBSD 还是 MacOS的免费小白鼠，靠全世界的资本家豪掷几千美元糊弄日子。所以在内核、系统设计上比较操作系统的优劣是没有任何意义的，否则 FreeBSD不会活的比使用 它内核的 MacOS还差。大多数人使用电脑用的是电脑软件，也就是系统的生态， 这方面 Windows有绝对的优势。</p><p>Windows对计算机图形化的影响是革命性的，极大的降低了普通人使用电脑的门槛。 Linux则先天不足，因为它继承了老的 Unix 传统，并没有发展出合理、实用、稳定的图形界面。现在的 Linux 系统使用的两大图形界面， <ahref="https://kde.org/" title="KDE">KDE(Kool Desktop Environment)</a> 和<a href="https://www.gnome.org/" title="GNOME">GNOME(The GNU NetworkObject Model Environment)</a> 基于比 Linux 还要古老的 <ahref="https://www.x.org/wiki/" title="X.org">X.org</a>，在设计上可能没有什么大问题，但是在实践中表现确实不好。Linux中的桌面系统是属于软件行列，是可选择的，如果你不喜欢可以使用其他桌面，所以 Linux 的自由、开源带来的分裂也延续到了桌面系统上。在 KDE 和 GNOME基础上创造的桌面又不可胜数。 为了解决 Linux 桌面的短板，<ahref="https://wayland.freedesktop.org/" title="Wayland">Wayland</a>被创造出来作为 X.org 的替代品，但是纯靠爱发电让 Wayland 经过十几年的发展也没有从 Windows 口中撕下一块肉，反倒是和 X11争原本就少得可怜的桌面份额， 而且表现不是很好。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202304/20230413152525.png"alt="KDE 是最早的 Linux 桌面，走 Windows 桌面风格，由于许可证陷入纠纷导致大厂不敢使用，背靠 Qt 公司，实力雄厚，最近几年的 Qt 越做越大，KDE 也逐渐吃香，可能是最具有前景的 Linux 桌面" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202304/20230413152902.png"alt="GNOME 是 KDE 陷入官司后被创造出来替代 KDE 的桌面，以简洁、高效自称，桌面风格类似 MacOS，是许多 Linux 系统的默认桌面，包括著名的红帽系统（RedHat Enterprise Linux, RHEL），实际上，红帽是 GNOME 的最大支持者" /></p><p>说了这么多，似乎 Linux就是一点用也没有？其实也不是，我说了，电脑被使用的是生态不是系统本身。最近几年 Linux 系统磅礴发展，特别是国内出了一个 <ahref="https://www.deepin.org/"title="Deepin">深度系统（Deepin）</a>加深了国人对 Linux系统的认识。最近几年 Linux 的生态逐渐转好，所以很多国内的企业也开始在Linux上抓市场。可能大多数人是受制于某个无形的手，但是他们敷衍的态度还是表明了Linux 在今后一阵子会逐渐在国内扎根。因此在这种背景下，其实使用 Windows和 Linux 其实没有多大区别。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202304/20230413155726.png"alt="深度系统拥有漂亮的桌面和 Windows 般的易用，在某种程度上可以说与 Windows 无缝转接。它用 Wine 配适了国内大多数讨厌 Linux 的大厂的软件，甚至做的比这些大厂的原生 Linux 软件要好" /></p><p>Linux 作为主力机感觉和 Windows差不多，那是不是可以无缝转接？其实不然，还是存在一些问题的，我后面会说。</p><h2 id="选何种-linux-系统">选何种 Linux 系统</h2><p><a href="https://www.linux.org/" title="Linux">Linux 官网</a>上列出的受欢迎的发行版有 24 款， 但其实不止这么点。Linux发行版多，其实主要分成三派： <a href="https://www.redhat.com"title="RedHat">红帽系(RHEL)</a>，包括 <a href="https://www.centos.org/"title="CentOS">CentOS</a>、 <a href="https://getfedora.org/"title="Fedora">Fedora</a> 等企业级系统； <ahref="https://www.debian.org"title="Debian">大便系（Debian）</a>，包括著名的 <ahref="https://ubuntu.com" title="Ubuntu">Ubuntu</a>和国内的各种麒麟系统，主打个人电脑； <a href="https://archlinux.org"title="Arch">Arch 系</a>，包括 <a href="https://manjaro.org"title="Manjaro">Manjaro</a> 和各种新奇的妖魔鬼怪系统，主打的就是妖魔鬼怪。除了这三个派别三足鼎立，还有辽东公孙康之大蜥蜴 <ahref="https://www.opensuse.org"title="OpenSUSE">OpenSUSE</a>，交趾士燮之祖宗之法不可变 <ahref="https://www.slackware.com" title="Slackware">Slackware</a>和南蛮孟获 <a href="https://gentoo.org"title="Gentoo">Gentoo</a>，其余的不足道哉。</p><blockquote><p>Debian 叫做“大便”其实是个调侃罢了，毕竟人家和“大便”就差一个字母。</p></blockquote><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202304/20230413160450.png"alt="Linux 官网上的 Linux 系统" /></p><p>至于这么多系统该选哪一个，那就是见仁见智的问题了。个人建议：</p><ol type="1"><li>大厂背书的。这就得排除各种小喽啰，因为人家保不齐就不维护了。 例如 <ahref="https://cutefish-ubuntu.github.io/"title="CutefishOS">CutefishOS</a> 刚出来就惊艳全场，被誉为国内最漂亮的系统，国内外享名，结果不久就停止维护了，甚至不发个通告，后被其他爱心人士接手维护。所以这类小作坊系统或者个人维护的小玩具就不要用来作主力了，否则大难临头欲哭无泪。</li><li>生态面广的。生态面就是可用软件，现在 RHEL 系和 Debian系都是生态比较好的， 各个大厂提供 Linux版软件都会适配这两个系统，也就是后缀为 rpm 和 deb 的安装包。 这里 Arch打包比较轻松，所以也许可以考虑 Arch。</li><li>本地化好的。这要看个人，有些人可能习惯中文环境或者中国人软件的使用习惯，会选择比较本地化的东西。比如深度系统就是本地化做的很好的，还有 Ubuntu。Ubuntu 是在国内的名声很大，甚至对大多数人而言，Linux 等于Ubuntu，反之亦然。</li></ol><p>综上，其实也就是我列出的三大类别：RHEL系适合企业使用，所以软件比较古老，个人使用比较体验可能不好，如果不添加其他源的话。Debian 系其实就靠 Ubuntu及其衍生系统撑起来的名声，推荐使用Ubuntu，个人桌面基本做到开箱即用，软件也还算可以。不过建议直接使用原版而不是使用国内的各种麒麟版本，麒麟是祥瑞，但在国产 Linux系统里，基本是垃圾的代名词。如果国内出了某个新的麒麟系统，那猜“垃圾”绝对没错，人家就是想过过日子。Arch系最突出的特点就是软件多、广， 软件源新，基本上什么东西刚出来都可以在Arch 上找到，这里说的是 <a href="https://aur.archlinux.org/"title="AUR">AUR（Arch User Repository）</a> 。 这样可选的 Linux就是：</p><ol type="1"><li><p>Fedora, 开瓢的 RHEL系统，的小白鼠。有大厂背书，不会搞到一半人跑路。软件在某种程度上还是很新的，因为是小白鼠级别。说是小白鼠，其实不是说不好，而是很多新的特性都是在 Fedora 上先使用然后看情况转接到 RHEL 系统，看起来就是小白鼠。默认桌面是 GNOME, 桌面风格简约高效 ——自称的，我觉得其实蛮合适， 简约得难以置信。如果还是觉得不好，那 LinusTorvalds, Linux 之父用的就是 Fedora.</p></li><li><p>Ubuntu, 著名的 Linux个人操作系统，虽然也有服务器版。这个基本不用多介绍，人站那就是大佬。默认桌面也是 GNOME. 与 Fedora一样适合小白入手，而且可能比 Fedora更适合。电脑出了啥问题一半在百毒上都可以搜到。</p></li><li><p>OpenSUSE, 德国人的 Linux操作系统。德国人以严谨著称，该系统也和德国人一样呆板、严谨，很优秀但国内知名度不高。默认桌面是 GNOME.</p></li><li><p>Manjaro, Arch 系。包括 Arch 的优秀特性，但是去除了 Arch入手难度高的缺点， 是一个优秀的 Arch 发行版。如果觉得自己没能力驾驭Arch, 但又想使用 AUR 上各种 各样的软件，可以尝试 Manjaro ——但是千万不要添加 AUR 国内源，一半的 Manjaro 都是因为这个挂的，使用正统AUR 就行了，国内软件也有打包，没必要用国内源。默认有三个桌面：GNOME、KDE 和 XFCE，还有其他的社区维护桌面版本。</p></li><li><p>Arch Linux, 进阶版本的 Linux.凭心而论，不适合小白使用，属于进阶用户的入门系统。没有默认桌面，或者说默认没有桌面。Arch的用户手册称第二没人敢称第一 —— Gentoo可能也敢称第二。基本上电脑遇到的问题都可以在用户手册上找到，相当于把Ubuntu 遇到的问题集合到了一起。</p></li><li><p>Gentoo, 进阶版本的 Linux. Arch 进阶，Gentoo 则更疯狂，会使用 Arch不一定 会用 Gentoo, 但会 Gentoo 一般就不怕 Arch 烦人了。和 Arch一样属于手册极其 详尽的系统，但是没有点 Linux基础和使用经验可能不习惯。</p></li><li><p><a href="https://www.linuxfromscratch.org" title="LFS">Linux FromScratch</a>, LFS. 高级 版本的 Linux. 从头打造自己的 Linux系统。走过几次安装手册，只要会做 Logo，就可以自己做一个国产的操作系统，然后去坑蒙拐骗了。</p></li></ol><p>上面列出了 7 个发行版，前四者基本做到开箱即用，特别是Ubuntu；后三者则是习惯 Linux 后的进阶版本，其中 LFS可能最多做个玩具练练手，但其余两者可以作为主力 使用，我使用的就是 Arch,前期使用 Manjaro 作为过度。</p><h2 id="linux-桌面">Linux 桌面</h2><p>Linux 桌面不够稳定是事实，但主要还是看使用的人。我使用的是 ArchLinux，感觉 还是很稳定的，特别是使用 Manjaro期间，基本没有遇上什么问题。Linux 系统最怕的 就是 Nvidia卡（N卡）和游戏。如果在这方面没有什么特殊追求，一般而言还是很稳定的。上面介绍过，Linux 桌面主要是 GNOME 和 KDE, 还有各种分化的桌面XFCE、 Cinnamon、LXDE、Mate 等妖魔鬼怪和直接使用窗口管理器的平铺窗口 <ahref="https://i3wm.org" title="i3">i3wm</a>、<ahref="https://swaywm.org" title="swaywm">Swaywm</a> 等。给桌面选择添加几个过滤条件，其实也就 GNOME 和 KDE 两种。GNOME 和 KDE所占份额 最大，其中 GNOME 有 RHEL 背书，KDE 背靠Qt，没啥后顾之忧，其余的不是用爱发电就是高手的进阶桌面，不适合日常使用。当然，一些 GNOME 衍生的版本，例如Mate 还是很值得玩味的。有人说 GNOME、KDE太重。其实正常情况下，他们也没多少占用。</p><p>我的 Arch 使用的是 GNOME 桌面。Linux 桌面不论是 GNOME 还是 KDE其实可能都做不到开始直接使用，因为每个人的审美都是不一样的，难免要进行一些调整。GNOME的调整一般通过 <a href="https://extensions.gnome.org"title="GNOME Shell Extension">GNOME Shell 插件</a> 调整， KDE自带的样式调整就够了。调整桌面一般也会整桌面主题，就像手机的主题一样，这些微调会给人一种满足感，就像整自己手机一样。同样的，这种快乐一般诱发时间的流逝，所以很多刚接触 Linux的人会莫名其妙花很多时间打扮自己的系统，然后有一种分享欲。一开始大家肯定不知道怎么调整才好，会自然而然地搜各种美化教程。不过说实话，习惯之后会觉得，其实这些没必要。但是这两个系统如果是从头搭建，一般都需要装插件或者调整。KDE 桌面调整的需要少一点，GNOME不调整会觉得桌面很丑。</p><p>选好发行版和桌面基本上就可以安装使用了。一般而言，安装某个发行版最好的方式是看官方教程，看网上的教程很多都是相互借鉴的，甚至不知所云的，容易把系统搞坏。</p><h1 id="linux-上的-windows-替代">Linux 上的 Windows 替代</h1><p>在国内使用 Linux 系统不可避免要碰到一些问题，不过国内的 Linux生态逐渐得到完善， 很多软件都有 Linux原生版本了，比如百度网盘，可以直接到官网下载 Linux 版本。 对 Linux系统来说，很少有直接使用安装包安装的习惯，一般是依靠包管理器，例如 RHEL系的 dnf、yum，Debian 系的 apt 和 Arch 系的 pacman. 对于 Arch 系的系统可以直接使用 <a href="https://github.com/Jguer/yay" title="YAY">yay</a>,一个 AUR 助手，可以 完成 Linux 软件和很多用户打包软件的直接安装。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202304/20230413185910.png"alt="Yay 搜索 baidunetdisk 的结果，结果显示的是可以下载的百度网盘软件，还会有简短的介绍" /></p><p>如果不知道哪些软件有没有 Linux 版本，可以上网搜搜或者直接到 AUR上面查看有没有这个包。如果不喜欢使用命令行，现在的各种发行版都会有自己的软件商店。除了百度网盘还有 Linux 版本的有：</p><ol type="1"><li><p>WPS for Linux. Linux 版本的WPS，功能差别不大，可用，没有广告，可以登录账号。</p></li><li><p>QQ for Linux. 最新的 Linux 版 QQ，基于 Electron,功能还算完善，使用过觉得 不错。如果不喜欢可以选择其他基于 <ahref="https://www.winehq.org" title="Wine">Wine</a> 的版本。</p></li><li><p>Wechat for UOS. 统信系统定制版的微信。没啥可说的，也是基于Electron. 功能应该还算完善吧，也有 Wine 版本可选。</p></li><li><p>Nutstore for linux. 坚果云 Linux 版。还行，不常用。</p></li><li><p><a href="https://github.com/liupan1890/aliyunpan"title="小白羊">Aliyunpan</a>. 阿里云盘小白羊版。</p></li><li><p>Neteasti Cloud Music. 网易云音乐 Linux 版本。</p></li><li><p><a href="https://y.qq.com/download/download.html"title="QQ Music">QQ Music for linux</a>. QQ 音乐 Linux 版本。</p></li><li><p>WemeetApp. 腾讯会议 Linux 版，不过只能在 X11协议下分享屏幕，Wayland 暂时不行。</p></li><li><p>...</p></li></ol><p>不过对我来说，国产软件就像毒瘤，我不愿让它们污染我的电脑，所以是不会安装的。例如百度网盘、阿里云盘和迅雷、QQ、微信等。我的习惯是，开一个虚拟机，把这些毒瘤装上去，然后给它们 1G 内存，让它们自己折腾。我在 Linux 上使用虚拟机虚拟的是 Windows7，不是不想用 WindowsXP, 而是自己确实装不上。Windows7的优点 是即使内存占用很高还是很流畅。我之前虚拟过Windows10，卡的不行。别说是在里边运行国产毒瘤了，就是在桌面上右键都要等半天，最后只能选择经历史考验的Windows7 系统。使用 <a href="https://www.qemu.org" title="QEMU">QEMU</a>进行虚拟，也可以使用 <a href="https://www.virtualbox.org"title="vbox">Oracle VM VirtualBox</a> 或者 <ahref="https://www.vmware.com" title="vmware">VMware</a>。QEMU图的是轻量级，虚拟完可以写一个图标文件，把虚拟机放到桌面或者软件界面，开机启动挂载微信和 QQ放到另一个工作区， 时不时用一些国产毒瘤来下载东西。这里不用 Linux版是因为，这些毒瘤鬼知道会拿点什么隐私东西。把他们放到虚拟机给点内存能活就行，它们可以在里边大展手脚，爱怎么折腾怎么折腾。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202304/20230413191425.png"alt="GNOME 上用 QEMU 虚拟的 Windows7 系统和系统图标" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202304/20230413191530.png"alt="打开的 Windows7 系统和系统桌面" /></p><p>对于使用 QEMU 虚拟 Windows 系统我后面打算也写一个教程。不过对 QEMU的使用仅限于皮毛，因为不是科班出生，计算机硬件了解不多。除了这些，也可以在Windows7 虚拟机上运行一些 Windows独占的软件，给点内存就行。至于打游戏这种东西，Linux确实带不动，所以最好给电脑来个双系统，以防万一想打游戏。</p><p>对于文字处理，例如 Microsoft WORD，可以用 WPS for Linux替代，我则使用<a href="https://github.com/vim/vim" title="VIM">VIM</a> + <ahref="https://pandoc.org/" title="Pandoc">Pandoc</a>, 先用 Markdown写下文字，然后用 Pandoc 将 Markdown 转为 DOCX 格式，所以对 WPS for Linux也就图个能看就行。对于 PDF 文件，一般使用 zathura 查看就行了。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202304/20230413194332.png"alt="VIM 用 Markdown 写文章，通过 Pandoc 转换然后在浏览器中查看。左侧是 VIM 写的 Markdown 格式，右边是 Pandoc 转换的 HTML 格式" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202304/20230413194726.png"alt="zathura 查看 PDF 文件，设置了护眼模式" /></p><p>文献管理用 <a href="https://www.zotero.org/"title="Zotero">Zotero</a>, 配合坚果云可以和手机的 <ahref="https://github.com/mickstar/Zoo-For-Zotero">Zoo for Zotero</a>进行跨平台文献查看。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202304/20230413194952.png"alt="Zotero 界面，可以配置暗色护眼" /></p><p>除了游戏以外，特别是对电脑性能要求高的游戏，比如我之前玩的 Arma3, 在Linux 上安装 Steam 玩成 PPT 模式，Linux可以应付生活中大部分工作。不过一些游戏，例如《饥荒》就不用担心完全可以带动。我觉得玩游戏还是用 Windows系统比较好， Windows 和 Linux不是不共戴天，而是可以互补的。我的电脑是双系统，一般只用 Linux,打游戏就使用 Windows.</p><p>然后是 Linux 系统上的输入法，我用的是 <a href="https://fcitx-im.org"title="Fcitx5">Fcitx5</a>, 手机上用 <ahref="https://github.com/fcitx5-android/fcitx5-android"title="fcitx5 for Android">Fcitx5 for Android</a> ， 后者可以在 <ahref="https://f-droid.org" title="F-Droid">F-Droid</a> 和 Github上下载。手机上的 Fcitx5颇有谷歌输入法的风范，蛮好看。不使用国内的输入法是因为，国产软件实在恶心，感觉总要把人底裤扒得干干净净才好。使用 Fcitx5,电脑的词库可以和手机的词库互通，还不用担心人民企业家们偷窥你的隐私。除了Fcitx5，还有一个开源的 输入法叫 <a href="https://rime.im"title="Rime">中州韵Rime</a>。不过这个输入法（引擎）不是很适合普通人，并且有些行为确实反人类：长按输入字符或者键盘上写各种提示。这个输入法引擎很优秀，但是不是普通人能用的，而且看他原本也不是拼简体的 ——可以， 但不是本职，懒得折腾就直接使用 Fcitx5。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202304/20230413202808.png"alt="Fcitx5 在电脑上的输入框，开了百度输入法的云输入，第二个候选字，有云输入还是很准确的" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202304/20230413202514.jpg"alt="Fcitx5 在手机上的界面，界面类似谷歌输入法，简洁明了" /></p><h1 id="后语">后语</h1><p>重新写博客，我打算写写消失几个月内做的一些事，包括：</p><ol type="1"><li>QEMU 虚拟 Windows7 直接使用国产毒瘤，其中会包括使用 VirtIO提供更好的体验。</li><li>Arch Linux 和 Windows 双系统无缝切换。</li><li>Arch Linux 安装 Nvidia 卡，并在需要的时候调用。</li><li>五笔输入法快速入门。</li><li>布努文字入门。</li></ol><p>其中，布努文字草案虽出来很久了，但是我觉得都不太好，打算按照自己的方言整合一套文字。自己最近也在按自己整合的文字重新数字化一本布努文字典，不过一万多个词条太多了，可能会时不时在博客更新。此外还有自己写的一些小脚本，例如 VIM上写 Markdown,感觉如果有时间也会记记什么的。最近也没有在做什么，只是觉得做的东西不是很适合写下来罢了。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode 通过 SSH 远程使用服务器</title>
    <link href="/2022/11/22/VSCode-%E9%80%9A%E8%BF%87-SSH-%E8%BF%9C%E7%A8%8B%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2022/11/22/VSCode-%E9%80%9A%E8%BF%87-SSH-%E8%BF%9C%E7%A8%8B%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>统计计算和机器学习常常需要借助计算力更强的计算机，也就是服务器。然而服务器一般只能通过SSH(Secure Shell) 登陆，没有界面。SSH可以在自己的电脑和服务器之间建立安全的链接，使用自己的服务器。没有界面只有控制台，对于浸淫命令行操作的人来说不是什么大问题；然而很多的科研人员并不是专业开发人员，并不一定对计算机很了解，只有一个终端就成了障碍。</p><p><a href="https://code.visualstudio.com/">VS Code(Visual StudioCode)</a>是微软推出的一款跨平台编辑器。因其强大的扩展能力和微软雄厚的资金支持，VSCode 得到快速发展，现在基本成一个可以配置成任何一门语言 IDE(IntegratedDevelopment Environment，集成开发环境)的编辑器。鉴于此，本篇将通过简单的配置，在 VS Code上使用自己的远程服务器。</p><h1 id="预备">预备</h1><p>想使用 SSH 需要自己的电脑安装 SSH。Windows、Linux 和 MacOS系统一般都自带 SSH。Windows10 以下则需要手动配置。验证自己电脑是否有SSH，可以打开控制台，输入 <code>ssh --version</code>.如果出现类似的提示则表明本机的 SSH 可以使用。如果不可以用，Windows系统到 <ahref="https://learn.microsoft.com/zh-cn/windows-server/administration/openssh/openssh_install_firstuse?tabs=gui">微软教程</a>查看如何安装；MacOS 使用 <code>brew install openssl</code>进行安装，一般预装；Linux系统没有安装就使用自己的包管理器或到软件应用商店安装。</p><blockquote><p>Linux 系统的包管理器太复杂了，一般来说</p><p>Arch Linux 系列: <code>sudo pacman -Syu openssl</code></p><p>Ubuntu/Debian 系列: <code>sudo apt install openssl</code></p><p>RHEL 系列: <code>dnf install openssl</code> 或者<code>yum install openssl</code></p><p>这是 Linux 最常见的三个分发版。</p></blockquote><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221122110635.png"alt="检查 SSH 是否安装成功" /></p><p>SSH 准备好就可以安装 VS Code 了。</p><h1 id="配置-vs-code">配置 VS Code</h1><p>到 <a href="https://code.visualstudio.com/">VS Code(Visual StudioCode)</a>官网去下载对应的版本然后安装。安装步骤比较简单，此处不再赘述。安装打开VS Code并按照提示安装中文插件，不愿使用中文本地化插件可以不安装。安装完毕之后选择左上角的四个方框的图标，那是插件商店。搜索SSH，安装 Remote SSH 和 RemoteX11，前者用于远程登录，后者用于端口转发。当然，也可以不安装后者。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221122091008.png"alt="安装 SSH 插件" /></p><p>插件安装完毕按 <code>CTRL+SHIFT+P</code> 快捷键调出命令面板，输入 ssh添加主机——也就是服务器。输入 <code>ssh username@hostip</code>添加主机，然后保存。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221122091126.png"alt="调出命令面板" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221122091302.png"alt="添加主机" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221122091340.png"alt="选择保存的文件" /></p><p>添加完毕，VS Code会提示是否连接，这时候可以选择连接。下次想要再使用不需要添加主机，而是直接呼出命令面板，然后输入ssh connect 即可：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221122091358.png"alt="是否连接" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221122091506.png"alt="再次连接" /></p><p>第一次连接，VS Code 会询问主机是什么系统，一般服务器都是Linux，这里演示的主机服务器是 Linux，所以选择 Linux系统。连接速度因人而异，期间可能需要输入密码。这里的演示不需要，因为后面可以设置不需要密码登录。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221122091532.png"alt="Linux 主机" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221122091546.png"alt="正在连接" /></p><p>连接成功后会弹出一个提示，告诉你对主机的配置放在何处，不用担心。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221122091629.png"alt="弹出的提示" /></p><p>按照 <code>终端-&gt;新建终端</code>或者快捷键打开终端。这时可以看到服务器的终端。</p><h1 id="使用-vs-code">使用 VS Code</h1><p>在连接 SSH的前提下看到左边启动界面有一个打开文件夹的操作，可以选择打开服务器的目录。打开目录时，VSCode 会询问是否信任该目录。勾选信任，不然无法操作。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221122092128.png"alt="打开目录" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221122092204.png"alt="信任" /></p><p>信任之后可以打开目录下的文件。打开文件时 VS Code会提示是否安装某些插件，建议直接选择安装这类插件。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221122092305.png"alt="打开文件" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221122092330.png"alt="安装插件" /></p><p>VS Code 功能非常强大，可以在左边 Git 侧边栏查看修改的文件有哪些。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221122092420.png"alt="Git 侧边栏" /></p><p>插件安装完毕可以进行其他操作，比如看到 VS Code 提示找不到这些 Python包。这是因为我们没有激活合适的服务器环境。这里的服务器使用 conda/mamba进行环境管理，可以手动选择合适的环境。呼出命令面板，输入<code>python interpreter</code> 寻找合适的 Python环境。我的服务器工作环境是 Pytoch2，因此选择该环境。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221122092553.png"alt="没有找到合适的包" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221122092814.png"alt="呼出命令面板" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221122092835.png"alt="选择环境" /></p><p>选择合适的环境后，VS Code 可以找到 Python 包了。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221122092915.png"alt="找到软件包" /></p><h1 id="运行">运行</h1><p>打开好环境，我们可以尝试运行。选择 VS Code右上角的运行，点击即可。运行的输出会出现在终端。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221122093014.png"alt="运行" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221122093042.png"alt="终端输入" /></p><p>运行结果如何先不管。但是如果输入有图片，VS Code 也可以查看。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221122093554.png"alt="查看图片" /></p><h1 id="关闭">关闭</h1><p>当运行完毕，没有其他工作了，可以选择关闭 SSH 连接。呼出命令面板，输入<code>close remote connection</code> ，确认即可。</p><h1 id="后语">后语</h1><p>简单记录一下罢了。除了 VS Code，其实还可以使用Jupyter。不过自己的工作环境安装 Jupyter有问题，除非新建环境。既然如此，那又何必折腾？虽然 Jupyter看起来确实漂亮。</p><h1 id="补充">补充</h1><p>如何使用 SSH 密钥直接登陆服务器，不用每次都输入密码？</p><p>在自己的终端输入</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ ssh-keygen -r rsa<br></code></pre></div></td></tr></table></figure><p>回车三次。不需要输入啥。这一步会在自己家目录 <code>.ssh</code>下生成两个密钥文件: id_rsa 和id_rsa.pub，前者是私钥后者是公钥。公钥可以部署到服务器用于配对，私钥用于确认身份。私钥不可公开，否则就没有意义了。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221122124637.gif"alt="生成密钥对" /></p><p>生成密钥对之后在命令行输入</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ ssh-copy-id user@host<br></code></pre></div></td></tr></table></figure><p><code>user</code> 是用户名，<code>host</code> 是服务器IP。这会默认复制你的公钥到服务器 <code>~/.ssh/authorized_keys</code>文件中。做完这些，以后登录服务器就不必输入密码了。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSH</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pandoc 生成参考文献的 etal 问题</title>
    <link href="/2022/11/21/Pandoc-%E7%94%9F%E6%88%90%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%E7%9A%84-etal-%E9%97%AE%E9%A2%98/"/>
    <url>/2022/11/21/Pandoc-%E7%94%9F%E6%88%90%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%E7%9A%84-etal-%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>之前埋了坑，今天得填。使用 Pandoc 按照 CSL(Citation Style Language)生成参考文献时会因为本地化问题出现一些小问题。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221121113010.png"alt="问题再现" /></p><p>CSL 文件可以设置多个本地化判断，但是 Pandoc渲染出来的依旧是中文。可能和 Zotero 导出的语言设置有关。反正单单使用 CSL文件改变不了什么，我们需要其他方法。</p><p>参考文献输出结果有问题，我们可以考虑用正则表达式进行替换。这种方法最简单，也是多数人能够想到的。此外，Pandoc允许通过筛选脚本(Filter)对文件进行转换前、后的修改。<a href="/2022/11/20/Pandoc-%E4%BB%8E-Markdown-%E5%88%B0%E5%85%B6%E4%BB%96%E6%A0%BC%E5%BC%8F/" title="Pandoc: 从 Markdown 到其他格式">Pandoc: 从 Markdown 到其他格式</a>里引入的 Pandoc-crossref本质也是一个筛选脚本：筛选出交叉引用的标记并进行格式转化。Pandoc的命令行 <code>--citeproc</code> 选项，未并入 Pandoc内置命令之前也是一个筛选脚本，现在的 Pandoc 还保留着它的原始用法，即<code>--filter pandoc-citeproc</code>。因此，对 Pandoc文本进行修改也可以借助筛选脚本。这样我们就有了计划，准备行动吧！</p><h1 id="正则替换">正则替换</h1><p>正则替换有两个办法，一个是在 Word 软件，例如 WPS Word 或者 MicrosoftWord 中直接搜索替换。另一个比较复杂需要其他操作，待会解释。</p><h2 id="wps-正则替换">WPS 正则替换</h2><p>WPS可以替换但有点不大合适，如果参考文献的数字标号是括号而不是方括号，我们就得正则表达式，而且这个正则用起来总感觉差点意思，也许叫做通配符好一点。MicrosoftWord 也差不多，效果基本如此。此外，这是在 WPS 2019 for linux测试的，使用不了网上说的 <code>^s</code> <code>^w</code>等空白符号，空白符原原本本就是 <code></code> 。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">查找：(\[[0-9]&#123;1,&#125;\][ ]*^t&#123;1,&#125;[a-zA-Z, ]&#123;1,&#125;)等<br>替换：\1et al<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221121135756.gif"alt="WPS Word 正则替换 国标2005 的参考文献" /></p><p><code>\[</code> 和 <code>\]</code> 包起来的是参考文献的标号，标号是用<code>[0-9]</code> 代替数字，<code>&#123;1,&#125;</code>表示数字至少有一个。<code>[ ]*</code> 表示任意多个(0个以上)空白符。空白符可以直接使用 <code></code>替代，由于无法保证只有一个空白符，所以选择任意多个。WPS 不支持<code>*</code> 这种写法，所以使用 <code>[]</code> 包住空白符，然后用<code>*</code> 限定。<code>[]</code> 表示方框中任何一个符号，比如<code>[34]</code> 表示可以是 <code>3</code> 或<code>4</code>。<code>^t</code> 是制表符，就是 <code>Tab</code>键，起码一个。<code>[a-zA-Z, ]</code>表示任何英文字母、空白符和逗号。括号括起来表示捕捉这个字符串，后面的“等”表明这个字符串后面必须跟一个中文“等”。“替换”的<code>\1</code> 代表查找到的字符串。这属于硬编码，健壮性不足。</p><h2 id="纯正的正则">纯正的正则</h2><p>除了 WPS 和 Office内的替换，我们还可以使用更为神奇的正则，毕竟真正的正则替换编写的代码更健壮一点。不过这一步需要使用支持正则的工具，比如Python 和 SED。如果电脑本来就装有前者还好，没有的话纯当作长见识。SED 是Stream EDitor的缩写，中文叫做流式编辑器。这东东虽然是命令行操作，但本质是一个编辑器。Windows系统不用想了，SED 是 Linux 系统标配。</p><p>如果使用 Windows，不建议下面的操作，所以下面的演示就当作是 Linux系统独占——虽然并非如此，但 Windows 的 Dos真的太弱了，不适合写脚本——不适合我写。</p><p>之前说过，DOCX 是二进制文件，但没说是哪一类。DOCX不是我们理解中的那种二进制，而是一种压缩包，解压缩就能看到内容。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221121144133.gif"alt="解压 DOCX 文件" /></p><p>解压后有一堆文件，都是 XML 文本文件，可以直接使用 SED进行正则替换。文字内容在 <code>word/document.xml</code>这个文件。打开文件可以看到内容。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221121144416.png"alt="文字内容位置" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221121144723.png"alt="文字内容" /></p><p>接下来就是替换。使用 SED 暴力替换：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sed -i <span class="hljs-string">&#x27;s/\([a-zA-Z\.\s]\+\)\(,\s\|\s\)\+等\./\1\2et al./g&#x27;</span> word/document.xml<br></code></pre></div></td></tr></table></figure><p><code>-i</code>是原位替换，直接在源文件替换。替换分为三个部分：<code>s/find/replace/flag</code>。<code>s</code>表示替换 substitute，<code>find</code>表示目标字符串，<code>replace</code> 表示替换后的字符串，<code>g</code>表示全局替换global，斜杠用来分隔。<code>\([a-zA-Z\.\s]\+\)\(,\s\|\s\)\+等</code>找到字母、逗号、点和空白(<code>\s</code>)字符，紧接着一个中文<code>等</code>，然后替换成 <code>et al</code>。效果与 WPS差不多，只是不需要使用 WPS 或者 Office，用 SED 即可。替换 HTML 直接使用<code>sed</code> 操作，如：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sed -i <span class="hljs-string">&#x27;s/\([a-zA-Z\.\s]\+\)\(,\s\|\s\)\+等\./\1\2et al./g&#x27;</span> test.html<br></code></pre></div></td></tr></table></figure><p>替换完毕，将这些东东原原本本压缩回去：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ zip -r new.docx *<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221121145806.png"alt="重新压缩" /></p><p>用 WPS 打开新文件看看替换的效果：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221121150031.png"alt="替换后的 new.docx 文件" /></p><p>替换这一步可以用其他语言写，例如 Python、Lua等。压缩完毕后只需要覆盖原文件就可以了。这样太麻烦了，可以写一个脚本：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> -Eeuo pipefail<br><br><span class="hljs-comment"># 退出时删除临时文件</span><br><span class="hljs-built_in">trap</span> clean EXIT<br><span class="hljs-comment"># 生成临时文件</span><br><span class="hljs-built_in">declare</span> -r tmpdir=<span class="hljs-string">&quot;<span class="hljs-subst">$(mktemp -u -d)</span>&quot;</span><br><span class="hljs-comment"># 获取文件的全路径</span><br><span class="hljs-built_in">declare</span> -r target=<span class="hljs-string">&quot;<span class="hljs-subst">$(readlink -m <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span>)</span>&quot;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">clean</span></span>() &#123;<br>  <span class="hljs-keyword">if</span> [ -e <span class="hljs-string">&quot;<span class="hljs-variable">$tmpdir</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>    /bin/rm -rf <span class="hljs-string">&quot;<span class="hljs-variable">$tmpdir</span>&quot;</span><br>  <span class="hljs-keyword">fi</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">main</span></span>() &#123;<br><br>  <span class="hljs-comment"># 解压缩，-q 表示 quiet，不用输出信息</span><br>  unzip -qd <span class="hljs-string">&quot;<span class="hljs-variable">$tmpdir</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span><br>  <span class="hljs-built_in">pushd</span> <span class="hljs-string">&quot;<span class="hljs-variable">$tmpdir</span>&quot;</span><br>  sed -i <span class="hljs-string">&#x27;s/\([a-zA-Z\.\s]\+\)\(,\s\|\s\)\+等\./\1\2et al./g&#x27;</span> word/document.xml<br>  zip -qr <span class="hljs-string">&quot;<span class="hljs-variable">$target</span>&quot;</span> *<br>  <span class="hljs-built_in">popd</span><br>&#125;<br><br>main <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span> &gt; /dev/null<br></code></pre></div></td></tr></table></figure><p>保存到某个路径，例如<code>/home/chunshuyumao/Documents/Pandoc</code>，并在 Shell配置文件，如 <code>.bashrc</code> <code>.zshrc</code>，加入<code>alias reorg=$HOME/chunshuyumao/Documents/Pandoc/reorg.sh</code>。重新打开终端，使用<code>reorg 文件</code> 就可以完成整个替换。</p><p>相信正则替换看着已经头大了。正则替换确实不是很好。举个例子，如果不是生成DOCX 或者 HTML 而是 PDF 文件，那上帝也救不了。相比于 DOCX这种假的二进制文件，PDF可是实打实的难以修改，正则只能对付对付文本文件，复杂的二进制只能见鬼。由此可见，简单使用正则不是解决之道。要想彻底解决这个问题，我们还是得回到Pandoc 这个“罪魁祸首”。</p><h1 id="解铃还需系铃人">解铃还需系铃人</h1><p>兜了一圈还是回到了 Pandoc。Pandoc 使用 pandoc-citeproc/citeproc解析参考文献是内部机制改变不了，只能想其他办法。之前说过 Pandoc 支持使用Lua 写筛选脚本，最好到 <ahref="https://pandoc.org/lua-filters.html">官网</a> 了解 Pandoc调用筛选脚本的步骤。</p><figure class="highlight clean"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs clean">source -&gt; AST -&gt; filter -&gt; AST -&gt; target<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221121152414.png" /></p><p>AST 是 Abstract SyntaxTree，抽象语法树的缩写。这东东听起来有点抽象，其实就是给字符加上一点标记。举个例子，<code>2022</code>是一个字符串，如果在 Python中它被认为是数字，我们就给它一个结构，长这样：</p><figure class="highlight arcade"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arcade">struct &#123;<br>  <span class="hljs-built_in">text</span> = <span class="hljs-string">&#x27;2022&#x27;</span><br>  type = <span class="hljs-built_in">number</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>这样程序读取的时候只要查看 <code>type</code>就知道，原来这是一个数字。如果 <code>type</code> 换成<code>string</code> 那就被认为是字符串。但是内容 <code>2022</code>完全一样。编程语言就是通过这样的方式区分各种标识符到底是什么东西。这东西还可以分析语言，比如<code>牛</code> 这个字，用 <code>形</code> 或者 <code>adj</code>表示形容词，用 <code>名</code> 或者 <code>n</code> 表示名词。但是<code>牛</code>完全就一个写法。机器就是通过这个笨拙的方式去了解语言。</p><p>我解释这个是为啥？因为无聊。</p><p>写 Filter，我们解决的是 Pandoc 读取所有源文件之后的数据，处理完之后Pandoc 再进行处理输出。废话不多说，开始干活。</p><h2 id="pandoc-抽象语法树">Pandoc 抽象语法树</h2><p>得先了解这个语法树是个什么。Pandoc 提供了一个叫 <code>native</code>的格式允许我们将自己的格式转换成它的语法文件。打开命令行，输入</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ pandoc -d ~/Documents/Pandoc/defaults/HTML.yaml -t native test.md -o test.json<br></code></pre></div></td></tr></table></figure><p>YAML 文件是上一篇文章 <a href="/2022/11/20/Pandoc-%E4%BB%8E-Markdown-%E5%88%B0%E5%85%B6%E4%BB%96%E6%A0%BC%E5%BC%8F/" title="Pandoc: 从 Markdown 到其他格式">Pandoc: 从 Markdown 到其他格式</a> 最后写的文件，调用Pandoc-crossref、citeproc 和一些其他的配置。这个 test.md文件只需要包含引用即可，没什么别的要求。native 格式不一定是JSON，我只是为了高亮显示，所以后缀写成了 JSON。转换结束后打开：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221121154858.png"alt="红框内为语法标记" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221121155403.png"alt="一篇文献在 Pandoc 内的表示" /></p><p>可以看到，Pandoc 内部使用一个 <code>Div</code>标识包住一篇参考文献，而且标签中有 <code>ref</code>字样，参考文献内有一个奇葩的字符串 <code>\31561</code>代表中文的“等”，类型标识是 <code>Str</code>。记住这两个即可。</p><h2 id="编写-pandoc-filter">编写 Pandoc Filter</h2><p>Pandoc Filter 的说明还是蛮清晰的，这里直接使用，不进行讲解。Pandoc解析输入文件生成的语法树分为两部分，一部分叫做 <code>Pandoc</code>代表正文，另一部分是 <code>Meta</code> 表示 <code>front-matter</code>的信息。我们修改正文只需处理 Pandoc。在之前的目录<code>/home/chunshuyumao/Documents/Pandoc</code> 新建一个 filters目录，目录里边创建一个 cite_et_al.lua 文件。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">mkdir</span> -p /home/chunshuyumao/Documents/Pandoc/filters<br>$ <span class="hljs-built_in">touch</span> cite_et_al.lua<br></code></pre></div></td></tr></table></figure><p>打开 cite_et_al.lua，在里边写入以下内容：</p><figure class="highlight lua"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Pandoc</span><span class="hljs-params">(doc)</span></span><br>  doc:walk&#123;<br>    Div = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(div)</span></span><br>      <span class="hljs-built_in">print</span>(div)<br>    <span class="hljs-keyword">end</span>,<br>  &#125;<br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure><p>只处理 Pandoc 部分所以创建一个 Pandoc 函数，文档中指出 Pandoc函数只有一个参数，取名为 doc. 几乎所有的 Pandoc 类型都有一个<code>walk</code> 函数用于遍历其内部元素，所以调用它，传入的参数是一个Table(表)，这是 Lua 内最常用的数据类型，与 Python 的表 <code>&#123;&#125;</code>差不多。表内有唯一的一个 key(键) 叫做 <code>Div</code>，表示我们只处理<code>Div</code> 类型，这个键对应的 value(值) 是一个函数，函数只是打印<code>Div</code> 类型，其他什么也不做。</p><p>Lua有一个语法糖：当函数只有一个参数时，函数调用的括号可以省略。<code>walk</code>只有一个参数，所以括号被省略，原本的调用应该是:</p><figure class="highlight lua"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lua">doc:walk(&#123;<br>  Div = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(div)</span></span><br>    <span class="hljs-built_in">print</span>(div)<br>  <span class="hljs-keyword">end</span>,<br>&#125;)<br></code></pre></div></td></tr></table></figure><p><code>walk</code> 是 <code>doc</code> 的成员，Lua调用成员函数使用的是 <code>:</code>，有别于 Python、类C 语言的<code>.</code>。</p><p>解释完毕。打开之前的 HTML.yaml 文件，在 filters选项下添加脚本，并执行转换。</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">filters:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">pandoc-crossref</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">citeproc</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">cite_et_al.lua</span><br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221121162559.png" /></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ pandoc -d ~/Documents/Pandoc/defaults/HTML.yaml test.md -o test.html<br></code></pre></div></td></tr></table></figure><p>下面执行转化不再列出代码，因为输入的就是上面这一行。查看输出：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221121163016.png"alt="意外发现" /></p><p>执行后发现很多的 Div被打印，其中有一个，即上图红圈内，包含了所有的引用文献。它的标签也很特别，其他文献引用是“ref-” + citationkey, 它是“refs”。这就好办了，只需要修改它就行了，不用一个一个找其他的文献在哪。它内部的文献仍然是一个Div 包围。所以我们筛选出来:</p><figure class="highlight lua"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Pandoc</span><span class="hljs-params">(doc)</span></span><br>  doc:walk&#123;<br>    Div = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(div)</span></span><br>      <span class="hljs-comment">-- 查找 refs Div</span><br>      <span class="hljs-keyword">if</span> (div.identifier <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;&#x27;</span>):<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;refs&#x27;</span>) <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">print</span>(div)<br>      <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span>,<br>  &#125;<br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure><p><code>identifier</code> 是 Div 的标签，其实是 Div 里的 attr 内的identifier 的引用。什么意思内，就是 <code>div.identifier</code> 等于<code>div.attr.identifier</code>，因此不必写那么长，可以用<code>div.identifier</code> 代替即可。<code>or</code> 表示如果没有<code>identifier</code> 域则用空字符串('')代替，这是 Lua 的语法糖。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221121163956.png"alt="Div 的 attr 结构" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221121164035.png"alt="attr 内的 identifier" /></p><p>执行转化，查看输出：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221121164303.png"alt="成功输出 refs Div" /></p><p>找到之后对 refc Div 内的文献操作需要写一个函数：</p><figure class="highlight lua"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lua"><br><span class="hljs-comment">-- 这是处理文献的函数</span><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ref_div</span><span class="hljs-params">(div)</span></span><br>  <br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Pandoc</span><span class="hljs-params">(doc)</span></span><br>  <span class="hljs-keyword">return</span> doc:walk&#123;<br>    Div = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(div)</span></span><br>      <span class="hljs-comment">-- 查找 refs Div</span><br>      <span class="hljs-keyword">if</span> (div.identifier <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;&#x27;</span>):<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;refs&#x27;</span>) <span class="hljs-keyword">then</span><br>        div.content = div.content:walk&#123; Div = ref_div, &#125;<br>        <span class="hljs-keyword">return</span> div<br>      <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span>,<br>  &#125;<br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure><p>Div 的内容部分在 <code>content</code> 域里，所以使用<code>walk</code> 函数对 refs Div 的 content结构域进行遍历。同时写一个新的函数，函数前面有个 <code>local</code>表示脚本之外无法调用。这是 Lua 的一些技巧，方便索引。遍历结束后返回content 替换掉 Div 原本的内容，最后返回修改的 Div.</p><h2 id="处理-str-部分">处理 Str 部分</h2><p>记得最开始的分析吧，我们要处理的是文献 Div 里的 Str类型。因此修改代码：</p><figure class="highlight lua"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ref_div</span><span class="hljs-params">(div)</span></span><br>  <span class="hljs-keyword">local</span> stop = <span class="hljs-literal">false</span><br>  <span class="hljs-keyword">local</span> is_en = <span class="hljs-literal">false</span><br><br>  <span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">do_subs</span><span class="hljs-params">(str)</span></span><br>  <span class="hljs-keyword">end</span><br><br>  div.content = div.content:walk&#123; Str = do_subs, &#125;<br><br>  <span class="hljs-keyword">return</span> div<br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure><p><code>do_subs</code> 是 do substitution 的缩写，实现替换。定义在ref_div 这个函数里边，以便使用上边的两个标志。<code>ref_div</code>处理一篇文献只需要替换一次“等”，所以设置一个标识位 <code>stop</code>表示替换停止。只要替换停止，函数直接返回不再进行替换。<code>is_en</code>判断是不是英文文献，如果是则替换。替换结束后需要把值返回给div.content，然后再返回 div。</p><p>最后编写 do_subs 函数，如下：</p><figure class="highlight lua"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">do_subs</span><span class="hljs-params">(str)</span></span><br>  <span class="hljs-keyword">if</span> stop <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">end</span><br><br>    <span class="hljs-comment">---@type string</span><br>    <span class="hljs-keyword">local</span> text = str.text<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> is_en <span class="hljs-keyword">then</span><br>      <span class="hljs-keyword">if</span> text:<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;%a+&#x27;</span>) <span class="hljs-keyword">then</span> is_en = <span class="hljs-literal">true</span><br>      <span class="hljs-keyword">elseif</span> text:<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;等.&#x27;</span>) <span class="hljs-keyword">then</span> stop = <span class="hljs-literal">true</span> <span class="hljs-keyword">end</span><br>      <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">local</span> times<br>    text, times = text:<span class="hljs-built_in">gsub</span>(<span class="hljs-string">&#x27;等&#x27;</span>, <span class="hljs-string">&#x27;et al&#x27;</span>)<br>    <span class="hljs-keyword">if</span> times &gt;= <span class="hljs-number">1</span> <span class="hljs-keyword">then</span><br>      str.text = text<br>      stop = <span class="hljs-literal">true</span><br>      <span class="hljs-keyword">return</span> str<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure><ol type="1"><li><p>首先判断是不是停止替换，如果是，直接返回；如果不是，则进行后边的操作。</p></li><li><p>获取 str 里的字符串，字符串保存在 text 里——可通过 Pandoc文档查看。判断是不是英文文献，刚开始我们设置不是英文文献，所以它就进行搜索。</p></li><li><p>使用正则查找英文单词，只要出现英文单词就是英文文献。正则用<code>%a+</code> 来表示至少一个字母，是英文文献就把 <code>is_en</code>设置为<code>true</code>。如果找不到英文单词，不一定不是英文文献，例如可能是<code>[1]</code> 这类的标号。因此再判断一下有没有出现 <code>等.</code>这个中文字符。“等”只出现在中文和英文文献里，前面找不到英文单词，现在又出现“等”，那就铁定是中文文献，所以设置<code>stop</code>，不需要白费功夫替换中文，节省点时间。如果还是没有找到“等”，就直接返回，什么也不要设置。</p></li><li><p>如果是英文文献，使用 <code>gsub</code>进行替换。返回值分别是替换后的字符和替换次数。替换次数大于等于一说明至少替换了一次，这时可以停止替换，一篇文献不可能出现两次“等”，同时将替换后的字符替换原来的字符并返回。</p></li></ol><p>经过以上四步，文献就替换完成了。验证一下：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221121172624.png"alt="替换成功" /></p><p>大功告成！</p><h3 id="重新优化">重新优化</h3><p>查看 <ahref="https://pandoc.org/lua-filters.html#module-pandoc.utils">文档</a>发现 Pandoc 提供一个 <code>pandoc.utils.citeproc</code>函数进行参考文献解析。我们可以应用到自己的代码中，于是代码变成：</p><figure class="highlight lua"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ref_div</span><span class="hljs-params">(div)</span></span><br>  <span class="hljs-keyword">local</span> stop = <span class="hljs-literal">false</span><br>  <span class="hljs-keyword">local</span> is_en = <span class="hljs-literal">false</span><br><br>  <span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">do_subs</span><span class="hljs-params">(str)</span></span><br>    <span class="hljs-keyword">if</span> stop <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">end</span><br><br>    <span class="hljs-comment">---@type string</span><br>    <span class="hljs-keyword">local</span> text = str.text<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> is_en <span class="hljs-keyword">then</span><br>      <span class="hljs-keyword">if</span> text:<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;%a+&#x27;</span>) <span class="hljs-keyword">then</span> is_en = <span class="hljs-literal">true</span><br>      <span class="hljs-keyword">elseif</span> text:<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;等.&#x27;</span>) <span class="hljs-keyword">then</span> stop = <span class="hljs-literal">true</span> <span class="hljs-keyword">end</span><br>      <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">local</span> times<br>    text, times = text:<span class="hljs-built_in">gsub</span>(<span class="hljs-string">&#x27;等&#x27;</span>, <span class="hljs-string">&#x27;et al&#x27;</span>)<br>    <span class="hljs-keyword">if</span> times &gt;= <span class="hljs-number">1</span> <span class="hljs-keyword">then</span><br>      str.text = text<br>      stop = <span class="hljs-literal">true</span><br>      <span class="hljs-keyword">return</span> str<br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">end</span><br><br>  div.content = div.content:walk&#123; Str = do_subs, &#125;<br><br>  <span class="hljs-keyword">return</span> div<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Pandoc</span><span class="hljs-params">(doc)</span></span><br>  <span class="hljs-keyword">return</span> pandoc.utils.citeproc(doc):walk&#123;<br>    Div = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(div)</span></span><br>      <span class="hljs-comment">-- 查找 refs Div</span><br>      <span class="hljs-keyword">if</span> (div.identifier <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;&#x27;</span>):<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;refs&#x27;</span>) <span class="hljs-keyword">then</span><br>        div.content = div.content:walk&#123; Div = ref_div, &#125;<br>        <span class="hljs-keyword">return</span> div<br>      <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span>,<br>  &#125;<br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure><p>HTML.yaml 改为</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221121173048.png"alt="不需要 citeproc 了" /></p><p>因为在自己的代码中调用了 citeproc，所以不需要在 HTML.yaml中调用。同理 docx.yaml 也需要改：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221121173211.png"alt="docx.yaml" /></p><p>至此，我们写了一个 Lua 脚本用于修改文献。这从根本改变了 Pandoc的输出，因此即使输出文件是 PDF也是正确的。这种方法算比较完善的方法了。好煎熬。</p><h1 id="后语">后语</h1><p>Pandoc是一个强大的工具。然而这个世界没有什么是完美的，它也有无法满足需求的那天，不过我们可以通过自己的方式去改变它。从最早的正则表达式进行修改到后来直接调用Pandoc API(Application programminginterface)，就像一个探索的过程，感觉解决问题后总有莫名的成就感，哈哈。</p>]]></content>
    
    
    <categories>
      
      <category>Pandoc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
      <tag>CSL</tag>
      
      <tag>Pandoc Filter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pandoc: 从 Markdown 到其他格式</title>
    <link href="/2022/11/20/Pandoc-%E4%BB%8E-Markdown-%E5%88%B0%E5%85%B6%E4%BB%96%E6%A0%BC%E5%BC%8F/"/>
    <url>/2022/11/20/Pandoc-%E4%BB%8E-Markdown-%E5%88%B0%E5%85%B6%E4%BB%96%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p><a href="https://markdown.com.cn/">Markdown</a>是一种轻量级的标记语言，可以在纯文本文档中添加格式化元素。Markdown最大的特点就是专注于文字，而且因为纯文本格式，可以纳入版本管理。日常使用的DOCX格式是二进制格式，没法进行版本管理。纯文本意味着只要是一个编辑器便可以打开并对Markdown 进行编辑和查看。</p><blockquote><p>二进制无法进行版本管理指的是，无法查看版本之间的区别，并非直接加入版本管理。</p></blockquote><p>写作的时候，可以先使用 Markdown进行写作，然后转换成其他需要的格式，实现一个文件满足多种格式，避免一点点修改原格式。转换格式必不可少<a href="https://Pandoc.org">Pandoc</a>，一款支持多格式转换的工具。现在很多的 Markdown 编辑器基本依赖的就是Pandoc。了解如何使用 Pandoc 可以控制自己的 Markdown输出格式，更随心所欲。之前自己使用 <ahref="https://Zettlr.com">Zettlr</a>，Zettlr 帮解决了大部分的 Pandoc问题，所以没有太在意 Pandoc。现在从 Zettlr 脱离出来，开始探究 Pandoc的使用。由此，今天就是要对 Pandoc 做一个介绍，主要针对的是如何配合Markdown 转化成 DOCX 格式和 HTML格式。前者一般是学生必须的格式，所以必须得介绍；后者是用 Markdown写作时的日常预览。</p><h1 id="pandoc-安装">Pandoc 安装</h1><p><a href="https://Pandoc.org">Pandoc</a>被称作文件格式转换的瑞士军刀，非常锐利简便，如果对细节要求不高，一般来说一行命令就可以完成许多格式之间的转换。介绍过Markdown 的，基本都会说到 Pandoc，似乎这两者便是天生的一对。</p><p>Pandoc是一个命令行工具，所以下载、安装之后是无法打开图形界面的，甚至看不到命令行界面。<ahref="https://pandoc.org/installing.html">官网</a>有介绍如何进行安装，不过我更喜欢在 <ahref="https://github.com/jgm/pandoc/releases/latest">GitHub</a>上直接下载。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120095003.png"alt="GitHub 上最新的 Pandoc 对应各个系统的软件包" /></p><p>安装完之后需要进行环境变量的设置，方便在命令行打开。如果使用官网推荐的方式进行安装，即使用包管理器安装，一般在命令行上可以直接运行，只需要打开命令行即可。在Linux 和 MacOS上可以找一个叫做终端(Terminal)的软件，点击即可进入命令行模式；在 Windows系统上则可选择 CMD 或者 Powershell。Pandoc 导出 DOCX 文件格式使用Powershell 有毛病，会出现乱码，所以推荐使用 CMD。因此 Windows系统可以打开搜索找到叫做 <code>命令行</code> 的软件，打开即可。</p><p>打开命令行之后在命令行上输入 <code>pandoc --version</code> (Windows系统使用的 Pandoc 命令是<code>pandoc.exe --version</code>，后面所有指令在 Windows 上都写作<code>pandoc.exe</code> 而非<code>pandoc</code>)出现类似以下的界面则表示没问题：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120100023.png"alt="Pandoc 安装成功" /></p><h2 id="环境变量配置">环境变量配置</h2><p>如果得到的提示是 <code>某某命令找不到(Not Found)</code> 或者<code>未知命令</code> 这类错误，那说明环境没有配好，比如手动到 GitHub下载。如果是手动下载，下载后的包需要解压缩(zip,tar.gz)，解压之后放到指定的地方，然后进行环境变量的配置。</p><h3 id="linux-配置">Linux 配置</h3><p>在 Linux 上可以放到 <code>~/.local/bin/</code>文件夹里面。首先打开命令行，输入 <code>ls ~/.local/bin</code>查看路径是否存在。如果提示:</p><blockquote><p>命令行中需要输入的命令会使用 <code>$</code>标注起来，没有其他说明默认非 <code>$</code>开头的都是命令的输出结果。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">ls</span> ~/.local/bin<br><span class="hljs-built_in">ls</span>: cannot access <span class="hljs-string">&#x27;/home/chunshuyumao/.local/bin&#x27;</span>: No such file or directory<br></code></pre></div></td></tr></table></figure><p>类似的错误提示，说明你的路径下没有这些文件夹。这时候可以输入<code>mkdir -p ~/.local/bin</code>，直接创建多级文件夹。找到自己下载的Pandoc 的压缩包，一般是 <code>tar.gz</code> 结尾。然后 <code>ls</code>确实有这个文件，输入 <code>tar</code> 指令进行解压。如下:</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">ls</span><br>Desktop    Downloads   Music          Pictures  Templates  Zotero<br>Documents  miniconda3  pandoc.tar.gz  Public    Videos<br>$ tar -zxvf pandoc.tar.gz -C ~/.local/bin<br>pandoc<br></code></pre></div></td></tr></table></figure><p>其中 <code>-C</code> 表示解压的位置。在自己的命令行配置文件<code>.bashrc</code> 中写下 <code>PATH=$HOME/.local/bin:$PATH</code>，关闭命令行，重新打开试试 <code>pandoc --version</code>。</p><blockquote><p>如果使用的其他的 Shell，例如 Zsh、Ksh 等，就需要在特定的配置文件<code>.zshrc</code> 和 <code>.kshrc</code> 进行配置。</p></blockquote><p>如果进行这些配置之后还是出现错误，那请重头开始。</p><h3 id="windows-配置">Windows 配置</h3><p>如果是 Windows，直接解压放到任何一个目录，比如放到<code>D:\Applications\Pandoc</code> 文件夹。打开 <code>系统属性</code>界面，可以使用 Windows 自带的搜索直接搜 <code>系统属性</code>几个大字。打开之后选择<code>高级-&gt;环境变量-&gt;系统变量-&gt;Path(或者PATH)</code> ，双击<code>Path</code> 选择新建，输入自己的 Pandoc放到的位置，选择确定即可。</p><h1 id="pandoc-使用">Pandoc 使用</h1><p>安装好 Pandoc 之后就可以进行简单的使用了，接下来我会使用 Linux进行演示，但是所有操作在 Windows 的 CMD 上一样适用。</p><p>首先创建一个 Markdown 文件作为演示，文件拓展名是<code>.md</code>。以下是用于演示的 Markdown 文件的内容：</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># Markdown 语法</span><br><br><span class="hljs-emphasis">*拉丁文斜体*</span> 正字<br><br><span class="hljs-strong">**着重加粗**</span> 无所谓<br><br><span class="hljs-strong">**<span class="hljs-emphasis">*拉丁文斜体加粗*</span>**</span> 无所谓的正字<br><br><span class="hljs-quote">&gt;</span><br><span class="hljs-quote">&gt; 子曰：我没说过</span><br><span class="hljs-quote">&gt;</span><br><span class="hljs-quote"></span><br><span class="hljs-quote">[<span class="hljs-string">Markdown</span>](<span class="hljs-link">https://markdown.com.cm</span>) 网址</span><br><br>![<span class="hljs-string">高清大图</span>](<span class="hljs-link">https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120110320.png</span>)<br><br>|姓名|学号|年龄|<br>|:----:|:----:|:----:|<br>|张三|001|18|<br>|李四|003|17|<br>|王五|004|18|<br>: 花名单<br><br><span class="hljs-section">## 二级标题</span><br><br></code></pre></div></td></tr></table></figure><p>打开命令行，确认路径下有我们的 Markdown文件。然后进行转化。转化时输出文件用 <code>-o outout.format</code>表示，<code>-o</code> 是 <code>--output</code> 的缩写。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">ls</span><br>test.md<br>$ pandoc test.md -o test.html<br>$ pandoc test.md -o test.docx<br>$ <span class="hljs-built_in">ls</span><br>test.md test.html test.docx<br></code></pre></div></td></tr></table></figure><blockquote><p>完整写法应该是<code>pandoc --from markdown --to html test.md -o test.html</code>.如果不指定类型，Pandoc 会通过扩展名自动判断。转换到 DOCX的完整写法是<code>pandoc --from markdown --to docx test.md -o test.html</code>。也可以使用更短的命令<code>pandoc -f markdown -t html test.md -o test.html</code></p></blockquote><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120111452.gif"alt="动图演示" /></p><p>使用 WPS 或者 Office 打开 DOCX 文件查看，效果好像还行。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120111820.png"alt="Markdown 转换成的 DOCX 文件" /></p><p>同理使用 浏览器打开 HTML文件。平心而论，很丑，丑的不行，根本看不下去。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120112104.png"alt="Markdown 转换成的 HTML 文件" /></p><p>这不全怪 Pandoc，是我们的操作有问题。因为有些格式不止由一个 Markdown文件生成，而是多个文件组合。如果转换成 HTML 只使用一个文件，我们需要告诉Pandoc 我们只需要一个文件，所以转换成 HTML 的正确操作应该是：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ pandoc -s test.md -o test.html<br></code></pre></div></td></tr></table></figure><p>命令中的 <code>-s</code> 是 <code>--standalone</code>的缩写，表示单文件模式，不需要多个源文件组合。再看看转换之后的文件：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120112602.png"alt="使用单文件模式转换成 HTML 格式" /></p><p>这次的转换就很好看了。我开了暗夜模式所以网页看起来是黑的，其实是白的。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120112732.png"alt="正常情况下的预览" /></p><p>转换成 DOCX 的时候也需要单文件模式，但是 Pandoc 默认加上了。默认的HTML 模板其实蛮好看，没啥需要改的。仔细看，转换单文件模式的 HTML时，命令行还出现了这样的提示：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ pandoc -s test.md -o test.html<br>[WARNING] This document format requires a nonempty &lt;title&gt; element.<br>  Defaulting to <span class="hljs-string">&#x27;test&#x27;</span> as the title.<br>    To specify a title, use <span class="hljs-string">&#x27;title&#x27;</span> <span class="hljs-keyword">in</span> metadata or --metadata title=<span class="hljs-string">&quot;...&quot;</span>.<br></code></pre></div></td></tr></table></figure><p>这提示我们可以给文件加一个标题，语法是<code>--metadata title="标题"</code>。可以用 <code>-M</code> 代替冗长的<code>--metadata</code> 命令，在命令行加。我们试试：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ pandoc -s -M title=<span class="hljs-string">&quot;Convert from Markdown to HTML&quot;</span> test.md -o test.html<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120113424.png"alt="添加标题" /></p><p>可以看到，渲染的网页给我们添加了标题:</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120113457.png"alt="网页添加标题" /></p><p>同理转换成 DOCX 看看：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120113702.png"alt="DOCX 添加标题" /></p><p>只是使用基本的语法到这里就差不多了，要使用其他功能就需要继续往下看。</p><h1 id="pandoc-进阶">Pandoc 进阶</h1><p>进阶部分我们会介绍如何使用 Pandoc进行文献引用、链接，自动给标题标号、分章节，修改链接格式，甚至图片、表格、公式交叉引用、导出格式等等，也会使用到其他的工具，到时会细说。</p><h2 id="文献引用">文献引用</h2><p>这里的引用(citation)指的是写论文时的参考文献，与 <code>&gt;</code>代表的直接引用名人名言不同。可以在官网上看到有关引用的介绍。有什么问题最好也是官网查看，到处在网上搜属实是下下策。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120124611.png"alt="官网上对引用的介绍" /></p><p>从官网上了解到，想要引用需要：</p><ol type="1"><li>包含引用的文件，比如我们的论文 Markdown 格式。</li><li>参考文献(bibliography)源文件，可以是参考文献文件，也可以使用<code>-M</code> 标注。用 <code>-M</code>标注太低级了，后面的演示会直接使用 <ahref="https://www.Zotero.org">Zotero</a> 导出的文献库。</li><li>CSL 引用格式文件。这是可选的。</li><li>使用 <code>--citeproc</code> 进行参考文献的引用处理。</li></ol><p>参考文献格式有多个类别，可查看下表。Pandoc处理参考文献时会把其他格式转换成 JSON ，所以为了简便可以直接使用 JSON格式，少了中间商。那就准备文献库吧。</p><table><caption>参考文献格式</caption><thead><tr class="header"><th style="text-align: center;">格式</th><th style="text-align: center;">扩展名</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">BibLaTex</td><td style="text-align: center;">.bib</td></tr><tr class="even"><td style="text-align: center;">BibTex</td><td style="text-align: center;">.bibtex</td></tr><tr class="odd"><td style="text-align: center;">CSL JSON</td><td style="text-align: center;">.json</td></tr><tr class="even"><td style="text-align: center;">CSL YAML</td><td style="text-align: center;">.yaml</td></tr><tr class="odd"><td style="text-align: center;">RIS</td><td style="text-align: center;">.ris</td></tr></tbody></table><h3 id="从-zotero-中导出文献库">从 Zotero 中导出文献库</h3><p>导出文献库需要下载 Zotero 作为文献管理器，然后需要的文献放到 Zotero中。Zotero 是一个大命题，这里不会过多介绍，如有兴趣可以看看之前写的文章<a href="/2022/03/15/Zotero%E6%96%87%E7%8C%AE%E7%AE%A1%E7%90%86%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/" title="Zotero文献管理插件安装">Zotero文献管理插件安装</a>。安装 <ahref="https://retorque.re/zotero-better-bibtex/">Better BibTex forZotero</a> 插件方便使用<code>citationkey</code>。<code>citationkey</code> 是 Pandoc实现引用的关键东东，就像 DOI(digital object uniqueidentifier，数字对象唯一标识符) 一样，每一篇文献都有一个对应的<code>citationkey</code>，独一无二。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120130813.png"alt="citationkey" /></p><p>安装好插件之后就要导出文献库。Zotero 里打开<code>文件(File) -&gt; 导出库(Export Library)</code>，选择<code>Better CSL JSON</code> 格式，然后勾选<code>保持更新(Keep updated)</code>，<code>OK</code>即可。如果没有这个格式，建议看看是不是没有安装 Better BibTex这个插件。保存到一个指定目录，我保存到<code>/home/chunshuyumao/Documents/Pandoc/ZoteroLibrary.json</code>，后面要用到。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202211161958383.png"alt="选择导出文献库" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202211162000373.png"alt="选择格式，保持更新" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202211162011533.png"alt="保存到某个目录" /></p><p>文献库是一个 JSON格式的文件，可以打开瞧瞧。下面展示的是文件中的信息，截了一篇文献的信息。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202211162045423.png"alt="一篇文献的引用信息" /></p><p>Pandoc 识别引用的语法是 <code>[@citationkey]</code>。意思是在Markdown 文件中引用一篇文献需要这样写：</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">这是文章内容，巴拉巴拉巴拉。研究[@AlfredRodrigo-1702]认为巴拉巴拉巴拉。<br></code></pre></div></td></tr></table></figure><p>Pandoc 渲染之后自动标号，而且在后面生成了参考文献。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202211162058293.png"alt="Pandoc 渲染后" /></p><p>需要注意的是，如果没有给 Pandoc 指定文献格式(Citation Stylelanguage，CSL) ，Pandoc 默认使用 Chicago Manual of Style。格式可以到Zotero中下载。一般来说，国内使用的是国标(GB)，至于哪个版本就看需求了，我一般用2005 年的 numeric. 下载之后的 CSL 文件在 Zotero 安装位置下的 styles文件夹。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202211162108573.png"alt="下载格式" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202211162111253.png"alt="CSL 位置" /></p><p>复制想要用的 CSL 文件到某个位置，这里复制到和文献库同一位置，即<code>/home/chunshuyumao/Documents/Pandoc</code>。</p><h3 id="使用引用">使用引用</h3><p>准备好文献库，在我们的 Markdown 文件中添加以下行：</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section">## 二级标题</span><br><br>这里即将引用一篇文献[@DefiningCellTypes]。是的没错。<br><br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120133037.png"alt="全文如上" /></p><p>Pandoc 将 Markdown 转换到 HTML 并使用引用，除了文献库和 CSL文件，还需要加上 <code>--citeproc</code> 进行处理，所以语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ pandoc -s -M title=<span class="hljs-string">&quot;Convert from Markdown to HTML&quot;</span> --citeproc --bibliography /path/to/lib.json --csl /path/to/style.csl test.md -o test.html<br></code></pre></div></td></tr></table></figure><p>上面的命令行太长，我们可以使用换行，让它看起来更正常一点：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ pandoc -s \<br>  -M title=<span class="hljs-string">&quot;Convert from Markdown to HTML&quot;</span> \<br>  --citeproc \<br>  --bibliography /path/to/lib.json \<br>  --csl /path/to/style.csl \<br>  test.md \<br>  -o test.html<br></code></pre></div></td></tr></table></figure><p>这样看起来舒服多了。同理，把 <code>test.html</code> 换成<code>test.docx</code> 就可以生成 DOCX 格式了。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120133530.png"alt="命令行转换" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120133641.png"alt="HTML 格式效果" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120133758.png"alt="DOCX 格式效果" /></p><p>初步完成了引用，写论文一般要求引用可以点击跳转。这个也可以做到，只需要添加<code>-M link-citations=true</code>。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ pandoc -s \<br>  -M title=<span class="hljs-string">&quot;Convert from Markdown to HTML&quot;</span> \<br>  -M link-citations=<span class="hljs-literal">true</span> \<br>  --citeproc \<br>  --bibliography /path/to/lib.json \<br>  --csl /path/to/style.csl \<br>  test.md \<br>  -o test.html<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120134937.gif"alt="动图演示点击跳转" /></p><p>这里有个毛病，点击跳转的 DOCX 文件在 WPS Office 中没办法跳转，但在Microsoft Office 中没问题。可能使用的 Linux 版 WPS有问题，因为手机版也可以跳转。</p><h2 id="自动给标题标号">自动给标题标号</h2><p>处理完文献我们希望，导出的 HTML 和 DOCX的标题自动给标题标号，这种东西没必要手动操作，直接让 Pandoc处理。查看官网，想让 Pandoc 标号只需要添加一行命令 <code>-N</code> 或者<code>--number-sections</code>。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120135849.png"alt="自动标号" /></p><p>好家伙，叠 Buff 开始：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ pandoc -s \<br>  -M title=<span class="hljs-string">&quot;Convert from Markdown to HTML&quot;</span> \<br>  -M link-citations=<span class="hljs-literal">true</span> \<br>  -N \<br>  --citeproc \<br>  --bibliography /path/to/lib.json \<br>  --csl /path/to/style.csl \<br>  test.md \<br>  -o test.html<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120140103.png"alt="自动标号成功" /></p><p>后面我会用 HTML 演示，DOCX 和 HTML 差不多，有区别时我才会单独拎出DOCX，否则操作共享。</p><h2 id="交叉引用">交叉引用</h2><p>写论文不免使用图片、公式和表格，特别是 <code>如图几</code>这类的语句。如果原本你有三张图，并且已经标好号了，论文内有五个<code>如图几</code>。不想你又在开头添加一张图片。这时候你需要更改所有的<code>如图几</code>，因为在开头添加图片就把原来的标号顺序全都弄错了。为了避免这种情况，我们一般选择交叉引用。坏消息是Markdown 和 Pandoc 都不支持交叉引用，好消息是有一个 Pandoc插件可以支持。这个插件就是 <ahref="https://github.com/lierdakil/pandoc-crossref">Pandoc-crossref</a>。</p><h3 id="下载-pandoc-crossref">下载 Pandoc-crossref</h3><p>先到 <ahref="https://github.com/lierdakil/pandoc-crossref/releases">GitHub</a>下载 Pandoc-crossref。注意下载时版本对应，看看自己的 Pandoc是什么版本，使用 <code>pandoc --version</code> 查看。我的是<code>2.19.2</code> 可以直接下载最新的 Pandoc-crossref。不同版本编译的Pandoc-crossref 一般不能交叉使用。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120142401.png"alt="Pandoc-crossref 下载" /></p><p>下载完成后建议和 Pandoc放一起方便管理。如果使用的是不同的目录，比如你不愿把它们放到一起，那请记住位置，并为Pandoc-crossref 设置环境变量，否则下面使用 Pandoc-crossref需要带上全路径。</p><blockquote><p>全路径指的是，把文件的绝对路径写上。配置环境变量本质上就是免了写全路径。</p></blockquote><h3 id="使用-pandoc-crossref">使用 Pandoc-crossref</h3><p>可以查看 Pandoc-crossref 的 <ahref="https://lierdakil.github.io/pandoc-crossref/">用法</a>。这里我会说明基本用法。首先是最常用的图片引用，语法如下：</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">![<span class="hljs-string">图片注释</span>](<span class="hljs-link">图片路径</span>)&#123;#fig:id&#125;<br></code></pre></div></td></tr></table></figure><p>正文中使用引用只需用 <code>[@fig:id]</code>即可。格式和参考文献的引用一样，参考文献由 <code>--citeproc</code>处理，为了避免 Pandoc 把交叉引用当作参考文献解析，我们需要在使用<code>--citeproc</code> 之前使用 pandoc-crossref, 命令行语法为<code>--filter pandoc-crossref</code>。<code>id</code>是一个拉丁字母的组合，不可使用中文、数字和下标等等。如下为图示:</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120143501.png"alt="图片引用" /></p><p>注意，一定要在使用 <code>--citeproc</code> 之前使用pandoc-crossref。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ pandoc -s \<br>  -M title=<span class="hljs-string">&quot;Convert from Markdown to HTML&quot;</span> \<br>  -M link-citations=<span class="hljs-literal">true</span> \<br>  -N \<br>  --filter pandoc-crossref \<br>  --citeproc \<br>  --bibliography /path/to/lib.json \<br>  --csl /path/to/style.csl \<br>  test.md \<br>  -o test.html<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120143827.png"alt="导出效果" /></p><p>Pandoc 渲染引用的图片标号用 <code>fig.</code>代替，并在图片注释前添加 <code>Figure.</code>。中文写作想使用<code>图</code> 而不是 <code>fig</code> 怎么办？添加<code>-M figPrefix="图"</code>。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ pandoc -s \<br>  -M title=<span class="hljs-string">&quot;Convert from Markdown to HTML&quot;</span> \<br>  -M link-citations=<span class="hljs-literal">true</span> \<br>  -N \<br>  -M figPrefix=<span class="hljs-string">&quot;图&quot;</span> \<br>  --filter pandoc-crossref \<br>  --citeproc \<br>  --bibliography /path/to/lib.json \<br>  --csl /path/to/style.csl \<br>  test.md \<br>  -o test.html<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120145040.png"alt="修改前缀" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120144908.png"alt="修改引用的前缀" /></p><p>想把图注释中的 <code>Figure</code> 也改中文？野心不小嘛，添加<code>-M figureTitle="图"</code>。同理，公式、表格的用法也一样，甚至还有章节、列表的引用，见下表：</p><div><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120145251.png" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120145517.png" /></p>Pandoc-crossref 支持的交叉引用(部分)<div><p>在 Markdown 文件中添加如下引用：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120153534.png"alt="使用交叉引用" /></p><p>命令行输入</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ pandoc -s \<br>  -M title=<span class="hljs-string">&quot;Convert from Markdown to HTML&quot;</span> \<br>  -M link-citations=<span class="hljs-literal">true</span> \<br>  -M figPrefix=<span class="hljs-string">&quot;图&quot;</span> \<br>  -M figureTitle=<span class="hljs-string">&quot;图&quot;</span> \<br>  -M tblPrefix=<span class="hljs-string">&quot;表&quot;</span> \<br>  -M tableTitle=<span class="hljs-string">&quot;表&quot;</span> \<br>  -M eqnPrefix=<span class="hljs-string">&quot;公式&quot;</span> \<br>  -N \<br>  --filter pandoc-crossref \<br>  --citeproc \<br>  --bibliography /path/to/lib.json \<br>  --csl /path/to/style.csl \<br>  test.md \<br>  -o test.html<br></code></pre></div></td></tr></table></figure><p>效果如 <code>交叉引用1</code> 和<code>交叉引用2</code>。想必有人发现不同了，图 2 的表格和图片都标上了<code>1.1</code> 表示第一章的第一张图，而图 1 没有。这是因为我加了分章节<code>-M chapters=ture</code>，这样图片和公式可以按照章节(其实就是标题)来划分，且第一张图的数学公式没有渲染。这个不急，后面会说怎么渲染数学公式。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120152620.png"alt="交叉引用1" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120152413.png"alt="交叉引用2" /></p><p>至此，交叉引用已经完成了，该解决数学公式了。</p><h2 id="数学公式">数学公式</h2><p>Pandoc 渲染数学公式需要借助外力。Pandoc渲染数学公式需要显式指定渲染引擎。如下</p><ol type="1"><li>mathjax</li><li>mathml</li><li>webtex</li><li>katex</li><li>gladtex</li></ol><p>这几个有好有坏，看个人取舍，我一般使用MathJax，这个引擎渲染的范围广一点，使用的也比较多。至于语法，添加<code>--mathjax</code> 即可。还可以添加网址，例如<code>--mathjax=URL</code>。为什么还要有网址？因为这东东是“外力”，Pandoc不自带，它会调用内置的网址。由于这些网址都是国外的，所以很不幸可能会慢，大概率会慢，很慢。那怎么解决？其实只需下载一份JavaScript文件保存即可。当渲染的时候，提供路径到保存的引擎文件，没有借助网络进行渲染。</p><p>到 <ahref="https://sourceforge.net/projects/mathjax.mirror/">SourceForge</a>下载 MathJax 压缩包，解压之后重命名为 <code>MathJax</code>并移动到某一个文件夹，可以放到<code>/home/chunshuyumao/Documents/Pandoc/</code> 。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120155048.png"alt="SourceForge" /></p><p>放好之后使用指定位置，现在我们的命令行如下：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ pandoc -s \<br>  -M title=<span class="hljs-string">&quot;Convert from Markdown to HTML&quot;</span> \<br>  -M link-citations=<span class="hljs-literal">true</span> \<br>  -M figPrefix=<span class="hljs-string">&quot;图&quot;</span> \<br>  -M figureTitle=<span class="hljs-string">&quot;图&quot;</span> \<br>  -M tblPrefix=<span class="hljs-string">&quot;表&quot;</span> \<br>  -M tableTitle=<span class="hljs-string">&quot;表&quot;</span> \<br>  -M eqnPrefix=<span class="hljs-string">&quot;公式&quot;</span> \<br>  -N \<br>  --mathjax=/home/chunshuyumao/Documents/Pandoc/MathJax/es5/tex-mml-chtml.js \<br>  --filter pandoc-crossref \<br>  --citeproc \<br>  --bibliography /path/to/lib.json \<br>  --csl /path/to/style.csl \<br>  test.md \<br>  -o test.html<br></code></pre></div></td></tr></table></figure><p>不下载其实也可以用，就是看个人网络问题。如果不下载，就只需要加<code>--mathjax</code>。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120155705.png"alt="数学公式渲染" /></p><h2 id="论文-docx-模板">论文 DOCX 模板</h2><p>刚开始时我们就发现生成的 DOCX好像不咋地，且写论文一般有要求，例如字号、字体等，靠 Pandoc默认的模板很难满足需求，我们需要自己的模板。Pandoc 考虑到了，提供<code>reference-doc</code> 引入模板。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120160438.png"alt="reference-doc 引入 DOCX 模板" /></p><h3 id="导出-pandoc-默认模板">导出 Pandoc 默认模板</h3><p>首先导出 Pandoc 模板，它预设了很多格式，直接修改即可。使用 Windows系统需要注意，这一步的导出只能使用 CMD，不可使用Powershell，后者会出现乱码。在命令行中输入：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ pandoc --print-defatul-data-file ref.docx &gt; ref.docx<br></code></pre></div></td></tr></table></figure><p>用 WPS 或者 Office 打开，看看预设的模板如何：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120160858.png"alt="获取模板，并打开" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120161032.png"alt="打开木板预览" /></p><p>没有表格对应的模板，所以三线表需要导出成 DOCX 后再手动进行修改。修改DOCX 模板不在本篇文章的范围，所以大家最好自己去试。</p><p>修改之后的模板也放到<code>/home/chunshuyumao/Documents/Pandoc/</code>下边，待会再放个大招。</p><h3 id="使用自己的模板">使用自己的模板</h3><p>假设已修改完模板可以使用了。这个模板只有 DOCX 使用，所以导出成 HTML就不必加入了。语法是<code>--reference-doc=/path/to/template.docx</code>。下面导出我们的文档看看。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ pandoc \<br>  -M title=<span class="hljs-string">&quot;Convert from Markdown to HTML&quot;</span> \<br>  -M link-citations=<span class="hljs-literal">true</span> \<br>  -M figPrefix=<span class="hljs-string">&quot;图&quot;</span> \<br>  -M figureTitle=<span class="hljs-string">&quot;图&quot;</span> \<br>  -M tblPrefix=<span class="hljs-string">&quot;表&quot;</span> \<br>  -M tableTitle=<span class="hljs-string">&quot;表&quot;</span> \<br>  -M eqnPrefix=<span class="hljs-string">&quot;公式&quot;</span> \<br>  -N \<br>  --reference-doc=/home/chunshuyumao/Documents/Pandoc/paper.docx<br>  --mathjax=/home/chunshuyumao/Documents/Pandoc/MathJax/es5/tex-mml-chtml.js \<br>  --filter pandoc-crossref \<br>  --citeproc \<br>  --bibliography /path/to/lib.json \<br>  --csl /path/to/style.csl \<br>  test.md \<br>  -o test.docx<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120161832.png"alt="按照本业论文格式改的效果" /></p><p>大功告成！现在 Pandoc已经被驯服了。不过这还不算完善，每次要写这么长的命令，鬼才乐意。接下来就是如何优化的Pandoc 配置。</p><h2 id="优化-pandoc-配置">优化 Pandoc 配置</h2><p>优化配置还得看官网。官网说我们可以使用一个 YAML 格式配置选项和<code>metadata</code> 然后让 Pandoc 读取。YAML是什么不用担心，就是一个标记语言，是 "YAML Ain't a Markup Language"的递归缩写。这是开源世界的一种玩笑，很明显这就是一个标记语言，所以实际上它叫做"Yet Another Markup Language"。YAML可以清晰明了地展示配置。闲话少叙，直接看这是如何使用.</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120162426.png"alt="配置" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120163224.png"alt="Pandoc 配置" /></p><p>官网上有如何配置和默认的配置信息，我们只需要修改一些即可。首先祭出我们又臭又长的命令行参数：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ pandoc \<br>  -M title=<span class="hljs-string">&quot;Convert from Markdown to HTML&quot;</span> \<br>  -M link-citations=<span class="hljs-literal">true</span> \<br>  -M figPrefix=<span class="hljs-string">&quot;图&quot;</span> \<br>  -M figureTitle=<span class="hljs-string">&quot;图&quot;</span> \<br>  -M tblPrefix=<span class="hljs-string">&quot;表&quot;</span> \<br>  -M tableTitle=<span class="hljs-string">&quot;表&quot;</span> \<br>  -M eqnPrefix=<span class="hljs-string">&quot;公式&quot;</span> \<br>  -N \<br>  --reference-doc=/home/chunshuyumao/Documents/Pandoc/paper.docx<br>  --mathjax=/home/chunshuyumao/Documents/Pandoc/MathJax/es5/tex-mml-chtml.js \<br>  --filter pandoc-crossref \<br>  --citeproc \<br>  --bibliography /path/to/lib.json \<br>  --csl /path/to/style.csl \<br>  test.md \<br>  -o test.docx<br></code></pre></div></td></tr></table></figure><h3 id="metadata-yaml-文件">MetaData YAML 文件</h3><p><code>-M</code> 开头的都是 <code>metadata</code> ，所有创建一个<code>meta.yaml</code> 文件，把它们写进去，<code>#</code>开头的是注释，方便注释参数的作用。YAML使用冒号而不是等号，而且冒号之后还得有一个空格。</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># -------------------------------------------------------------</span><br><span class="hljs-comment"># Pandoc-crossref</span><br><span class="hljs-comment"># -------------------------------------------------------------</span><br><br><span class="hljs-attr">figPrefix:</span> <span class="hljs-string">&quot;图&quot;</span><br><span class="hljs-attr">figureTitle:</span> <span class="hljs-string">&quot;图&quot;</span><br><br><span class="hljs-attr">tblPrefix:</span> <span class="hljs-string">&quot;表&quot;</span><br><span class="hljs-attr">tableTitle:</span> <span class="hljs-string">&quot;表&quot;</span><br><br><span class="hljs-attr">eqnPrefix:</span> <span class="hljs-string">&quot;公式&quot;</span><br><br><span class="hljs-comment"># 支持交叉引用跳转</span><br><span class="hljs-attr">linkReference:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># -------------------------------------------------------------</span><br><span class="hljs-comment"># Division</span><br><span class="hljs-comment"># -------------------------------------------------------------</span><br><span class="hljs-attr">chapters:</span> <span class="hljs-literal">true</span><br><br><br><span class="hljs-comment"># -------------------------------------------------------------</span><br><span class="hljs-comment"># Citations</span><br><span class="hljs-comment"># -------------------------------------------------------------</span><br><span class="hljs-attr">link-citations:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment"># 不需要将参考文献做成连接</span><br><span class="hljs-attr">link-bibliography:</span> <span class="hljs-literal">false</span><br><span class="hljs-comment"># 参考文献</span><br><span class="hljs-attr">reference-section-title:</span> <span class="hljs-string">&quot;参考文献&quot;</span><br><br><span class="hljs-comment"># 这是 HTML 字体大小。默认字体太大了，改小一点，15、16 均可</span><br><span class="hljs-attr">fontsize:</span> <span class="hljs-string">14px</span><br></code></pre></div></td></tr></table></figure><p>这里多了之前没有讲的东西。首先是<code>linkReference</code>，用于支持交叉引用跳转，默认没有开启，需要配置。<code>link-bibliography</code>不让 Pandoc 给参考文献加上链接。这个说起来比较抽象，图片伺候：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120164411.png"alt="加链接" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120164244.png"alt="不加链接" /></p><p>最后一行是参考文献标题大名。有人可能发现了，<code>title</code>没有出现在 meta.yaml 里。确实，因为没有必要，除了将<code>metadata</code> 写到 meta.yaml 外还可在 Markdown文件中直接写，使用 <code>---</code> 隔开即可，这叫做<code>front-matter</code>(标头)，比如我们的原文件：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120171326.png"alt="标头" /></p><p>除了这些，所有的 <code>-M</code> 的属性都可以写到 front-matter中。</p><h3 id="options-yaml-文件">Options YAML 文件</h3><p>写完 <code>metadata</code> 文件来看选项文件。命令行中所有非<code>-M</code>都是选项。注意，之前转换格式时少了一点，就是显式指定格式。实际上我们是从Markdown 格式 转成 HTML 或者 DOCX的。这次为了规范，我们分别为两者指定各自的文件，先写 DOCX 的 YAML文件：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># 指定从 Markdown 格式开始转换</span><br><span class="hljs-attr">reader:</span> <span class="hljs-string">markdown</span><br><span class="hljs-comment"># 指定转换成的格式是 DOCX</span><br><span class="hljs-attr">writer:</span> <span class="hljs-string">docx</span><br><br><span class="hljs-comment"># -------------------------------------------------------------</span><br><span class="hljs-comment"># Reader Options</span><br><span class="hljs-comment"># -------------------------------------------------------------</span><br><span class="hljs-comment"># 设置 Tab 为 4 个空格</span><br><span class="hljs-attr">tab-stop:</span> <span class="hljs-number">4</span><br><span class="hljs-attr">preserve-tabs:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-comment"># 使用 pandoc-crossref 作为交叉引用</span><br><span class="hljs-attr">filters:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">pandoc-crossref</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">citeproc</span><br><br><span class="hljs-comment"># 指定 metadata 从 meta.yaml 中读取</span><br><span class="hljs-attr">metadata-files:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">meta.yaml</span><br><br><span class="hljs-comment"># 设置标题偏移。例如将一级标题变成三级标题，那就改成 2</span><br><span class="hljs-attr">shift-heading-level-by:</span> <span class="hljs-number">0</span><br><span class="hljs-comment"># 设置图片默认扩展名。如果自己太懒连格式都没写，那就让 Pandoc</span><br><span class="hljs-comment"># 自动帮你添加 —— 那你是真的懒</span><br><span class="hljs-attr">default-image-extension:</span> <span class="hljs-string">.png</span><br><br><span class="hljs-comment"># -------------------------------------------------------------</span><br><span class="hljs-comment"># Writer Options</span><br><span class="hljs-comment"># -------------------------------------------------------------</span><br><span class="hljs-comment"># 这是设置默认结束符，Windows 可以设置为 nl</span><br><span class="hljs-attr">eol:</span> <span class="hljs-string">lf</span><br><span class="hljs-comment"># 是否自动换行。如果一行太长了，Pandoc 可以帮助自动换行</span><br><span class="hljs-attr">wrap:</span> <span class="hljs-string">auto</span><br><br><span class="hljs-comment"># 是否生成目录。</span><br><span class="hljs-attr">toc:</span> <span class="hljs-literal">false</span><br><span class="hljs-comment"># 生成目录的话，生成多深的目录，这里只需要生成二级目录就可以了</span><br><span class="hljs-attr">toc-depth:</span> <span class="hljs-number">2</span><br><br><span class="hljs-comment"># 是否是单文件模式，DOCX 可以省略，但是 HTML 最好显式写下来</span><br><span class="hljs-attr">standalone:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment"># 是否去掉注释。这指的是写 Markdown 时使用的 HTML 类型的格式，例</span><br><span class="hljs-comment"># 如 &lt;!--这是注释，没必要保留到正文--&gt;</span><br><span class="hljs-attr">strip-comments:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># Fore reference-doc, metadata-files</span><br><span class="hljs-comment"># 设置查找 meta.yaml 和 模板文件的路径，设置之后就不用写很长的路</span><br><span class="hljs-comment"># 径了，不信看看上面的 meta.yaml 压根就不用写路径，这里已经设置了</span><br><span class="hljs-attr">data-dir:</span> <span class="hljs-string">/home/chunshuyumao/Documents/Pandoc</span><br><br><span class="hljs-comment"># For bibliography, and file resource</span><br><span class="hljs-comment"># 查找文献库和图片的路径</span><br><span class="hljs-attr">resource-path:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">.</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">/home/chunshuyumao/Documents/Pandoc</span><br><br><br><span class="hljs-comment"># -------------------------------------------------------------</span><br><span class="hljs-comment"># Sepecific writer</span><br><span class="hljs-comment"># -------------------------------------------------------------</span><br><span class="hljs-attr">reference-links:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># document | block | section</span><br><span class="hljs-attr">reference-location:</span> <span class="hljs-string">document</span><br><br><span class="hljs-comment"># default | chapter | section | part</span><br><span class="hljs-attr">top-level-division:</span> <span class="hljs-string">chapter</span><br><br><span class="hljs-attr">number-offset:</span> []<br><span class="hljs-comment"># 是否自动分章节</span><br><span class="hljs-attr">number-sections:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment"># 实际上，模板找不到，所以这里还是需要写全路径</span><br><span class="hljs-attr">reference-doc:</span> <span class="hljs-string">/home/chunshuyumao/Documents/Pandoc/paper.docx</span><br><br><span class="hljs-comment"># -------------------------------------------------------------</span><br><span class="hljs-comment"># Citation options</span><br><span class="hljs-comment"># -------------------------------------------------------------</span><br><span class="hljs-comment"># 文献库，这里就不用写全路径了</span><br><span class="hljs-attr">bibliography:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">ZoteroLibrary.json</span><br><span class="hljs-attr">csl:</span> <span class="hljs-string">csl/chinese-gb7714-2005-numeric.csl</span><br><br></code></pre></div></td></tr></table></figure><p>同理，HTML 的 YAML 文件</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">reader:</span> <span class="hljs-string">markdown</span><br><span class="hljs-attr">writer:</span> <span class="hljs-string">html</span><br><br><span class="hljs-comment"># -------------------------------------------------------------</span><br><span class="hljs-comment"># Reader Options</span><br><span class="hljs-comment"># -------------------------------------------------------------</span><br><br><span class="hljs-attr">tab-stop:</span> <span class="hljs-number">4</span><br><span class="hljs-attr">preserve-tabs:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-attr">filters:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">pandoc-crossref</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">citeproc</span><br><br><span class="hljs-attr">metadata-files:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">meta.yml</span><br><br><span class="hljs-attr">shift-heading-level-by:</span> <span class="hljs-number">0</span><br><span class="hljs-attr">default-image-extension:</span> <span class="hljs-string">.png</span><br><br><span class="hljs-comment"># -------------------------------------------------------------</span><br><span class="hljs-comment"># Writer Options</span><br><span class="hljs-comment"># -------------------------------------------------------------</span><br><br><span class="hljs-attr">eol:</span> <span class="hljs-string">lf</span><br><span class="hljs-attr">dpi:</span> <span class="hljs-number">72</span><br><span class="hljs-attr">wrap:</span> <span class="hljs-string">auto</span><br><br><span class="hljs-attr">toc:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">toc-depth:</span> <span class="hljs-number">2</span><br><br><span class="hljs-attr">strip-comments:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-attr">standalone:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment"># 这里要注意，如果为 true， 每次转换成 HTML 格式，Pandoc 都会尝试</span><br><span class="hljs-comment"># 下载 Markdown 中的图片。这种如果使用图床比较多，最好直接关了这东</span><br><span class="hljs-comment"># 东，不然转换很慢的。</span><br><span class="hljs-attr">embed-resources:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-comment"># Fore reference-doc</span><br><span class="hljs-attr">data-dir:</span> <span class="hljs-string">/home/chunshuyumao/Documents/Pandoc</span><br><br><span class="hljs-comment"># For bibliography, images</span><br><span class="hljs-attr">resource-path:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">.</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">/home/chunshuyumao/Documents/Pandoc</span><br><br><br><span class="hljs-comment"># -------------------------------------------------------------</span><br><span class="hljs-comment"># Sepecific writer</span><br><span class="hljs-comment"># -------------------------------------------------------------</span><br><br><span class="hljs-attr">reference-links:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># document | block | section</span><br><span class="hljs-attr">reference-location:</span> <span class="hljs-string">document</span><br><br><span class="hljs-comment"># default | chapter | section | part</span><br><span class="hljs-attr">top-level-division:</span> <span class="hljs-string">chapter</span><br><br><span class="hljs-attr">number-offset:</span> []<br><span class="hljs-attr">number-sections:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># 代码高亮的主题</span><br><span class="hljs-attr">highlight-style:</span> <span class="hljs-string">pygments</span><br><span class="hljs-comment"># 数学公式引擎</span><br><span class="hljs-attr">html-math-method:</span><br>    <span class="hljs-attr">method:</span> <span class="hljs-string">mathjax</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">/home/chunshuyumao/Documents/Pandoc/MathJax/es5/tex-mml-chtml.js</span><br><br><br><span class="hljs-comment"># -------------------------------------------------------------</span><br><span class="hljs-comment"># Citation options</span><br><span class="hljs-comment"># -------------------------------------------------------------</span><br><br><span class="hljs-attr">bibliography:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">ZoteroLibrary.json</span><br><span class="hljs-attr">csl:</span> <span class="hljs-string">cls/chinese-gb7714-2005-numeric.csl</span><br></code></pre></div></td></tr></table></figure><p>把这三个文件放到 <code>/home/chunshuyumao/Documents/Pandoc/</code>下，形成这样的结构：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120170716.png"alt="文件结构" /></p><p>划红线的表示用不到的，有些只是我写的脚本。<code>paper.docx</code> 和<code>ref.docx</code> 是 DOCX 模板。做好后如何用？</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ pandoc -d ~/Documents/Pandoc/defaults/docx.yaml test.md -o test.docx<br></code></pre></div></td></tr></table></figure><p>即可。这便是为啥建议所有东西放一个文件夹，多简单呀。至此，基本配置已经做完。但问题远远没有结束，虽然展示时没有这个毛病，但是写论文一定会碰到，那就是CSL 文件导出的文献其实是有问题的。举个例子：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120172424.png"alt="这就是毛病" /></p><p>作者多于三个就会使用“等”替代，但是 CSL 文件只能使用一种语言，Pandoc的分析可能也一样，原本英文文献应该出现“etal”，但中文本地化的前提下它只能使用“等”。这个问题不仅 Pandoc 有，Zotero也有，主要问题出在使用 Zotero 的 CSL 文件。不用 Zotero 的 CSL能不能避免这种情况？答案是：不知道。CSL 文件用的是 XML(Extensible MarkupLanguage,可拓展标记语言)，这种标记语言简直是魔鬼，反正我是没看懂，遑论去改了。</p><p>这也不是没救，无法改变 CSL文件，可以上网找别人改过的。不过我试了很多发现也没用，很可能 Pandoc也有问题。最后曲线救国，只能写 Pandoc 的 filter进行修改。这也是为啥我的文件夹有几个脚本。前面大家看到了，Pandoc-crossref就是一个 Pandoc 的 filter。Pandoc filter 支持 Lua语言，拓展不难。只是这一篇已经够长了，只能在下一篇讲如何将 Pandoc渲染出的参考文献改为正常的词。</p><h1 id="后语">后语</h1><p>隔了大半年才再写一篇其实也是懒。期间我学五笔输入法，为了适应五笔强迫使用，结果打字速度不行，没法写文章。且最近几个月好像也不得空，期间还换了电脑系统，从Manjaro 换成了 Arch Linux。中途遇到 Zettlr 出问题，于是从 Zettlr 迁移到Vim。现在的 Markdown 是用 Vim 写的。当初不知道 Better BibTex for Zotero可以在 Vim 中直接调用窗口引用文献，我甚至还写了一个 Vim插件用于文献参考，效果如下</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/20221120193841.gif"alt="自己写的 Vim 参考文献补全插件" /></p><p>感觉还行，顺便解决了 Vim表格问题和图片插入。反正这几个月自己虽然没有写文章，但是确实没有闲着，都折腾需要折腾的东西了。如果最近要写点东西还是有素材的。</p>]]></content>
    
    
    <categories>
      
      <category>Markdown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
      <tag>Pandoc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell 脚本加 cURL, 再见 PicGo</title>
    <link href="/2022/06/27/Shell-%E8%84%9A%E6%9C%AC%E5%8A%A0-cURL,%E5%86%8D%E8%A7%81-PicGo/"/>
    <url>/2022/06/27/Shell-%E8%84%9A%E6%9C%AC%E5%8A%A0-cURL,%E5%86%8D%E8%A7%81-PicGo/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>谈谈最近的小事。</p><h2 id="sway-平铺窗口管理">Sway-平铺窗口管理</h2><p>GNOME 桌面 的极简主义让我很满意。为了让 GNOME更符合自己的审美，我添加了七八个插件。正因此，最近多次重启电脑，因为这货居然会卡住没反应！考虑到GNOME一直以内存泄漏出名，我打算试试平铺窗口管理（Tiling WindowManager）。</p><p>所谓"窗口平铺"，就是系统自动将打开的各种窗口排好，而不是一般系统的叠加（正确来说叫做"浮动（Floating）"）。</p><p>Linux 上平铺窗口管理最著名的就是 <a href="https://i3wm.org/"title="i3wm">i3wm</a>，我选择 <a href="https://swaywm.org/"title="Sway">Sway</a>，适用于 <a href="https://wayland.freedesktop.org/"title="Wayland">Wayland</a> 的 i3。<a href="https://manjaro.org/"title="Manjaro Linux">Manjaro Linux</a> 社区有在维护 Sway版，可惜我最开始的时候并没有选择 Sway。</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/06/27/202206271741491.png"title="官网截的图，因为我的 Sway 已经被我卸了。"alt="官网截的图，因为我的 Sway 已经被我卸了。" /></p><p>平铺有利于桌面空间的利用，全快捷键操作也可以让人脱离键盘，看起来极富极客（Geek）风格，也就是装～。其实Windows 系统也有平铺的功能，以前都是快捷键，Windows11之后直接在最大化按钮加上平铺。</p><p>安装 Sway 主要借助的是 <a href="https://wiki.archlinux.org/"title="Arch Linux Wiki">Arch LinuxWiki</a>。没办法，这家伙的文档贼丰富。Sway 的配置太难受了，包括i3，由于不希望安装太多第三方软件，我真的是从头到脚写了各种脚本，真的要吐。折腾到后面，感觉虽然有成就感，但是自己不愿折腾了，回到了GNOME。继续使用我的 GNOME 拓展 <ahref="https://extensions.gnome.org/extension/28/gtile/"title="gTile">gTile</a>。</p><h2 id="github-copilot">GitHub-Copilot</h2><p><ahref="https://github.blog/2022-06-21-github-copilot-is-generally-available-to-all-developers/"title="GitHub Copilot 消息来源">GitHub Copilot</a>是一个可以根据注释生成代码的人工智能。Copilot，顾名思义，当你的副手。GitHub对外开放不代表免费，实际上价格极其感人。好消息是，对于开源项目维护者和学生、老师来说，这东东是免费的。当然，前提是你得完成学生认证。GitHub的<a href="https://education.github.com/"title="学生认证">学生认证</a>其实好处多多（认证的邮箱建议使用学校邮箱），可以拿到各种优惠包。由于自己用不上，所以还没有进行认证。白嫖只是白白占有资源，何必呢。</p><p>GitHub Copilot 支持 Visual Studio、Visual Studio Code 和NeoVIM。如果感兴趣，也可以到<ahref="https://github.com/features/copilot/"title="GitHub Copilot">官网</a>瞄瞄这家伙如何工作。当然，如果进行学生认证的话还可以免费使用。</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/06/27/202206271808381.png"title="GitHub Copilot" alt="GitHub Copilot" /></p><h2 id="picgo">PicGo</h2><p><a href="https://www.picgo.net/" title="PicGO">PicGo</a>才是今天的主角，准确说是即将退场的主角。PicGo是一款集成各类图床的上传工具，可以通过 图床API（Application ProgrammingInterface，应用编程接口）轻松实现图片的上传。具体就不介绍了。</p><p>是这样的，Linux 系统 PicGo 的 AppImage 包高达100M。不得不说，对于有洁癖的人来说，是可忍孰不可忍？自己使用的图床主要包括<a href="https://chevereto-free.github.io/"title="Chevereto">Chevereto</a>、<a href="https://github.com/"title="GitHub">GitHub</a> 和 <a href="https://sm.ms/"title="SM.MS">SM.MS</a>，主要是前两者，后者只是以前用的。自己用不上PicGo 的多功能，而且 PicGo还那么臃肿，由此萌发了使用脚本自己写一个上传工具的念头。</p><p>说到脚本，很多人想到的自然是 Python，不过很可惜，Python在我眼中就是臃肿的另一个代表，虽然自己的系统就有Python。依赖越少的工具，越深得我的心，所以像Python 这类脚本语言基本可以散了，实际上 Lua 可以考虑。Linux 系统离不开Shell，所以后面决定用 Shell/Bash。</p><h1 id="替代-picgo">替代 PicGo</h1><p>写一个替代 PicGo 的脚本其实还是很简单的。Windows 系统没必要看，因为Windows 系统的生态确实太好了，没必要折腾。</p><h2 id="准备">准备</h2><p>简单介绍用到的东东：</p><ol type="1"><li>Linux GNOME 桌面环境。指定 GNOME 系统是为了使用 GNOME的全局自定义快捷键。因为我需要减少依赖，不可能为了设置全局快捷键下载一个软件或者程序。</li><li>Xclip，Linux X桌面协议系统（Xorg）的剪贴板程序。Linux 不是 X协议就是 Wayland协议。由于 Wayland协议 现在生态不咋地，为了兼容 Xorg 生出了XWayland 这个缝合怪（对的，就是两者的结合），因此直接使用Xclip就行，没必要用 wl-clipboard，徒增兼容问题。这是 Linux 标配。</li><li>Bash/Shell，最普遍的 Shell 环境，Linux 标配。</li><li>SED，Stream Editor，流式编辑器，Linux 标配。</li><li><a href="https://curl.se/"title="cURL">cURL</a>，非常强大的命令行文件传输工具，Linux 标配。</li><li>notify-send，命令行或者脚本下的通知工具，非常简单。不清楚是不是有桌面的Linux 都会带着，但是一般确实如此。</li><li>JQ，命令行环境处理 JSON格式文件的利器，见鬼，以前自己不愿安装，纯手工解析JSON,后面学乖了，好好使用 JQ吧。一般需要安装，一般使用命令行的都会安装。</li><li>GitHub 帐号，可选，用于保存图片，也就是做图床。</li><li>SM.MS 帐号，可选，做图床。</li></ol><p>上面的工具基本都是一个正常的 Linux 系统自带的，除了 JQ可能没有。还有，那两个帐号可不自带。</p><h2 id="搭建框架">搭建框架</h2><p>找一个放脚本的目录，例如我喜欢把自己的脚本放到<code>$HOME/.scripts</code> 目录下，创建一个 Shell 脚本。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> ~/.scripts <span class="hljs-comment"># 进入脚本目录</span><br>$ <span class="hljs-built_in">pwd</span> <span class="hljs-comment"># 输出当前目录</span><br>/home/chunshuyumao/.scripts<br>$ vim upload.sh<br><br><span class="hljs-comment"># 以下为脚本内容</span><br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-built_in">set</span> -euo pipefail<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">main</span></span>() &#123;<br><br>&#125;<br><br>main <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span><br></code></pre></div></td></tr></table></figure><p>创建脚本之后先写一个主函数(main)，让我们的脚本看起来更加清晰。这些内容之前的博客都出现过了，这就不解释了。</p><p>我们使用的是 GNOME 桌面系统自带的截图工具。GNOME42之后，这个工具的快捷键是<code>prt</code>，也就是键盘上的打印键。默认截图之后会保留在剪贴板，接下来我们需要从剪贴板获得图片。</p><p>不过想想，获取的图片保存到哪里？由于我们把图片上传到图床，本地保留一份看起来没必要，所以建议创建一个临时文件，上传之后删掉。我就是这么做的。实际上PicGo也是这样做的（之前，现在有内置方法）。从剪贴板获取图片使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">xclip -sel clip -t image/png -o &gt; image.png<br></code></pre></div></td></tr></table></figure><p>当然，你要是乐意，可以写全参数：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">xclip -selection clipboard -target image/png -out &gt; image.png<br></code></pre></div></td></tr></table></figure><p>懒人就不会选择长命令。长命令形式一目了然，我们从（selection）剪贴板（clipboard）获取目标图片PNG格式（targetimage/png），输出（out &gt;）到<code>image.png</code>。好家伙，完全不用解释哦！</p><p>这样在脚本所在目录就会出现一个 <code>image.png</code> 文件。</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/06/27/202206272005261.png"title="从剪贴板获取图片" alt="从剪贴板获取图片" /></p><p>可是这样不优雅，图片直接在脚本所在的地方生成非常恶心。好在我们可以做得更好！一个优雅的方式是，创建一个临时目录，把所有的临时文件放到这个目录中，等到任务完成之后再删去目录。好巧不巧，刚刚好有一个这样的命令符合我们的预期，它就是<code>mktemp</code>。通过查阅使用手册，我们可以知道，<code>mktemp</code>可以这样创建临时文件夹：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">mktemp</span> -d -t temp.XXXXXXXXXX<br>/tmp/tmp.e7Y2FzNj5Q<br></code></pre></div></td></tr></table></figure><p><code>-d</code>表示生成临时文件夹，不加的话会生成临时文件。<code>-t</code>表示在临时文件夹（/tmp）下生成。 <code>temp.XXXXXXXXXX</code>是生成的文件夹名，其中 <code>temp.</code>是随便取的，这是我自己选的；<code>XXXXXXXXXX</code>代表生成多少个随机的字符，你要乐意，写一万个也行。<code>mktemp</code>生成临时文件夹之后会返回文件夹的路径。</p><p>为了让自己的脚本更加健壮，我们需要确认 <code>mktemp</code>确实成功创建了文件夹，否则（||）直接退出（exit）。除此之外通过<code>date</code>创建图片的名字，然后和临时文件夹整合到一起作为图片的路径。因此我们的脚本现在变成了这样：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">set</span> -euo pipefail<br><br><span class="hljs-comment"># 按时间给图片命名，依次是 年 月 日 时 分 秒 星期</span><br><span class="hljs-comment"># [Y]ear [m]onth [d]ay [H]our [M]inute [S]econd  u --&gt; 鬼知道这是什么的缩写</span><br><span class="hljs-built_in">declare</span> -r image_name=<span class="hljs-string">&quot;<span class="hljs-subst">$(date +%Y%m%d%H%M%S%u)</span>.png&quot;</span><br><span class="hljs-comment"># 如果创建临时文件夹失败，就使用 exit 1 退出</span><br><span class="hljs-built_in">declare</span> -r tmpdir=<span class="hljs-string">&quot;<span class="hljs-subst">$(mktemp -d -t temp.XXXXXXXXXX)</span>&quot;</span> || <span class="hljs-built_in">exit</span> 1<br><span class="hljs-built_in">declare</span> -r path2image=<span class="hljs-string">&quot;<span class="hljs-variable">$tmpdir</span>/<span class="hljs-variable">$image_name</span>&quot;</span><br><span class="hljs-comment"># 通知持续时间为 3 秒</span><br><span class="hljs-built_in">declare</span> -r expire=3000<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">main</span></span>() &#123;<br><br>  <span class="hljs-comment"># Notifies when there is not image in clipboard, and exits.</span><br>  xclip -sel clip -t image/png -o &gt; <span class="hljs-string">&quot;<span class="hljs-variable">$path2image</span>&quot;</span> || &#123;<br>    notify-send -t <span class="hljs-variable">$expire</span> -i <span class="hljs-string">&#x27;dialog-warning&#x27;</span> <span class="hljs-string">&#x27;WARNING&#x27;</span> <span class="hljs-string">&quot;There is not image exiting in clipboard.&quot;</span><br>    <span class="hljs-built_in">exit</span> 1<br>  &#125;<br>&#125;<br><br>main <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span><br></code></pre></div></td></tr></table></figure><p><code>||</code>表示前面的命令失败的话就执行后面的命令。其实这些在之前的文章都有讲到。<code>notify-send</code>用于弹出通知，大概这样使用：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#             通知几秒后关闭？          图标是啥？              标题      内容</span><br>$ notify-send --expire-time milliseconds --icon <span class="hljs-string">&#x27;dialog-icon&#x27;</span> <span class="hljs-string">&#x27;Caption&#x27;</span> <span class="hljs-string">&#x27;Details&#x27;</span><br></code></pre></div></td></tr></table></figure><p>脚本中的意思是：从（selection）剪贴板（clipboard）获取（target）PNG格式的图片（image/png），并输出（out&gt;）到 <code>path2image</code>中。如果获取失败（||），以警告图标（icondialog-warning）发送标题为"WARNING"，内容为"巴拉巴拉"的通知（notify-send），通知时间持续3 秒。</p><p>上传到 SM.MS 还是 GitHub 是不同的选择，所以待会写两个函数，一个传到SM.MS，一个传到GitHub。我们希望调用函数之后，函数返回上传成功后图片的地址，也就是：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">local</span> image_url=<span class="hljs-string">&quot;<span class="hljs-subst">$(upload2github)</span>&quot;</span><br></code></pre></div></td></tr></table></figure><p>获得的地址以 Markdown格式传到剪贴板，这样就可以直接粘贴了，也就是</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;![](<span class="hljs-variable">$&#123;image_url&#125;</span>)&quot;</span> | xclip -sel clip<br></code></pre></div></td></tr></table></figure><p>最后再发送(notify-send)一个通知(dialog-information)，说明（details）成功（caption）了：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">notify-send -t <span class="hljs-variable">$expire</span> -i <span class="hljs-string">&#x27;dialog-information&#x27;</span> <span class="hljs-string">&#x27;SUCCESS&#x27;</span> <span class="hljs-string">&#x27;$&#123;image_url&#125;&#x27;</span><br></code></pre></div></td></tr></table></figure><p>处理完之后，别忘了删除我们的临时文件夹，写一个 clean 函数，在 main函数里面显式调用，或者当捕捉(trap)到退出(EXIT)信号时被动调用。现在来看看我们的脚本：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">set</span> -euo pipefail<br><br><span class="hljs-built_in">trap</span> clean EXIT<br><br><span class="hljs-comment"># 按时间给图片命名，依次是 年 月 日 时 分 秒 星期</span><br><span class="hljs-comment"># [Y]ear [m]onth [d]ay [H]our [M]inute [S]econd  u --&gt; 鬼知道这是什么的缩写</span><br><span class="hljs-built_in">declare</span> -r image_name=<span class="hljs-string">&quot;<span class="hljs-subst">$(date +%Y%m%d%H%M%S%u)</span>.png&quot;</span><br><span class="hljs-built_in">declare</span> -r tmpdir=<span class="hljs-string">&quot;<span class="hljs-subst">$(mktemp -d -t temp.XXXXXXXXXX)</span>&quot;</span> || <span class="hljs-built_in">exit</span> 1<br><span class="hljs-built_in">declare</span> -r path2image=<span class="hljs-string">&quot;<span class="hljs-variable">$tmpdir</span>/<span class="hljs-variable">$image_name</span>&quot;</span><br><span class="hljs-comment"># 通知持续时间为 3 秒</span><br><span class="hljs-built_in">declare</span> -r expire=3000<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">clean</span></span>() &#123;<br>  /bin/rm -rf <span class="hljs-variable">$tempdir</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">main</span></span>() &#123;<br><br>  <span class="hljs-comment"># Notifies when there is not image in clipboard, and exits.</span><br>  xclip -sel clip -t image/png -o &gt; <span class="hljs-string">&quot;<span class="hljs-variable">$path2image</span>&quot;</span> || &#123;<br>    notify-send -t <span class="hljs-variable">$expire</span> -i <span class="hljs-string">&#x27;dialog-warning&#x27;</span> <span class="hljs-string">&#x27;WARNING&#x27;</span> <span class="hljs-string">&quot;There is not image exiting in clipboard.&quot;</span><br>    <span class="hljs-built_in">exit</span> 1<br>  &#125;<br>  <br>  <span class="hljs-comment"># 默认上传到 GitHub</span><br>  <span class="hljs-built_in">local</span> image_url=<span class="hljs-string">&quot;<span class="hljs-subst">$(upload2github)</span>&quot;</span><br>  <span class="hljs-comment"># 复制到剪贴板</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;![](<span class="hljs-variable">$&#123;image_url&#125;</span>)&quot;</span> | xclip -sel clip<br>  notify-send -t <span class="hljs-variable">$expire</span> -i <span class="hljs-string">&#x27;dialog-information&#x27;</span> <span class="hljs-string">&#x27;SUCCESS&#x27;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;image_url&#125;</span>&quot;</span><br>  <br>  clean<br>&#125;<br><br>main <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span><br></code></pre></div></td></tr></table></figure><p>框架搭建完毕！后面如果有其他的图床，多写一个函数就完了。此外， PicGo干的其实也不多就是这件事，只不过是人家是跨平台可视化的，而我写的这个仅限于类Unix 系统。</p><h2 id="编写-upload2github-函数">编写 upload2github 函数</h2><p>具体实现上传函数。为了普适性，我拿 GitHub图床做一个例子。首先要准备几样东西</p><ol type="1"><li>图床仓库</li><li>私人令牌（Token）</li></ol><p>这里就不介绍如何申请 GitHub仓库了，默认你建立了自己的仓库。这个仓库名一定要准确。例如我的仓库<code>202203</code>：</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/06/27/202206272146001.png"title="202203" alt="202203" /></p><p>有了这个我们可以写函数了：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">upload2github</span></span>() &#123;<br><br>  <span class="hljs-comment">#################设置####################</span><br>  <span class="hljs-built_in">local</span> repo=<span class="hljs-string">&#x27;202203&#x27;</span><br>  <span class="hljs-built_in">local</span> username=<span class="hljs-string">&#x27;chunshuyumao&#x27;</span><br>  <span class="hljs-built_in">local</span> token=<span class="hljs-string">&#x27;xxxxxxxxxxxxxxxxxxxxxx&#x27;</span><br>  <span class="hljs-comment">#################可选####################</span><br>  <span class="hljs-built_in">local</span> cdn=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/gh/<span class="hljs-variable">$username</span>/<span class="hljs-variable">$repo</span>@master&quot;</span><br>  <span class="hljs-comment">#################设置####################</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>私人令牌（token）需要到帐号设置里获取。CDN（Content DeliveryNetwork，内容分发网络），用于加速 GitHub图床的图片显示，毕竟国外的东西，访问难免慢，使用 CDN加速就会快一点。除了设置网起来的配置，其他都不要动。</p><p>参考 <a href="https://docs.github.com/en/rest/repos/contents"title="GitHub API PUT">GitHub官方API使用说明</a> 上传图片。</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/06/27/202206272200431.png"title="GitHub API" alt="GitHub API" /></p><p>语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">curl \<br>  -X <span class="hljs-string">&#x27;PUT&#x27;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$github_url</span>&quot;</span> \<br>  -H <span class="hljs-string">&#x27;Accept: application/vnd.github.v3+json&#x27;</span> \<br>  -H <span class="hljs-string">&quot;Authorization: token <span class="hljs-variable">$token</span>&quot;</span> \<br>  -d <span class="hljs-string">&#x27;&#123; &quot;message&quot;: &quot;upload&quot;, &quot;content&quot;: &quot;&#x27;</span><span class="hljs-variable">$content</span><span class="hljs-string">&#x27;&quot; &#125;&#x27;</span><br></code></pre></div></td></tr></table></figure><p><code>-X</code> 表示请求的方式，这里使用<code>PUT</code>。<code>-H</code> 用于构建请求的头部，也就是<code>header</code>。<code>-d</code> 是上传的数据，即网络请求的<code>data</code>。</p><p><code>$github_url</code> 是一个 API URL，如下：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Bash"><span class="hljs-built_in">local</span> github_url=<span class="hljs-string">&quot;https://api.github.com/repos/<span class="hljs-variable">$username</span>/<span class="hljs-variable">$repo</span>/contents/<span class="hljs-variable">$image_name</span>&quot;</span><br></code></pre></div></td></tr></table></figure><p><code>token</code> 我们已经见过了。<code>$content</code>呢？官网说的很清楚，是一个通过 <code>base64</code>编码的字符串。这样获取：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Bash"><span class="hljs-built_in">local</span> content=<span class="hljs-string">&quot;<span class="hljs-subst">$(base64 -w 0 $path2image)</span>&quot;</span><br></code></pre></div></td></tr></table></figure><p><code>-w 0</code> 表示不用换行（no wrap）。习惯上，文本文件一行限制70 个字符，这称为<code>wrap</code>。无缘无故添加换行符，后面难以处理，所以我们设置不换行。</p><p>请求之后返回的结果是 JSON 格式，保存到一个变量，然后用 JQ进行处理：</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/06/27/202206272209181.png" /></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">local</span> message=<span class="hljs-string">&quot;<span class="hljs-subst">$(curl \</span></span><br><span class="hljs-subst"><span class="hljs-string">  -X &#x27;PUT&#x27; <span class="hljs-string">&quot;<span class="hljs-variable">$github_url</span>&quot;</span> \</span></span><br><span class="hljs-subst"><span class="hljs-string">  -H &#x27;Accept: application/vnd.github.v3+json&#x27; \</span></span><br><span class="hljs-subst"><span class="hljs-string">  -H <span class="hljs-string">&quot;Authorization: token <span class="hljs-variable">$token</span>&quot;</span> \</span></span><br><span class="hljs-subst"><span class="hljs-string">  -d &#x27;&#123; <span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;upload&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;&#x27;<span class="hljs-variable">$content</span>&#x27;&quot;</span> &#125;&#x27; \</span></span><br><span class="hljs-subst"><span class="hljs-string">  2&gt; /dev/null | jq &#x27;commit..message?&#x27; sed -r &#x27;s/\&quot;(.*)</span>\&quot;/\1/g&#x27;)&quot;</span><br><br><span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$message</span>&quot;</span> != <span class="hljs-string">&quot;upload&quot;</span> ]]; <span class="hljs-keyword">then</span><br>  notify-send -t <span class="hljs-variable">$expire</span> -i <span class="hljs-string">&#x27;dialog-error&#x27;</span> <span class="hljs-string">&#x27;ERROR&#x27;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$message</span>&quot;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-built_in">exit</span> 1<br></code></pre></div></td></tr></table></figure><p>我们不需要使用返回的结果，只需要判断是否成功。文档说明，如果上传成功，返回的message 是我们之前的 message 的内容，我们只需要判断两个 message想不相同即可。如果不同，直接报错通知。</p><p><code>2&gt; /dev/null</code> 表示把错误输出到 <code>/dev/null</code>文件。<code>|</code>叫做"管道符"，表示把左边的输出当作右边的输入。<code>jq '.message?'</code>的意思是获取 JSON 格式第一层的 <code>message</code>信息，问号表示如果没有这个信息，那就返回 <code>null</code>代替，相当于:</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> message exists <span class="hljs-keyword">in</span> JSON, <span class="hljs-keyword">then</span> <span class="hljs-built_in">return</span> message <span class="hljs-keyword">else</span> <span class="hljs-built_in">return</span> null<br></code></pre></div></td></tr></table></figure><p>上传成功之后，我们直接返回图片的链接：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;<span class="hljs-variable">$cdn</span>/<span class="hljs-variable">$image_name</span>&quot;</span><br></code></pre></div></td></tr></table></figure><p>Shell脚本的返回和其他语言的返回不大一样，其实这个是打印，而不是返回。最后我们的脚本是：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 函数描述:</span><br><span class="hljs-comment">#   上传图片到 GitHub 图床</span><br><span class="hljs-comment"># 参数: 无</span><br><span class="hljs-comment"># 返回值: 图片的链接，或者弹出失败后的信息</span><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">upload2github</span></span>() &#123;<br><br>  <span class="hljs-comment">####################设置#######################</span><br>  <span class="hljs-built_in">local</span> repo=<span class="hljs-string">&#x27;202203&#x27;</span>  <span class="hljs-comment"># 这是你的仓库名</span><br>  <span class="hljs-built_in">local</span> username=<span class="hljs-string">&#x27;chunshuyumao&#x27;</span> <span class="hljs-comment"># 这是你的帐号名，现在写的是我的</span><br>  <span class="hljs-built_in">local</span> token=<span class="hljs-string">&#x27;xxxxxxxxxxxxxxxxxxxxxx&#x27;</span> <span class="hljs-comment"># 你的私人令牌，token</span><br>  <span class="hljs-comment">################可选 CDN 加速###################</span><br>  <span class="hljs-built_in">local</span> cdn=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/gh/<span class="hljs-variable">$username</span>/<span class="hljs-variable">$repo</span>@master&quot;</span><br>  <span class="hljs-comment">####################设置########################</span><br><br>  <span class="hljs-built_in">local</span> content=<span class="hljs-string">&quot;<span class="hljs-subst">$(base64 -w 0 $path2image)</span>&quot;</span><br>  <span class="hljs-built_in">local</span> github_url=<span class="hljs-string">&quot;https://api.github.com/repos/<span class="hljs-variable">$username</span>/<span class="hljs-variable">$repo</span>/contents/<span class="hljs-variable">$image_name</span>&quot;</span><br>  <span class="hljs-built_in">local</span> message=<span class="hljs-string">&quot;<span class="hljs-subst">$(curl \</span></span><br><span class="hljs-subst"><span class="hljs-string">    -X &#x27;PUT&#x27; <span class="hljs-string">&quot;<span class="hljs-variable">$github_url</span>&quot;</span> \</span></span><br><span class="hljs-subst"><span class="hljs-string">    -H &#x27;Accept: application/vnd.github.v3+json&#x27; \</span></span><br><span class="hljs-subst"><span class="hljs-string">    -H <span class="hljs-string">&quot;Authorization: token <span class="hljs-variable">$token</span>&quot;</span> \</span></span><br><span class="hljs-subst"><span class="hljs-string">    -d &#x27;&#123; <span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;upload&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;&#x27;<span class="hljs-variable">$content</span>&#x27;&quot;</span> &#125;&#x27; 2&gt; /dev/null | jq &#x27;.message?&#x27;)</span>&quot;</span><br><br>  <span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$message</span>&quot;</span> != <span class="hljs-string">&quot;upload&quot;</span> ]]; <span class="hljs-keyword">then</span><br>    notify-send -t <span class="hljs-variable">$expire</span> -i <span class="hljs-string">&#x27;dialog-error&#x27;</span> <span class="hljs-string">&#x27;ERROR&#x27;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$message</span>&quot;</span><br>    <span class="hljs-built_in">exit</span> 1<br>  <span class="hljs-keyword">fi</span><br><br>  <span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;<span class="hljs-variable">$cdn</span>/<span class="hljs-variable">$image_name</span>&quot;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>GitHub 函数写完。后面来看看 SM.MS。</p><h2 id="sm.ms-函数">SM.MS 函数</h2><p>SM.MS 图床也需要准备一个 <code>token</code>，主要结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 函数描述:</span><br><span class="hljs-comment">#   上传图片到 SM.MS 图床</span><br><span class="hljs-comment"># 参数: 无</span><br><span class="hljs-comment"># 返回值: 图片的链接，或者返回失败后的信息</span><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">upload2smms</span></span>() &#123;<br><br>  <span class="hljs-comment">#################SETTINGS START#################</span><br>  <span class="hljs-built_in">local</span> smms_url=<span class="hljs-string">&quot;https://sm.ms/api/v2/upload&quot;</span><br>  <span class="hljs-built_in">local</span> token=<span class="hljs-string">&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;</span><br>  <span class="hljs-comment">#################SETTINGS END###################</span><br><br>  <span class="hljs-built_in">local</span> result=<span class="hljs-string">&quot;<span class="hljs-subst">$(curl \</span></span><br><span class="hljs-subst"><span class="hljs-string">    -X &#x27;POST&#x27; <span class="hljs-string">&quot;<span class="hljs-variable">$smms_url</span>&quot;</span> \</span></span><br><span class="hljs-subst"><span class="hljs-string">    -H &#x27;Content-Type: multipart/form-data&#x27; \</span></span><br><span class="hljs-subst"><span class="hljs-string">    -H <span class="hljs-string">&quot;Authorization: Basic <span class="hljs-variable">$token</span>&quot;</span> \</span></span><br><span class="hljs-subst"><span class="hljs-string">    -F <span class="hljs-string">&quot;smfile=@<span class="hljs-variable">$&#123;path2image&#125;</span>;type=image/png;filename=<span class="hljs-variable">$&#123;image_name&#125;</span>&quot;</span> 2&gt; /dev/null)</span>&quot;</span><br><br>  <span class="hljs-built_in">local</span> image_url=<span class="hljs-string">&quot;<span class="hljs-subst">$(echo -n <span class="hljs-string">&quot;<span class="hljs-variable">$result</span>&quot;</span> | jq &#x27;.data.url?&#x27; | sed -r &#x27;s/\&quot;(.*)</span>\&quot;/\1/g&#x27;)&quot;</span><br>  <span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$image_url</span>&quot;</span> == <span class="hljs-string">&quot;null&quot;</span> ]]; <span class="hljs-keyword">then</span><br>    notify-send -t <span class="hljs-variable">$expire</span> -i <span class="hljs-string">&#x27;dialog-error&#x27;</span> <span class="hljs-string">&quot;ERROR&quot;</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(echo <span class="hljs-string">&quot;<span class="hljs-variable">$result</span>&quot;</span> | jq &#x27;.message?&#x27;)</span>&quot;</span><br>    <span class="hljs-built_in">exit</span> 1<br>  <span class="hljs-keyword">fi</span><br><br>  <span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;<span class="hljs-variable">$image_url</span>&quot;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>这个也很简单，参考<a href="https://doc.sm.ms/"title="SM.MS API">官网</a>。<code>-F</code> 参数是 <code>cURL</code>传递 <code>form-data</code>的方式，因为官网说了上传的是文件。一般上传文件直接使用<code>-F</code>。</p><p><ahref="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/06/27/202206272237441.png"title="SM.MS上传">SM.MS上传</a></p><p><code>jq '.data.url?'</code> 表示从 JSON 中获取 data 下的 url内容。大概是这样的布局：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">&#123;<br>    <span class="hljs-string">&quot;data&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;usr&quot;</span>: <span class="hljs-string">&quot;blabla&quot;</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>问号仍然表示没有这东东的话返回 <code>null</code>，后面的<code>message</code> 也一样。</p><p><code>sed -r 's/\"(.*)\"/\1/g'</code>用于删掉链接两边的双引号（""），因为链接两边不应该有双引号。</p><p>最后判断获取的是不是链接，不是的话就通知错误，并退出。轻轻松松，脚本完成！</p><h2 id="设置全局快捷键">设置全局快捷键</h2><p>这里只说 GNOME的全局快捷键。打开<code>gnome-center-control</code>，或者直接找设置（settings）</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/06/27/202206272247001.png"title="设置" alt="设置" /></p><p>选择<code>键盘（Keyboard）=&gt; 键盘快捷键（Keyboard Shortcuts）=&gt; 浏览与自定义快捷键（View and Custumize Shortcuts）=&gt; 自定义快捷键（Custom Shortcuts）</code>，点击<code>➕</code>：</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/06/27/202206272250411.png"title="添加" alt="添加" /></p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/06/27/202206272251341.png"title="添加快捷键" alt="添加快捷键" /></p><p><code>描述（Name）</code>只是描述，随便写啥；<code>命令（comamnd）</code>写你的脚本所在的路径，最后点击<code>快捷键（Shortcut）</code>进行快捷键设置。Over！</p><h1 id="后语">后语</h1><p>最后，把 PicGo 给卸了，毕竟，自己写的脚本才几K？开玩笑，其实 PicGo除了简单，还有可视化、预览、删除图床图片等等的功能，自己的这个脚本只是阉割版罢了。不得不说，Linux下真的可以自己动手丰衣足食。</p>]]></content>
    
    
    <categories>
      
      <category>Manjaro</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell脚本下载B站视频</title>
    <link href="/2022/06/08/Shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E8%BD%BDB%E7%AB%99%E8%A7%86%E9%A2%91/"/>
    <url>/2022/06/08/Shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E8%BD%BDB%E7%AB%99%E8%A7%86%E9%A2%91/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>前一阵子想在 B站下载点东西，可没有登陆各种网站的习惯。网上存在一些在线解析 B站视频的网站提供下载，不过我当时需要的是批量下载——可能是有洁癖吧，什么东西都觉得本地保留一份才是最安全的。这样一来，线上解析的网站就难找了。再说了，有些网站为了维持运营，不得不添加一些广告，这就很烦人了——好吧，白嫖没理由抱怨。</p><p>后来不得不使用了 <ahref="https://github.com/soimort/you-get">You-get</a>这个堪称下载神器的东西。You-get虽然可以实现批量下载，但是问题也很明显，就是批量下载可能会卡住，一卡住就得从来，见鬼。为了加快下载速度，自己又得在You-get 的基础上写一个多线程下载。You-get 用Python，我一来对这门语言不感兴趣，二来这东东好像后面还是调用了 <ahref="https://ffmpeg.org">FFmpeg</a> 进行音视频合并，这种东东使用简单的Shell 也可以实现，何必多此一举？</p><p>有了想法开始动手实现自己的 B站 视频下载脚本。这里要说说，You-get的功能太强大，一般我用不上，所以自己的脚本自然看起来简单多了，但是和You-get比还是功能太少。自己写的脚本不支持列表下载，不过可以配合自己之前写的多线程实现下载——适合自己的就是最好的。</p><h1 id="准备">准备</h1><p>使用 Shell 脚本自然不可能是 Windows 系统，所以 Windows系统的同志可以散了。想要自己写写的可以随便上网搜搜 Python语言的，运气好可能搜到一篇真的在教你怎么用 Python下载的。一般而言，使用国内的搜索引擎会非常痛苦——你不会找到自己想要的东西，你只会找到别人开钱给你看的东西。下面是基本工具：</p><ol type="1"><li>Unix/Linux 系统，也就是除了 Windows 外的系统。</li><li><a href="https://ffmpeg.org/">FFmpeg</a>一个跨平台的音视频框架。其实就一句话，合并音视频用的。</li><li>Shell，形形色色的 Shell 都行，为了最大的兼容性，一般是 Bash。</li><li>JQ，一个 Shell 上处理 <a href="https://www.json.org">JSON</a>数据的工具。通常 Unix/Linux系统不会自带，是用包管理器直接可以下载。</li></ol><p>除此之外还使用到 SED、<a href="https://curl.se">cURL</a> 等工具，一般Unix/Linux 系统都自带了，所以不单独列出。</p><h1 id="实现">实现</h1><p>接下来会分步骤进行实现。</p><h2 id="构建框架">构建框架</h2><p>为了精简脚本的功能，我的想法是脚本如此调用：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">bl.sh https://www.bilibili.com/video/BV1UE411d7QZ<br></code></pre></div></td></tr></table></figure><p>也就是<code>脚本 + URL</code>。然后就没有任何功能了——要的就是精简。</p><p>首先要创建一个脚本，我用的是 VIM 编辑器，所以下面是基本操作：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ vim bl.sh<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-built_in">set</span> -euo pipefail<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">main</span></span>() &#123;<br><br><br>&#125;<br><br>main <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span><br></code></pre></div></td></tr></table></figure><p>在上面的 <code>bl.sh</code> 脚本中写了一个 <code>main</code>函数作为主函数，并在最后调用这个函数。因为自己最开始接触到的语言是 C/C++，总觉得无论如何还是写一个主函数逻辑上才清楚，不喜欢一上来就是各种奇葩语句和乱入的函数堆叠。</p><p><code>set -euo pipefail</code> 设置脚本的一些功能，其中<code>-e</code> 表示遇到报错直接退出（EXIT），<code>-u</code>表示使用没有声明的变量（undeclearedvariable）就直接退出，<code>-o pipefail</code>表示使用管道符失败就报错退出。</p><p>设置上面的功能源于我的一些理念：只要没有得到正确执行就是错误，错误没有必要存在，没必要存在就没必要执行，程序直接算失败。这是一种习惯，有些人就喜欢和警告（warning、info）、错误（error）共存，咱也没办法。</p><p>为了进行检验，下面会以<code>https://www.bilibili.com/video/BV1Sg41137WR</code>作为下载事例。</p><h2 id="使用-curl">使用 cURL</h2><p>我们先用 cURL 请求目标网址试试：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ curl -O <span class="hljs-string">&quot;https://www.bilibili.com/video/BV1Sg41137WR&quot;</span><br>  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current<br>                                 Dload  Upload   Total   Spent    Left  Speed<br>100 47405    0 47405    0     0  83409      0 --:--:-- --:--:-- --:--:-- 83312<br>$ <span class="hljs-built_in">ls</span><br>BV1Sg41137WR<br>$ file BV1Sg41137WR<br>BV1Sg41137WR: gzip compressed data, from Unix, original size modulo 2^32 259418<br></code></pre></div></td></tr></table></figure><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/06/08/202206082248087.png"title="尝试请求" alt="尝试请求" /></p><p><code>curl -O url</code>表示把请求网址的结果保存，我们看到，保存之后生成了一个<code>BV1Sg41137WR</code> 的 gZIP 压缩文件。解压这个文件试试：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">mv</span> BV1Sg41137WR&#123;,.gz&#125;<br>$ gzip -d BV1Sg41137WR.gz<br>$ file BV1Sg41137WR<br>BV1Sg41137WR: HTML document, Unicode text, UTF-8 text, with very long lines (63971), with no line terminators<br></code></pre></div></td></tr></table></figure><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/06/08/202206082249382.png"title="解压文件" alt="解压文件" /></p><p>可以看到，解压之后这个文件其实是一个 HTML文件，也就是网页的源码。我们要找的视频网址等内容都在里边，接下来就是我们解读了。解释解释上面的行为。</p><p><code>mv</code>是重命名的意思，因为后面需要解压，自然就需要重名了。FreeBSD 等 Unix直系后代系统习惯通过文件内容判断文件格式。比如上面的<code>BV1Sg41137WR</code> 文件，通过判断可以得知是 gZIP 文件。在 FreeBSD中可以直接使用 <code>gzip -d</code>解压，因为通过内容可以轻松辨认出来；但是 Linux系统通过文件扩展名辨认文件， <code>BV1Sg41137WR</code> 没有文件名，在Linux 上使用 <code>gzip -d</code>它就分辨不出来这个文件是啥，自然就拒绝解压。</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/06/08/202206082255543.png"title="错误案例" alt="错误案例" /></p><p><code>mv</code> 是 <code>move</code>的缩写，用于移动和重命名。按理来说我们的操作应该是</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> BV1Sg41137WR BV1Sg41137WR.gz<br></code></pre></div></td></tr></table></figure><p><code>.gz</code> 是 gZIP文件的扩展名。可是我们看到上面的操作重复的字符太多了，懒人就不该写那么多的字母，所以Linux Shell 又有这种操作</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> BV1Sg41137WR&#123;,.gz&#125;<br></code></pre></div></td></tr></table></figure><p>通过在花括号和一个逗号省略相同的部分。于是就有我们的上面的操作。</p><p><code>gzip -d</code> 中的 <code>-d</code> 是<code>--decompress</code> 的缩写，也就是解压咯。</p><p>接下来可以使用文本编辑器查看下载的 HTML源码，其实最好的方式是通过浏览器直接查看源码。因为已经搞清楚了 B站尿性，所以我这里就不解释如何通过分析源码了解我们想要的内容。直接告诉大家：我们需要的部分在源码中的<code>window.__playinfo__</code>部分，可以通过浏览器查看源码然后查找得到。</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/06/09/202206091212163.png"title="目标" alt="目标" /></p><p>接下来要做的就是把 <code>__playinfo__=</code>后面的内容提取出来，然后通过 jq 格式化显示出来。</p><h2 id="获取目标内容">获取目标内容</h2><p>已经有了 HTML源码，现在就是从源码中提取我们需要的部分。上面已经说过，<code>__playinfo__=</code>后面就是我们的目标内容。在命令行上输入</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> BV1Sg41137WR | sed -nr <span class="hljs-string">&#x27;s/.*__playinfo__=(.*)&lt;\/script&gt;&lt;script&gt;.*/\1/gp&#x27;</span><br></code></pre></div></td></tr></table></figure><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/06/09/202206091254062.png"title="获取需要的部分" alt="获取需要的部分" /></p><p>这里解释一下，我们需要使用 <code>BV1Sg41137WR</code> 的内容，所以通过<code>cat</code> 和管道符 <code>|</code> 把内容传递给 SED。SED 参数<code>-n</code> 表示不打印，SED一般匹配之后会直接打印出来，我们希望打不打印由自己控制，所以默认直接不打印；<code>-r</code>表示后面我们会用到正则表达式（Regular Expression）。</p><p><code>s/.*__playinfo__=(.*)&lt;\/script&gt;&lt;script&gt;.*/\1/gp</code>是传递给 SED 的正则匹配模式。在 SED 中使用替换的语法是<code>s/old/new/gp</code>，把 <code>old</code> 替换为<code>new</code>，<code>g</code> 表示全局替换，SED默认只替换一次，使用全局替换就是见到的就替换；<code>p</code>表示打印出来，也就是替换之后打印出来；这里的<code>gp</code>是可选的，也就是可有可无。正则中的 <code>.*</code>表示任何字符，<code>(.*)</code>表示任意字符，并把它们分成一个小组，小组的编号从 1 开始，使用<code>\1</code> 代替。如果看不懂就算了，这就是提取内容罢了。</p><p>获取内容之后，我们可以看到内容非常乱，简直不是人看的。使用 JQ进行格式化就好看了：</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/06/09/202206091305686.png"title="格式化之后" alt="格式化之后" /></p><p>现在我们需要的是视频的链接。B站由于各种原因——谁都有自己的原因——为了防止别人下载自己的视频，把视频和音频分开存储，这样如果你使用具有嗅探功能的下载器也只能下载到没有音频的视频而已——没办法。</p><p>分析我们抓取到内容可以看出，数据中存在视频（video）和音频（audio）两个部分，我们需要做的就是抓取音、视频，然后通过FFmpeg 合并。</p><p>通过格式化后的 JSON 数据可以看到，视频在 <code>data</code> 标签下的<code>dash</code> 下的 <code>video</code> 下的 <code>baseUrl</code>。我们可以通过 JQ 回去，格式是：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ jq <span class="hljs-string">&#x27;.data.dash.video[0].baseUrl&#x27;</span> JSON<br></code></pre></div></td></tr></table></figure><p><code>video</code> 加 <code>[0]</code>是因为视频有多种清晰度，我们只需要获取第一个清晰度就行——在编程中，第一个往往从0 开始数。同理，音频如此获取：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ jq <span class="hljs-string">&#x27;.data.dash.audio[0].baseUrl&#x27;</span> JSON<br></code></pre></div></td></tr></table></figure><p>JQ 可以一次性获取多个值，所以我们可以简单写成：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ jq <span class="hljs-string">&#x27;.data.dash.video[0].baseUrl, .data.dash.audio[0].baseUrl&#x27;</span> JSON<br></code></pre></div></td></tr></table></figure><p>最后我们这样获取想要的数据：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> BV1Sg41137WR | sed -nr <span class="hljs-string">&#x27;s/.*__playinfo__=(.*)&lt;\/script&gt;&lt;script&gt;.*/\1/gp&#x27;</span> | jq <span class="hljs-string">&#x27;.data.dash.video[0].baseUrl, .data.dash.audio[0].baseUrl&#x27;</span><br><br><span class="hljs-string">&quot;https://upos-sz-mirrorhw.bilivideo.com/upgcxcode/53/45/348384553/348384553_nb2-1-30080.m4s?e=ig8euxZM2rNcNbdlhoNvNC8BqJIzNbfqXBvEqxTEto8BTrNvN0GvT90W5JZMkX_YN0MvXg8gNEV4NC8xNEV4N03eN0B5tZlqNxTEto8BTrNvNeZVuJ10Kj_g2UB02J0mN0B5tZlqNCNEto8BTrNvNC7MTX502C8f2jmMQJ6mqF2fka1mqx6gqj0eN0B599M=&amp;uipk=5&amp;nbs=1&amp;deadline=1654755278&amp;gen=playurlv2&amp;os=hwbv&amp;oi=3723425079&amp;trid=9f2d5b2f02c543e4919e6644832471cbu&amp;mid=0&amp;platform=pc&amp;upsig=dfcbb72afadc553a5c83c23fcacb7148&amp;uparams=e,uipk,nbs,deadline,gen,os,oi,trid,mid,platform&amp;bvc=vod&amp;nettype=0&amp;orderid=0,3&amp;agrr=1&amp;bw=255483&amp;logo=80000000&quot;</span><br><span class="hljs-string">&quot;https://upos-sz-mirrorhw.bilivideo.com/upgcxcode/53/45/348384553/348384553_nb2-1-30280.m4s?e=ig8euxZM2rNcNbdlhoNvNC8BqJIzNbfqXBvEqxTEto8BTrNvN0GvT90W5JZMkX_YN0MvXg8gNEV4NC8xNEV4N03eN0B5tZlqNxTEto8BTrNvNeZVuJ10Kj_g2UB02J0mN0B5tZlqNCNEto8BTrNvNC7MTX502C8f2jmMQJ6mqF2fka1mqx6gqj0eN0B599M=&amp;uipk=5&amp;nbs=1&amp;deadline=1654755278&amp;gen=playurlv2&amp;os=hwbv&amp;oi=3723425079&amp;trid=9f2d5b2f02c543e4919e6644832471cbu&amp;mid=0&amp;platform=pc&amp;upsig=8b68ed8743e01fde1dc6ac48136b3bc4&amp;uparams=e,uipk,nbs,deadline,gen,os,oi,trid,mid,platform&amp;bvc=vod&amp;nettype=0&amp;orderid=0,3&amp;agrr=1&amp;bw=23987&amp;logo=80000000&quot;</span><br></code></pre></div></td></tr></table></figure><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/06/09/202206091318587.png"title="获取音、视频链接" alt="获取音、视频链接" /></p><p>可以看到，获取的链接两边有引号，我们不需要这些引号，所以使用 SED去除。方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> BV1Sg41137WR | sed -nr <span class="hljs-string">&#x27;s/.*__playinfo__=(.*)&lt;\/script&gt;&lt;script&gt;.*/\1/gp&#x27;</span> | jq <span class="hljs-string">&#x27;.data.dash.video[0].baseUrl, .data.dash.audio[0].baseUrl&#x27;</span> | sed -nr <span class="hljs-string">&#x27;s/\&quot;(.*)\&quot;/\1/gp&#x27;</span><br></code></pre></div></td></tr></table></figure><p>既然已经获得链接，可以把上面的步骤写进脚本了。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">set</span> -euo pipefail<br><br><span class="hljs-comment"># 测试的 B站 视频链接</span><br><span class="hljs-built_in">declare</span> url=<span class="hljs-string">&#x27;https://www.bilibili.com/video/BV1Sg41137WR&#x27;</span><br><br><span class="hljs-comment"># 获取内容的正则表达式，用于 sed</span><br><span class="hljs-built_in">declare</span> -r reg_data=<span class="hljs-string">&#x27;s/.*__playinfo__=(.*)&lt;\/script&gt;&lt;script&gt;.*/\1/gp&#x27;</span><br><span class="hljs-comment"># 获取音、视频的正则，用于 jq</span><br><span class="hljs-built_in">declare</span> -r reg_video_audio=<span class="hljs-string">&#x27;.data.dash.video[0].baseUrl, .data.dash.audio[0].baseUrl&#x27;</span><br><span class="hljs-comment"># User-Agent 用于伪装成这成浏览器的请求——因为 B站 发现是脚本在下载视频就会阻止你下载。</span><br><span class="hljs-comment"># 如果你伪装成浏览器，它就以为你使用浏览器，自然不会影响到它的利益，也就不管你下载多少</span><br><span class="hljs-comment"># 视频了——毕竟你浏览越多，对它越好</span><br><span class="hljs-built_in">declare</span> -r user_agent=<span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.116 Safari/537.36&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">main</span></span>() &#123;<br><br>  <span class="hljs-comment"># 获取原始 HTML 源文件，把输出输出到 /dev/null，同时使用 gzip 进行解压，解压的内容放到</span><br>  <span class="hljs-comment"># raw_html 变量中</span><br>  <span class="hljs-built_in">local</span> raw_html=$(curl --user-agent <span class="hljs-string">&quot;<span class="hljs-variable">$user_agent</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$url</span>&quot;</span> 2&gt; /dev/null | gzip -d -)<br>  <span class="hljs-built_in">local</span> va=($(<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$raw_html</span>&quot;</span> | sed -nr <span class="hljs-variable">$reg_data</span> | jq <span class="hljs-string">&quot;<span class="hljs-variable">$reg_video_audio</span>&quot;</span> | sed -nr <span class="hljs-string">&#x27;s/\&quot;(.*)\&quot;/\1/gp&#x27;</span>))<br>&#125;<br><br>main <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span><br></code></pre></div></td></tr></table></figure><p>这里，我们不再下载网页源码成单独一个文件，而是处理之后直接保存到一个变量（raw_html）中。最后把音、视频内容放到一个数组<code>va</code> 中。Shell 中的数组使用 <code>()</code>括起来。现在视频地址在 <code>va[0]</code>，音频地址在<code>va[1]</code>。</p><h2 id="下载音视频">下载音、视频</h2><p>下载音视频的方法比较简单：给 cURL 添加一个 <code>referer</code>然后就可以下载了，语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">curl --referer <span class="hljs-string">&quot;<span class="hljs-variable">$url</span>&quot;</span> --user-agent <span class="hljs-string">&quot;va[0]&quot;</span> --output <span class="hljs-string">&quot;视频.mp4&quot;</span><br>curl --referer <span class="hljs-string">&quot;<span class="hljs-variable">$url</span>&quot;</span> --user-agent <span class="hljs-string">&quot;va[1]&quot;</span> --output <span class="hljs-string">&quot;音频.mp4&quot;</span><br></code></pre></div></td></tr></table></figure><p>所以脚本现在是：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">  <span class="hljs-built_in">local</span> va=($(<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$raw_html</span>&quot;</span> | sed -nr <span class="hljs-variable">$reg_data</span> | jq <span class="hljs-string">&quot;<span class="hljs-variable">$reg_video_audio</span>&quot;</span> | sed -nr <span class="hljs-string">&#x27;s/\&quot;(.*)\&quot;/\1/gp&#x27;</span>))<br>  <span class="hljs-built_in">local</span> tempfile=$(mktmpfile) || <span class="hljs-built_in">exit</span> 1<br>  curl --referer <span class="hljs-string">&quot;<span class="hljs-variable">$url</span>&quot;</span> --user-agent <span class="hljs-string">&quot;va[0]&quot;</span> --output <span class="hljs-string">&quot;<span class="hljs-variable">$tmpfile</span>-video.mp4&quot;</span><br>  curl --referer <span class="hljs-string">&quot;<span class="hljs-variable">$url</span>&quot;</span> --user-agent <span class="hljs-string">&quot;va[1]&quot;</span> --output <span class="hljs-string">&quot;<span class="hljs-variable">$tmpfile</span>-audio.mp4&quot;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>其中 我们创建（mktmpfile）了一个临时文件（temporary file,tmpfile），并确保只有创建成功才执行下面的语句，否则退出（exit 1）。</p><p>然后我们把音、视频的文件名改为临时文件的文件名加 <code>video</code>和 <code>audio</code>等字样，这是防止文件名重复，导致多线程下载失败。</p><p>接下来就是合并我们的音、视频。不过我们还没有获取视频的标题——这里我直接给出获取视频标题的正则表达式：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">declare</span> -r reg_title=<span class="hljs-string">&#x27;s/.*&lt;h1 title=.*&gt;(.*)&lt;\/h1&gt;.*/\1/gp&#x27;</span><br><br><span class="hljs-comment"># 获取标题</span><br>title=<span class="hljs-string">&quot;<span class="hljs-subst">$(echo <span class="hljs-string">&quot;<span class="hljs-variable">$raw_html</span>&quot;</span> | sed -nr <span class="hljs-string">&quot;<span class="hljs-variable">$reg_title</span>&quot;</span>)</span>&quot;</span><br></code></pre></div></td></tr></table></figure><p>最后使用 FFmpeg 进行合并：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">ffmpeg -i <span class="hljs-string">&quot;<span class="hljs-variable">$tmpfile</span>-video.mp4&quot;</span> -i <span class="hljs-string">&quot;<span class="hljs-variable">$tmpfile</span>-audio.mp4&quot;</span> -c copy <span class="hljs-string">&quot;<span class="hljs-variable">$title</span>.mp4&quot;</span> -y -loglevel quiet<br></code></pre></div></td></tr></table></figure><p>FFmpeg 的参数介绍一下：</p><ol type="1"><li><code>-i</code> 是 <code>inputfile</code>的缩写，代表输入的文件，也就是要合并的文件。</li><li><code>-c</code> 是 <code>codec</code>的缩写，编码的方式——这里直接使用复制。</li><li><code>-y</code> 是 <code>yes</code>的缩写，其实就是直接覆盖文件，它会覆盖之前合并的文件，懒人专用。</li><li><code>-loglevel</code> 是日志打印的等级，这里是 <code>quiet</code>，也就是不打印任何日志。</li></ol><p>FFmpeg 不会用没关系，知道这么回事就行——我也不咋地使用这东东。</p><p>合并之后，做好把之前的文件删了，所以再写删除脚本执行过程中产生的文件。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">/bin/rm -r <span class="hljs-variable">$tmpfile</span> <span class="hljs-variable">$tmpfile</span>-audio.mp4 <span class="hljs-variable">$tmpfile</span>-video.mp4<br></code></pre></div></td></tr></table></figure><p>所以我们的脚本最现在是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash是">#!/bin/bash<br>set -euo pipefail<br><br># 获取内容的正则表达式，用于 sed<br>declare -r reg_data=&#x27;s/.*__playinfo__=(.*)&lt;\/script&gt;&lt;script&gt;.*/\1/gp&#x27;<br># 获取音、视频的正则，用于 jq<br>declare -r reg_video_audio=&#x27;.data.dash.video[0].baseUrl, .data.dash.audio[0].baseUrl&#x27;<br><br># 获取标题<br>declare -r reg_title=&#x27;s/.*&lt;h1 title=.*&gt;(.*)&lt;\/h1&gt;.*/\1/gp&#x27;<br><br># User-Agent 用于伪装成这成浏览器的请求——因为 B站 发现是脚本在下载视频就会阻止你下载。<br># 如果你伪装成浏览器，它就以为你使用浏览器，自然不会影响到它的利益，也就不管你下载多少<br># 视频了——毕竟你浏览越多，对它越好<br>declare -r user_agent=&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.116 Safari/537.36&#x27;<br><br>function main() &#123;<br><br>  # 这里把命令行第一个参数当作 URL<br>  declare url=&quot;$1&quot;<br><br>  # 获取原始 HTML 源文件，把输出输出到 /dev/null，同时使用 gzip 进行解压，解压的内容放到<br>  # raw_html 变量中<br>  local raw_html=$(curl --user-agent &quot;$user_agent&quot; &quot;$url&quot; 2&gt; /dev/null | gzip -d -)<br>local va=($(echo &quot;$raw_html&quot; | sed -nr $reg_data | jq &quot;$reg_video_audio&quot; | sed -nr &#x27;s/\&quot;(.*)\&quot;/\1/gp&#x27;))<br>  <br>  local tmpfile=$(mktemp) || exit 1<br>  curl --referer &quot;$url&quot; --user-agent &quot;$user_agent&quot; &quot;$&#123;va[0]&#125;&quot; --output &quot;$tmpfile-video.mp4&quot;<br>  curl --referer &quot;$url&quot; --user-agent &quot;$user_agent&quot; &quot;$&#123;va[1]&#125;&quot; --output &quot;$tmpfile-audio.mp4&quot;<br><br>  local title=&quot;$(echo &quot;$raw_html&quot; | sed -nr &quot;$reg_title&quot;)&quot;<br>  <br>  # 合并音、视频<br>  ffmpeg -i &quot;$tmpfile-video.mp4&quot; -i &quot;$tmpfile-audio.mp4&quot; -c copy &quot;$title.mp4&quot; -y -loglevel quiet<br>  <br>  # 删除脚本产生的文件爱你<br>  /bin/rm -r $tmpfile $tmpfile-audio.mp4 $tmpfile-video.mp4<br>&#125;<br><br>main &quot;$@&quot;<br></code></pre></div></td></tr></table></figure><p>至此脚本完成——非常简短。</p><h2 id="测试">测试</h2><p>写完不代表一定成功，我们需要测试下载</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">ls</span><br>bl.sh<br>$ <span class="hljs-built_in">chmod</span> u+x bl.sh <span class="hljs-comment"># 赋予脚本可执行权限</span><br>$ ./bl.sh <span class="hljs-string">&quot;https://www.bilibili.com/video/BV1Sg41137WR&quot;</span><br>https://www.bilibili.com/video/BV1Sg41137WR<br>  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current<br>                                 Dload  Upload   Total   Spent    Left  Speed<br>100 52.6M  100 52.6M    0     0  2945k      0  0:00:18  0:00:18 --:--:-- 2977k<br>  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current<br>                                 Dload  Upload   Total   Spent    Left  Speed<br>100 5059k  100 5059k    0     0  2936k      0  0:00:01  0:00:01 --:--:-- 2938k<br>$ <span class="hljs-built_in">ls</span><br> bl.sh  <span class="hljs-string">&#x27;【红楼梦】夜曲 宝玉.mp4&#x27;</span><br></code></pre></div></td></tr></table></figure><p>完工！到这里， B站 视频下载就算完工了。</p><h1 id="后语">后语</h1><p>简单来说，这次的教程不难，就是以下几个步骤：</p><ol type="1"><li>获取网页源码</li><li>分析源码，获取音、视频链接</li><li>下载音、视频</li><li>合并音视频</li></ol><p>知道了过程，使用其他编程语言也可以。使用 Shell脚本看起来确实不是很优雅，为此我在这里附上用 Python写的下载，不然简单的下载真的被我写的很难：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#!/bin/python3</span><br><span class="hljs-comment"># -*- conding:utf-8 -*-</span><br><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Please Waiting...&#x27;</span>, flush=<span class="hljs-literal">True</span>)<br>    <span class="hljs-comment"># 获取 URL</span><br>    url = sys.argv[<span class="hljs-number">1</span>]<br>    <span class="hljs-comment"># 设置 User-Agent</span><br>    headers = &#123;<br>        <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.116 Safari/537.36&#x27;</span><br>    &#125;<br><br>    <span class="hljs-comment"># 获取网页源码</span><br>    raw_html = requests.get(url, headers=headers)<br>    <span class="hljs-comment"># 视频标题</span><br>    title = re.search(<span class="hljs-string">&#x27;&lt;h1 title=.*&gt;(.*)&lt;/h1&gt;&#x27;</span>, raw_html.text).group(<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 获取目标数据，</span><br>    data = re.search(<span class="hljs-string">&#x27;__playinfo__=(.*?)&lt;/script&gt;&lt;script&gt;&#x27;</span>, raw_html.text).group(<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 把目标数据转化为 Python 可读的 JSON 格式</span><br>    json_data = json.loads(data)<br>    video_url = json_data[<span class="hljs-string">&#x27;data&#x27;</span>][<span class="hljs-string">&#x27;dash&#x27;</span>][<span class="hljs-string">&#x27;video&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;baseUrl&#x27;</span>]<br>    audio_url = json_data[<span class="hljs-string">&#x27;data&#x27;</span>][<span class="hljs-string">&#x27;dash&#x27;</span>][<span class="hljs-string">&#x27;audio&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;baseUrl&#x27;</span>]<br>    <br>    <span class="hljs-comment"># 设置 Referer</span><br>    headers.update(&#123;<span class="hljs-string">&#x27;Referer&#x27;</span>: url&#125;)<br><br>    <span class="hljs-comment"># 随即生成 1～100 作为基础文件名</span><br>    basefile_name = <span class="hljs-built_in">str</span>(random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>))<br>    <span class="hljs-comment"># 获取当前目录</span><br>    working_path = os.getcwd()<br>    <span class="hljs-comment"># 创建临时文件名，</span><br>    video_file = os.path.join(working_path, <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;basefile_name&#125;</span>-video.mp4&#x27;</span>)<br>    audio_file = os.path.join(working_path, <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;basefile_name&#125;</span>-audio.mp4&#x27;</span>)<br><br>    <span class="hljs-comment"># 下载视频和音频</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(video_file, <span class="hljs-string">&#x27;ab&#x27;</span>) <span class="hljs-keyword">as</span> video:<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">iter</span> <span class="hljs-keyword">in</span> requests.get(video_url, headers=headers).iter_content(<span class="hljs-number">1024</span>):<br>            video.write(<span class="hljs-built_in">iter</span>)<br><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(audio_file, <span class="hljs-string">&#x27;ab&#x27;</span>) <span class="hljs-keyword">as</span> audio:<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">iter</span> <span class="hljs-keyword">in</span> requests.get(audio_url, headers=headers).iter_content(<span class="hljs-number">1024</span>):<br>            audio.write(<span class="hljs-built_in">iter</span>)<br><br>    <span class="hljs-comment"># 调用 FFmpeg 进行合并</span><br>    os.system(<span class="hljs-string">f&#x27;ffmpeg -i <span class="hljs-subst">&#123;video_file&#125;</span> -i <span class="hljs-subst">&#123;audio_file&#125;</span> &quot;<span class="hljs-subst">&#123;title&#125;</span>.mp4&quot; -c copy -y -loglevel quiet&#x27;</span>)<br><br>    <span class="hljs-comment"># 删除创建的临时文件</span><br>    os.remove(video_file)<br>    os.remove(audio_file)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Download END...&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></div></td></tr></table></figure><p>Python 解析 JSON 非常慢，原本我写了一个进度条，结果发现解析 JSON就很慢了，进度条基本等于没用，所以这里就没有加上。</p><p>即使是 Python 也需要使用 FFmpeg。如果使用的是 Windows 系统，需要设置FFmpeg 的环境变量——或者把 <code>ffmpeg</code> 改为<code>ffmpeg 的路径</code> 也行。例如，我使用 Windows 系统，并且下载的FFmpeg 在 <code>C:\User\chunshuyumao\Downloads\ffmpeg.exe</code>，Python 脚本倒数第六行从</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">os.system(<span class="hljs-string">f&#x27;ffmpeg -i......&#x27;</span>)<br></code></pre></div></td></tr></table></figure><p>改为</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">os.system(<span class="hljs-string">f&#x27;C:\\User\\chunshuyumao\\Downloads\\ffmpeg.exe -i.....&#x27;</span>)<br></code></pre></div></td></tr></table></figure><p>如果觉得好玩——也许可以用用自己喜欢的语言实现一遍？</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>脚本</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GitHub 图床加速</title>
    <link href="/2022/05/23/GitHub-%E5%9B%BE%E5%BA%8A%E5%8A%A0%E9%80%9F/"/>
    <url>/2022/05/23/GitHub-%E5%9B%BE%E5%BA%8A%E5%8A%A0%E9%80%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>图床迁移到 GitHub 之后，我也面临 DNS 污染的问题。图片保存在 GitHub通常不会有什么问题，就是访问比较慢，国内如此。想要加速，我们就的使用 CDN加速。</p><p>CDN<ruby>（内容分发网络）<rt>Content Delivery Network</rt></ruby>尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。一句话总结，就是让距离最近的服务器响应请求，加快网络内容的传输。一般用于加速静态资源，如网站上面上传的图片、媒体等。</p><p>通常我们使用的是 <a href="https://www.jsdelivr.com/"title="JsDelivr">JsDelivr</a>，一个免费、可靠的 CDN加速。下面是官网，主页面直接放了大量的使用方法：</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/05/23/202205231714065.png"title="JsDelivr 官网主页" alt="JsDelivr 官网主页" /></p><h1 id="测试">测试</h1><p>首先找一张 GitHub 上的图片，我这里选了一张之前用过的 Zettlr官网的图片，地址是</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">https://raw.githubusercontent.com/chunshuyumao/202203bf/master/202203132034512.png<br>或者<br>https://github.com/chunshuyumao/202203bf/raw/master/202203132034512.png<br></code></pre></div></td></tr></table></figure><p>效果如下——一般是看不到下面的图片的，也不排除图片可以显示，只是加载比较慢。</p><p><imgsrc="https://raw.githubusercontent.com/chunshuyumao/202203bf/master/202203132034512.png"title="未加速前 Zettlr 官网图片" alt="未加速前 Zettlr 官网图片" /></p><p>要使用 CDN 加速，需要把地址改成下面的形式</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203132034512.png<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203132034512.png"title="JsDelivr 加速后的 Zettlr 编辑器官网主页图片"alt="JsDelivr 加速后的 Zettlr 编辑器官网主页图片" /></p><p>可以看到，要加速 GitHub 的图片，加速地址是这样的</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">https://cdn.jsdelivr.net/gh/github帐号名/仓库名@分支名/图片名<br></code></pre></div></td></tr></table></figure><p>其中，分支名一般是主分支，也就是 master 或者main，至于到底是哪个，要是看你的仓库的主分支。</p><h1 id="picgo-加速">PicGo 加速</h1><p>如果使用 GitHub 作为图床，建议配合 PicGo 使用。使用 PicGo，需要修改GitHub 的配置。打开 PicGo，转到 GitHub 设置，按照下面进行配置。</p><p>首先，分支名要写你的 GitHub 分支，我这里是 main分支。其次写自定义域名，格式和上面说的一样。这样，PicGo上传后会自动返回加速后的地址。</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">https://cdn.jsdelivr.net/gh/GitHub帐号/仓库名@分支名<br></code></pre></div></td></tr></table></figure><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/05/23/202205231727605.png"title="PicGo 中的 GitHub 设置" alt="PicGo 中的 GitHub 设置" /></p><h1 id="hexo-加速">Hexo 加速</h1><p><code>cdn.jsdelivr.net</code>加速也不一定完全可靠，比如前几天这个加速也样被污染了。<code>cdn.jsdelivr.net</code> 使用不了，我们可以改成<code>fastly.jsdelivr.net</code> 或者<code>gcore.jsdelivr.net</code>。如果使用 Hexo管理静态博客，我们可能需要修改博客中的图片地址。</p><p>如果不嫌麻烦，可以使用文本编辑器直接全局修改。例如在 Linux 系统上使用<ruby>SED（文件流编辑器）<rt>Stream Editor</rt></ruby>全局修改：首先转到博客源文件（Markdown文件）目录，然后输入修改代码。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> Docment/NotePages/source/_posts <span class="hljs-comment"># 进入源文件目录</span><br>$ <span class="hljs-built_in">ls</span> | xargs -i sed -i <span class="hljs-string">&#x27;s/cdn.jsdelivr.net/fastly.jsdelivr.net/g&#x27;</span> &#123;&#125; <span class="hljs-comment"># 修改文件内地址</span><br></code></pre></div></td></tr></table></figure><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/05/23/202205231740399.png"title="SED 批量修改地址" alt="SED 批量修改地址" /></p><p>如果是其他系统的用户，可以使用文件编辑器打开文件，然后使用全局修改。</p><p>不过这只是权宜之计，我希望还是使用 <code>cdn.jsdelivr.net</code>只是在它使用不了的时候再改成其他加速。既然如此，我们就需要借助其他工具了。</p><p><a href="https://hexo.fluid-dev.com/" title="Hexo Fluid 主题">HexoFluid 主题</a> 有<ahref="https://hexo.fluid-dev.com/posts/hexo-injector/"title="Fluid 主题注入功能">注入功能</a>，也就是下面用到的。如果想要真正了解该主题的注入功能，最好到<ahref="https://hexo.fluid-dev.com/posts/hexo-injector/"title="Fluid 主题注入功能">官网</a>查看。</p><p>然后上 GitHub 用户 <ahref="https://github.com/PipecraftNet/jsdelivr-auto-fallback"title="PipecraftNet">PipecraftNet</a> 的仓库下载<code>index.min.js</code> 或者 <code>index.js</code>文件，或者直接复制里边的内容。这位大佬写了一个自动检测加速有没有用的脚本，会给自己的博客自动替换更好的CDN 加速。</p><p>转到博客源文件根目录（也就是 source 目录），新建一个 js文件夹，把下载的 <code>index.js</code>文件放到里边，最好重命名。如果是直接复制内容，那就在 js文件夹中新建一个扩展名为 <code>js</code>的文件，把复制的内容粘贴到里边。</p><p>下面演示使用 axel 下载，并且重命名文件为<code>change_cdn.js</code>。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> Documents/NotePages/source <span class="hljs-comment"># 转到源文件根目录</span><br>$ tree -L 1 <span class="hljs-comment"># 查看是否有 js 文件夹，没有就新建</span><br>.<br>├── about<br>├── _drafts<br>└── _posts<br><br>3 directories, 0 files<br>$ <span class="hljs-built_in">mkdir</span> js <span class="hljs-comment"># 新建 js 文件夹</span><br>$ tree -L 1<br>.<br>├── about<br>├── _drafts<br>├── js<br>└── _posts<br><br>4 directories, 0 files<br>$ <span class="hljs-built_in">cd</span> js<br>$ axel https://github.91chi.fun/https://raw.githubusercontent.com/PipecraftNet/jsdelivr-auto-fallback/main/index.js -o change_cdn.js<br></code></pre></div></td></tr></table></figure><p>下载完之后，转到 Hexo 博客根目录，在根目录下创建一个<code>scripts</code> 文件夹，在里边创建一个名为 <code>insert.js</code>的文件（文件名随便取）。将后面的代码复制到 <code>insert.js</code>文件内。<code>src</code> 后面写的是刚刚下载的文件的文件名，我的是<code>change_cdn.js</code>。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> ~/Documents/NotesPage<br>$ <span class="hljs-built_in">mkdir</span> scripts<br>$ vim scripts/insert.js<br><br>hexo.extend.injector.register(<span class="hljs-string">&#x27;head_begin&#x27;</span>, <span class="hljs-string">&#x27;&lt;script defer src=&quot;/js/change_cdn.js&quot;&gt;&lt;/script&gt;&#x27;</span>, <span class="hljs-string">&#x27;default&#x27;</span>);<br></code></pre></div></td></tr></table></figure><p>保存退出，完成脚本的注入了。</p><p>输入 <code>hexo clean &amp;&amp; hexo g -d</code>进行博客部署，脚本会自己判断哪一个 CDN更好用，然后自动修改。当然，这个只对博客的展示产生影响，不会直接修改你的博客内容。</p><h1 id="后语">后语</h1><p>好像 <code>cdn.jsdelivr.net</code>加速又可以访问了，其实已经卡了好几天了。</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图床</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么要捉弄ta...</title>
    <link href="/2022/05/19/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%8D%89%E5%BC%84ta/"/>
    <url>/2022/05/19/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%8D%89%E5%BC%84ta/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>相比欧亨利，契科夫的小说少有让我记住。现在记得最清楚，还是改变了我对契科夫看法的《捉弄》。《捉弄》是一篇非常短的小说，但是看完之后，你却希望它可以长一点。</p><p>今天先闲来无事，感觉可以搬过来分享。看完之后可以想想契科夫是不是又双叒叕讽刺了哪个黑暗的世界。</p><h1 id="正文">正文</h1><p>那是深冬的一个正午，太阳高挂在天空，射出冷冰冰的光线……真是冷得很，树干被冻得崩裂而喀喀作响。卡娜佳挽着我的胳膊，她脸颊上金色的绒毛附着着薄薄的银霜。</p><p>我们俩站在一座高山上，脚下就是一片积雪的斜坡，在阳光下的照耀下，像镜子一样记录着遥远的璀璨，在我们身边放着一副小小的轻便雪橇，蒙着红色的天鹅绒布——这便是我记忆里那天开始的样子。</p><p>“卡娜佳！我们好不容易上来的，跟我滑一次吧，一切都准备好了。”我双手扶着她的肩膀央求她“就一次！我发誓，你和我都会完整无缺的，不会出意外的！”</p><p>我看得出娜佳还是怕极了，从她小小的个子往下俯瞰，雪坡就像一个深不可测的可怕地穴，时刻都要将她吞噬一般。我拉着她把她拉进雪橇，她往下看了一眼，狠狠地吸了一口冷气，噎在喉头。她真的要冒险飞向深渊吗？会有危险吗？想到这里，她吓死了，吓疯了。</p><p>“求你啦！”我又说，“用不着害怕！你要相信我，你只是缺少决心，别怕了！”</p><p>娜佳最后还是让步了，不过看她脸色我知道，她是抱着有可能死掉的危险做出让步的，我扶着她坐在小雪橇上，一手搂着这个小小个子脸色惨白、浑身打颤的姑娘，准备跟她一道跌入深渊。</p><p>雪橇像出了膛的子弹，滑开空气向深渊飞去，耳边的风怒吼着，凶狠的撕扯我们的衣帽，像刀割一样刺痛着我们的脸颊，像要一把将你肩头的脑袋揪下。在巨大的风压下，我们变得难以呼吸，就像恶魔紧紧的扼住了我们脖子，愤怒着叫嚷着要把我们拖入地狱。四周的景物汇成了一条长长的一闪而过的飘带……那时我只有一个念头，下一秒我们就要粉身碎骨了！</p><p>“我爱你，娜佳！”我小声说。</p><p>雪橇滑得越来越平缓，风的吼声和滑木的沙沙声已经不那么可怕了，呼吸也不再困难，我们终于滑到了山脚下。可是卡娜佳已经半死不活。她脸色煞白，奄奄一息……</p><p>我帮她站起身来。</p><p>“骗子，下一回说什么也不滑了，”她睁大一双布满恐惧的眼睛望着我说，“一辈子也不滑了！差点没把我吓死！一辈子也不信你了！”</p><p>过了一会，她渐渐缓过神，开始用一种试探怀疑的眼神看我，好像在说：那句话是我说的吗？或者仅仅是旋风的呼啸让她产生了幻听？虽然我看见了她的眼神，但我还是假装检查我的手套，站她身边若无其事的抽着烟。</p><p>她又挽起我的胳膊，我们在山下玩了很久。但那个谜显然搅得她心神不宁。他到底说了没说？说了还是没有？那句话是他说的吗？这些问题反复出现在她脑子里，这可太重要了，这事关她的自尊心、未来、生命和幸福的问题，是非常非常重要的问题，这世上第一等重要的问题！</p><p>卡娜佳不厌其烦地用那种忧郁、困惑、识图看穿我的眼神打量着我，除此之外什么也思考不了，胡乱回答着我的问题，等着我会不会再说出那句话，或者露出什么马脚。</p><p>唉，那张可爱的小脸呀，那表情是多么丰富，多么可怜！我看得出，她竭力控制住自己，想好好的质问一下我，问我有没有说那句话，但她找不到词句，怕是自己多情了，她别扭坏了，焦急的不行。</p><p>“那个，有个事情……”她说，眼睛没有看我。</p><p>“什么？”我问。</p><p>“让我们再……再滑一次雪橇。”</p><p>于是我们沿着阶梯拾级而上。我再一次扶着脸色苍白、浑身打颤的娜佳坐上雪橇，我们再一次飞向恐怖的深渊，再一次听到风的呼啸，滑木的沙沙声，而且在雪橇飞得最快、风声最大的时刻，我再一次小声说：</p><p>“我爱你，娜佳！”</p><p>雪橇终于停住，卡娜佳立即回头观看我们刚刚滑下来的山坡，随后久久地审视着我的脸，倾听着我那无动于衷、毫无热情的声音，于是她整个人，浑身上下，连她的皮手笼和围巾、帽子在内，无不流露出极度的困惑。她的脸上分明写着：</p><p>“怎么回事？那句话到底是谁说的？是他，还是我听错了？”</p><p>这个疑团弄得她心神不定，失去了耐心。可怜的姑娘不回答我的问话，愁眉苦脸，眼看着就要哭出来了。</p><p>“我们是不是该回家了？”我故意问她。</p><p>“可是我……我喜欢这样滑雪，”她涨红着脸说，“我们再滑一次好吗？”</p><p>虽说她“喜欢”这样滑雪，可是，当她坐上雪橇时，跟前两次一样，她依旧脸色苍白，吓得透不过气来，浑身直打哆嗦。</p><p>我们第三次飞身滑下，我看到，她一直盯着我的脸，注视着我的嘴唇。可是我用围巾挡住嘴，咳嗽一声，正当我们滑到半山腰时，我又小声说了一句：</p><p>“我爱你，娜佳！”</p><p>结果谜依旧是谜！卡娜佳默默不语，想着心事……我从冰场把她送回家，她尽量不出声地走着，放慢脚步，一直期待着我会不会对她再说那句话。我看得出来，她的内心怎样受着煎熬，又怎样竭力克制自己，免得说出：</p><p>“这句话不可能是风说的！我也不希望是风说的！”</p><p>第二天上午，我收到一张便条：“如果您今天还去冰场，请顺便来叫我一声——娜。”从此以后，我和卡娜佳几乎天天都去滑雪。当我们坐着雪橇滑下坡时，每一次我总是小声说出那句话：</p><p>“我爱你，娜佳！”</p><p>很快卡娜佳对这句话就听上瘾了，就像人对喝酒、抽烟能上瘾一样。现在缺了这句话她就没法生活了。当然，从山顶上飞身滑下依旧令人胆战心惊，可是此刻的恐惧和危险，反给那句表白爱情的话平添一种特殊的魅力，尽管这句话依旧是个谜，依旧折磨着她的心。受到怀疑的依旧是我和风……这二者中究竟谁向她诉说了爱情，她不知道，但后来她显然已经不在乎了——只要喝醉了就成，管它用什么样的杯子喝的呢！</p><p>一天中午，我独自一人去了冰场。我混在拥挤的人群中，突然发现卡娜佳正朝山脚下走去，东张西望地在寻找我……后来她畏畏缩缩地顺着阶梯往上走……一个人滑下来是很可怕的，唉呀，可怕极了！她脸色白得像雪，战战兢兢地走着，倒像赴刑场一般，但还是走着，头也不回，坚决地走着。</p><p>她显然打定主意，最后要试一试，身边没有我的时候，还能不能听到那句美妙而甜蜜的话？我看到她脸色苍白，吓得张着嘴，坐上雪橇，闭上眼睛，像向人世告别似的滑下去……“沙沙沙”……滑木发出响声。我不知道卡娜佳是否听到了那句话，我只看到，她从雪橇上站起来时已经摇摇晃晃、有气无力了。看她的脸色可知，连她自己也不知道究竟听到什么没有，她一人滑下时的恐惧夺走了她的听觉，她已经丧失了辨别声音和理解的能力。</p><p>眼看着早春三月已经来临……阳光变得暖和起来。我们那座冰山渐渐发黑，失去了原有的光彩，最后冰雪都化了。我们也不再去滑雪。可怜的卡娜佳再也听不到那句话，何况也没人对她说了，因为这时已听不到风声，而我正要动身去彼得堡——要去很久，也许一去不复返了。</p><p>有一回，大约在我动身的前两天，薄暮中我坐在小花园里，这花园同娜佳居住的那个院子只隔着一道带钉子的高板墙……天气还相当冷，畜粪下面还有积雪，树木萧条，但已经透出春天的气息，一群白嘴鸦大声贴噪，忙着找旧枝宿夜。</p><p>我走到板墙跟前，从板缝里一直往里张望。我看到卡娜佳走出门来，站在台阶上，抬起悲凉伤感的目光望着天空……春风吹拂着她那苍白忧郁的脸……这风勾起她的回忆；昔日，在半山腰，正是在呼啸的风声中她听到了那句话。于是她的脸色变得越来越忧郁，两行眼泪夺眶而出……可怜的姑娘张开臂膀，似乎在央求春风再一次给她送来那句话。我等着一阵风刮过去，小声说：</p><p>“我爱你，娜佳！”</p><p>我的天哪，卡娜佳一下子像换了一个人！她一声欢呼，笑开了脸，迎着风张开臂膀，那么高兴，幸福，她真是美丽极了。</p><p>随后我走开了，回去收拾行装……</p><p>这已是很久以前的事了。如今卡娜佳已经出嫁。究竟是出于父母之命，还是她本人的意愿，如今已经无关紧要，她嫁给了贵族监护会的一名秘书，现在已经有了三个孩子。想当年，我们一块儿滑雪，那风送到她耳畔一句话：</p><p>“我爱你，娜佳！”</p><p>这段回忆是永生难忘的。对她来说，这是一生中最幸福、最动人、最美好的回忆……</p><p>如今我也上了年纪，已经不明白，为什么当初我说了那句话，为什么要捉弄她……</p><p>一八八六年三月十二日</p><h1 id="后话">后话</h1><p>我一直觉得，男生和女生是两个矛盾体，就像磁铁的正负极，也许柏拉图是对的？看完《捉弄》，如果你也觉得有点短，我可以给你描绘描绘你捉弄的那个Ta：</p><p>男生看：</p><blockquote><p>淑景斗清明，和风拂面轻。</p><p>小杯盘、同集郊坰。</p><p>著个簥儿不肯上，须索要、大家行。</p><p>行步渐轻盈。行行笑语频。</p><p>凤鞋儿、微褪些根。</p><p>忽地倚人陪笑道，真个是、脚儿疼。</p></blockquote><p>辛弃疾大佬的《唐(糖)多令》</p><p>女生看：</p><blockquote><p>昨夜海棠初着雨，数朵轻盈娇欲语。</p><p>佳人晓起出兰房，折来对镜比红妆。</p><p>问郎花好奴颜好，郎道不如花窈窕。</p><p>佳人见话发娇嗔，不信死花胜活人。</p><p>将花揉碎掷郎前，请郎今夜伴花眠。</p></blockquote><p>唐寅大佬的《妒花歌》。</p><p>东坡大佬《赏心十六事》镇文：</p><blockquote><p>清溪浅水行舟，微雨竹窗夜话。</p><p>暑至临溪濯足，雨后登楼看山。</p><p>柳荫堤畔闲行，花坞樽前微笑。</p><p>隔江山寺闻钟，月下东邻吹箫。</p><p>晨兴半柱茗香，午倦一方藤枕。</p><p>开瓮忽逢陶谢，接客不着衣冠。</p><p>乞得名花盛开，飞来家禽自语。</p><p>客至汲泉烹茶，抚琴听者知音。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>契科夫</tag>
      
      <tag>捉弄</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zettlr 编辑器部分功能优化——网页元素及时渲染</title>
    <link href="/2022/05/12/Zettlr-%E7%BC%96%E8%BE%91%E5%99%A8%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94%E7%BD%91%E9%A1%B5%E5%85%83%E7%B4%A0%E5%8F%8A%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    <url>/2022/05/12/Zettlr-%E7%BC%96%E8%BE%91%E5%99%A8%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94%E7%BD%91%E9%A1%B5%E5%85%83%E7%B4%A0%E5%8F%8A%E6%97%B6%E6%B8%B2%E6%9F%93/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p><ruby>Zettlr<rt>/ˈsetlər/</rt></ruby>服务的是写作者和科研工作者，这类受众通常不会使用花里胡哨的东西，所以 <ahref="https://zettlr.com" title="Zettlr">Zettlr</a>减少了很多方面的扩展。举个例子，在 Zettlr 中使用<ruby>HTML（超文本标记语言）<rt>HyperText MarkupLanguage</rt></ruby>的标签不会得到渲染，你输入<code>&lt;button&gt;这是一个按钮&lt;/button&gt;</code>，它会原样输出。</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/05/12/202205122125084.png"title="原生 Zettlr" alt="原生 Zettlr" /></p><p>写博客的时候时不时会使用到英文简写（一般不大适合使用中文），这时候我会给英文简写做个备注，比如把简写的原文写下。按理来说，原文应该使用括号写出，但是英文原文太长会影响排版，因此我会选择使用<code>&lt;ruby&gt;</code>标签把原文写在简写和中文的上方，减少页面占用。这种时候 Zettlr不渲染就会显得比较难看。</p><p>因此很早之前我就考虑修改 Zettlr，自己渲染网页元素。可惜，我没接触过<a href="https://www.electronjs.org/" title="Electron">Electron</a>开发，不了解这种应用的基本运行框架，而 Zettlr 就是用 Electron开发的。</p><p>前一阵子对 Zettlr的部分功能进行了优化，感觉自己可以再试试，搞不好可以实现自己很久以来的想法。于是今天下午花了点时候，大概摸清Zettlr渲染的部分代码，然后就直接动手，想不到还真的让我这只瞎猫碰到了死耗子！</p><p>修改代码之后，现在自己编译的 Zettlr已经可以渲染网页标签——还可以自定义标签，当然是在<ruby>资源管理<rt>AssetManager</rt></ruby>中配置自定义的 <ruby>CSS（层叠样式表）<rt>CascadingStyle Sheets</rt></ruby>。</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/05/12/202205122138784.png"title="改造后的 Zettlr" alt="改造后的 Zettlr" /></p><h1 id="修改">修改</h1><p>和上次的一样准备 Zettlr源码，建议直接使用上一次的，免得还得把之前的修改放进来。要修改的文件位置在Zettlr 源码根目录下的</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">source</span>/common/modules/markdown-editor/hooks/render-elements.ts<br></code></pre></div></td></tr></table></figure><p>使用你习惯的编辑器打开这个 TypeScripts 文件。</p><p>首先在开头从 <code>can-render-element</code> 文件引入<code>canRenderElement</code> 函数。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">import canRenderElement from <span class="hljs-string">&#x27;../plugins/util/can-render-element&#x27;</span><br></code></pre></div></td></tr></table></figure><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/05/12/202205122141485.png"title="引入需要的函数" alt="引入需要的函数" /></p><p>接下来在 <code>renderElements</code> 函数的最后调用<code>renderElems</code> 函数，函数是我们要写的，所以不用担心。</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/05/12/202205122144351.png"title="调用添加的渲染" alt="调用添加的渲染" /></p><p>在 <code>renderElememts</code> 上方写一个函数，叫做<code>renderElems</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">// 这是我们的函数<br><span class="hljs-keyword">function</span> renderElems (cm: CodeMirror.Editor): void &#123;<br><br>  // 获取视图，里面包含编辑器的原始文本<br>  const viewport = cm.getViewport()<br>  // 按行读取文本<br>  <span class="hljs-keyword">for</span> (<span class="hljs-built_in">let</span> i = viewport.from; i &lt; viewport.to; i++) &#123;<br>  // 无关的内容不用渲染<br>    <span class="hljs-keyword">if</span> (cm.getModeAt(&#123; <span class="hljs-string">&#x27;line&#x27;</span>: i, <span class="hljs-string">&#x27;ch&#x27;</span>: 0 &#125;).name !== <span class="hljs-string">&#x27;markdown-zkn&#x27;</span>) <span class="hljs-built_in">continue</span><br><br>    const line = cm.getLine(i)<br>    // 正则表达式获取标签名和内容<br>    <span class="hljs-keyword">for</span>(const match of line.matchAll(/&lt;\b([^&gt;]+)&gt;(.*?)&lt;\/\1\b&gt;/g)) &#123;<br><br>      const curFrom = &#123; <span class="hljs-string">&#x27;line&#x27;</span>: i, <span class="hljs-string">&#x27;ch&#x27;</span>: match.index as number &#125;<br>      const curTo = &#123; <span class="hljs-string">&#x27;line&#x27;</span>: i, <span class="hljs-string">&#x27;ch&#x27;</span>: match.index as number + match[0].length &#125;<br>     // 判断是否该渲染。这里需要注意不能落下，因为当你的鼠标靠近标签的时候不该渲染<br>     <span class="hljs-keyword">if</span> (!canRenderElement(cm, curFrom, &#123; line: curTo.line, ch: curTo.ch + 1 &#125;)) &#123;<br>       <span class="hljs-built_in">continue</span><br>     &#125;<br><br>      // 通过标签名创造一个标签<br>      const tag = document.createElement(match[1])<br>      tag.innerHTML = match[2];<br><br>      // 这个用于用于标记标签元素是否该被渲染<br>      const marker = cm.markText(<br>        curFrom, curTo, &#123;<br>          <span class="hljs-string">&#x27;clearOnEnter&#x27;</span>: <span class="hljs-literal">true</span>,<br>          <span class="hljs-string">&#x27;replacedWith&#x27;</span>: tag,<br>          <span class="hljs-string">&#x27;inclusiveLeft&#x27;</span>: <span class="hljs-literal">false</span>,<br>          <span class="hljs-string">&#x27;inclusiveRight&#x27;</span>: <span class="hljs-literal">false</span><br>         &#125;)<br>      // 因为已经渲染了标签，所以广播编辑器修改元素所占的位置<br>      marker.changed() // Notify CodeMirror of the potentially updated size<br> <br>      // 如果鼠标点击，或者光标靠近标签，就清除渲染的标签，回归原来的状态<br>      tag.onclick = (e) =&gt; &#123;<br>        marker.clear()<br>        cm.setCursor(cm.coordsChar(&#123; left: e.clientX, top: e.clientY &#125;))<br>        cm.focus()<br>       &#125;<br>     &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment"># 下面是原有的 renderElements 函数</span><br><span class="hljs-keyword">function</span> renderElements (cm: CodeMirror.Editor): void &#123;<br>...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>现在只需要重新编译就可以实现网页标签的渲染了，上一篇博客介绍过怎么编译。</p><h1 id="后语">后语</h1><p>修改完 Zettlr 之后，我如愿彻底离开 Typora 了。不过说来，Typora 在Manjaro 居然有 200M 以上，远比 Zettlr（112M）大。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zettlr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zettlr 编辑器部分功能优化</title>
    <link href="/2022/05/10/Zettlr-%E7%BC%96%E8%BE%91%E5%99%A8%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2022/05/10/Zettlr-%E7%BC%96%E8%BE%91%E5%99%A8%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>因为 Zettlr 编辑器支持在 Markdown 下的文献引用，自己逐步从 Tyopra转向 Zettlr。和 Tyopra 比，Zettlr 的体验确实不是很好。此外，Zettlr还存在图片默认左对齐、文章字数统计对中英文支持不好等问题。</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/05/09/202205100936007.png"title="图片左对齐，中英文（右上角）混合统计有问题。按理来说统计有 4 千字，这里的统计接近 8 千字。"alt="图片左对齐，中英文（右上角）混合统计有问题。按理来说统计有 4 千字，这里的统计接近 8 千字。" /></p><p>我希望的是图片可以默认居中对齐，然后中英文混输的字数统计可以准确一点。前者可以通过自定义<ruby>CSS（层叠样式表）<rt>Cascading Style Sheets</rt></ruby>进行修改，后者只能修改源码了。</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/05/09/202205100942279.png"title="修改后的效果" alt="修改后的效果" /></p><p>既然要修改源码，索性一并修改 <ruby>CSS（层叠样式表）<rt>CascadingStyle Sheets</rt></ruby> 的源码。因此这就是接下来的工作。接下来的修改在Zettlr 2.2.5 和 2.2.6（最新版）版本都是通用的。以后的版本可能在代码上有所不同，但本修改应该仍然起作用。由于是自己修改源码，每次发布新版的时候都需要手动修改。一个好的解决办法是给GitHub 上的维护着提个 issue或者直接拉取分支和人家一起干（这不是我该干的）。</p><h1 id="开工">开工</h1><p>开始之后需要你的电脑安装这几样东西：</p><ol type="1"><li><a href="https://nodejs.cn" title="Node.js">Node.js</a>，让JavaScript 脱离浏览器。版本什么其实不重要，不要太旧就行。Linux发行版一般可以通过命令行安装，例如我的 Manjaro：<code>sudo pacman -S nodejs --noconfirm</code>。</li><li><a href="https://www.yarnpkg.cn" title="Yarn">Yarn</a>，JavaScript软管理包，用于拉取源码所需的各个包。Linux发行版一般可以通过命令行安装，例如我的Manjaro：<code>sudo pacman -S yarn --noconfirm</code>。</li><li><a href="https://git-scm.com"title="Git">Git</a>，分布式版本管理系统，用于从 GitHub 拉取 Zettlr源码。这个是可选的——因为可以直接从 GitHub 上下载源码，不一定通过 Git拉取。</li></ol><p>Windows 系统需要到官网下载，当然，如果你使用 <ahref="https://chocolatey.org" title="Chocolatey">Chocolatey</a> 等Windows下的包管理器的话也可以选择直接使用这个管理器下载——据我所知，这个包管理器现在已经包含了许多的软件。</p><h2 id="获取-zettlr-源码">获取 Zettlr 源码</h2><p>获取 Zettlr 源码有两种方式，分别是 Git 拉取和 GitHub 直接下载。</p><ol type="1"><li>Git 拉取。</li></ol><p>首先创建一个文件夹用于保存 Zettlr 源码，随便取个名字，这里就叫做Shr2hst。进入文件夹中，并通过<ruby>克隆<rt>clone</rt></ruby>指令拉取源码。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">mkdir</span> ~/Shr2hst &amp;&amp; <span class="hljs-built_in">cd</span> ~/Shr2hst<br>$ git <span class="hljs-built_in">clone</span> https://github.com/zettlr/zettlr<br>Cloning into <span class="hljs-string">&#x27;zettlr&#x27;</span>...<br>remote: Enumerating objects: 47557, <span class="hljs-keyword">done</span>.<br>remote: Counting objects: 100% (3/3), <span class="hljs-keyword">done</span>.<br>remote: Compressing objects: 100% (3/3), <span class="hljs-keyword">done</span>.<br>remote: Total 47557 (delta 0), reused 0 (delta 0), pack-reused 47554<br>Receiving objects: 100% (47557/47557), 105.81 MiB | 1.88 MiB/s, <span class="hljs-keyword">done</span>.<br>Resolving deltas: 100% (36147/36147), <span class="hljs-keyword">done</span>.<br>$ <span class="hljs-built_in">ls</span><br>zettlr<br>$ <span class="hljs-built_in">cd</span> zettlr<br>$ <span class="hljs-built_in">ls</span><br>CHANGELOG.md          forge.config.js  scripts      tsconfig.json<br>CITATION.cff          LICENSE          SECURITY.md  webpack.main.config.js<br>CODE_OF_CONDUCT.md    package.json     <span class="hljs-built_in">source</span>       webpack.renderer.config.js<br>CONTRIBUTING.md       README.md        static       webpack.rules.js<br>electron-builder.yml  resources        <span class="hljs-built_in">test</span>         yarn.lock<br></code></pre></div></td></tr></table></figure><p>这个操作一般会比较慢——国内一直比较慢，所以需要耐心。进入 Zettlr文件夹之后可以看到许多的文件，其中 source文件夹就是我们的源码所在的位置。</p><ol start="2" type="1"><li>GitHub 下载压缩包。</li></ol><p>打开浏览器，输入 <code>https://github.com/zettlr/zettlr</code> 进入GitHub 界面，选择 Code 中的 Download ZIP 进行下载。</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/05/09/202205101008484.png" /></p><p>下载完成之后可以进行解压。在 Windows，随便使用一个压缩软件就可以解压。在 Linux 中可以使用 unzip命令解压，效果如下。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ unzip Zettlr-develop.zip<br>$ <span class="hljs-built_in">ls</span><br>Zettlr-develop  Zettlr-develop.zip<br>$ <span class="hljs-built_in">cd</span> Zettlr-develop<br>$ <span class="hljs-built_in">ls</span><br>CHANGELOG.md          forge.config.js  scripts      tsconfig.json<br>CITATION.cff          LICENSE          SECURITY.md  webpack.main.config.js<br>CODE_OF_CONDUCT.md    package.json     <span class="hljs-built_in">source</span>       webpack.renderer.config.js<br>CONTRIBUTING.md       README.md        static       webpack.rules.js<br>electron-builder.yml  resources        <span class="hljs-built_in">test</span>         yarn.lock<br></code></pre></div></td></tr></table></figure><h2 id="字数统计">字数统计</h2><p>首先修改我们的最初目标中英文混合的字数统计。这是一个 TypeScript文件，位于 source/common/util/count-words.ts。</p><p>Windows用户，建议通过文件管理找到这个文件，然后使用你喜欢的编辑器打开。 Linux用户可以在命令行上输入<code>vim source/common/util/count-words.ts</code>直接打开文件进行修改。</p><p>转到最后一行，把 44 到49行的代码删掉或注释掉，在后面添加以下代码。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">content = content.replace(/(\r\n+|\s+| +)/g, <span class="hljs-string">&quot;𰻝&quot;</span>);<br>content = content.replace(/[\x00-\xff]/g, <span class="hljs-string">&quot;w&quot;</span>);<br>content = content.replace(/w+/g, <span class="hljs-string">&quot;*&quot;</span>);<br>content = content.replace(/𰻝+/g, <span class="hljs-string">&quot;&quot;</span>);<br></code></pre></div></td></tr></table></figure><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/05/09/202205101026625.png"title="未更改" alt="未更改" /></p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/05/09/202205101030724.png"title="更改后" alt="更改后" /></p><p>保存退出。这几行代码的统计方式虽然原始，但是十分高效——和 Word、WPSWord的统计基本是一样的。代码里的“<ruby>𰻝<rt>biáng</rt></ruby>”字如果打不出来可以使用其他生僻字代替，例如“<ruby>龘<rt>dá</rt></ruby>”“<ruby>爨<rt>cuàn</rt></ruby>”“<ruby>厶<rt>sī</rt></ruby>”“<ruby>鬱<rt>yù</rt></ruby>”“<ruby>𣊧<rt>lǎng</rt></ruby>”等等。其实上面的统计很简单，大概意思是：先将空格符、回车符、换行符换成一个生僻字，然后将拉丁字母替换成w ，在把以生僻字隔离的一个至多个 w 替换成 *，然后减去生僻字就是所有的字数了。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 举个例子，看下面的文字</span><br>我 Wǒ 是 shì 爱 aì 南 nán 开 kāi 的 de 。<br>俺也一样。<br><span class="hljs-comment"># 替换后</span><br>我𰻝Wǒ𰻝是𰻝shì𰻝爱𰻝aì𰻝南𰻝nán𰻝开𰻝kāi𰻝的𰻝de𰻝。𰻝俺也一样。𰻝<br><span class="hljs-comment"># 替换拉丁字母</span><br>我𰻝ww𰻝是𰻝www𰻝爱𰻝ww𰻝南𰻝www𰻝开𰻝www𰻝的𰻝w𰻝。𰻝俺也一样。𰻝<br><span class="hljs-comment"># 去掉拉丁字母</span><br>我𰻝*𰻝是𰻝*𰻝爱𰻝*𰻝南𰻝*𰻝开𰻝*𰻝的𰻝*𰻝。𰻝俺也一样。𰻝<br><span class="hljs-comment"># 去掉生僻字</span><br><span class="hljs-comment"># 1 2 3  4 5 6 7 8 9 10 11 12 13 14 15 16 17 18</span><br> 我 * 是 * 爱* 南* 开*  的 *  。 俺 也 一 样 。 <br></code></pre></div></td></tr></table></figure><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/05/10/202205101207897.png"alt="以防出现方框" /></p><h2 id="图片居中">图片居中</h2><p>图片居中的源码位于 source/common/modules/markdown-editor/editor.less文件中，使用任意文本编辑器打开。转到 217 行——或者慢慢找也行。在 figture里边的 img 添加<code>margin: 0 auto;</code>，表示居中对齐。保存退出。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ vim <span class="hljs-built_in">source</span>/common/modules/markdown-editor/editor.less<br></code></pre></div></td></tr></table></figure><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/05/09/202205101049346.png"title="未修改" alt="未修改" /></p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/05/09/202205101050726.png"title="修改后" alt="修改后" /></p><p>这一部分是前端知识，知道这么回事就行。</p><h1 id="编译">编译</h1><p>编译之前下载依赖包，执行一下命令。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ yarn install --frozen-lockfile<br></code></pre></div></td></tr></table></figure><p>确认安装完依赖包之后就可以进行编译。</p><p>编译选项包括：</p><ul><li><code>package:mac-x64</code> (Intel-based Macs)</li><li><code>package:mac-arm</code> (Apple Silicon-based Macs)</li><li><code>package:win-x64</code> (Intel-based Windows)</li><li><code>package:win-arm</code> (ARM-based Windows)</li><li><code>package:linux-x64</code> (Intel-based Linux)</li><li><code>package:linux-arm</code> (ARM-based Linux)</li></ul><p>如果不知道自己的系统是啥构架，直接使用 <code>yarn package</code>就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ yarn package:linux-x64 <span class="hljs-comment"># 这个是编译 Linux 的包</span><br>✔ Checking your system<br>✔ Preparing native dependencies<br>✔ Compiling Main Process Code<br>✔ Compiling Renderer Template<br>✔ Compiling Renderer Preload: main_window<br>✔ Compiling Renderer Preload: <span class="hljs-built_in">print</span><br>✔ Compiling Renderer Preload: log_viewer<br>✔ Compiling Renderer Preload: quicklook<br>✔ Compiling Renderer Preload: preferences<br>✔ Compiling Renderer Preload: tag_manager<br>✔ Compiling Renderer Preload: paste_image<br>✔ Compiling Renderer Preload: error<br>✔ Compiling Renderer Preload: about<br>✔ Compiling Renderer Preload: stats<br>✔ Compiling Renderer Preload: assets<br>✔ Compiling Renderer Preload: update<br>✔ Compiling Renderer Preload: project_properties<br>✔ Preparing to Package Application <span class="hljs-keyword">for</span> <span class="hljs-built_in">arch</span>: x64<br>✔ Preparing native dependencies<br>✔ Packaging Application<br>Done <span class="hljs-keyword">in</span> 236.96s.<br></code></pre></div></td></tr></table></figure><p>编译完成，接下来就是打包。</p><p>打包选项包括：</p><ul><li><code>release:mac-x64</code> (Intel-based Macs)</li><li><code>release:mac-arm</code> (Apple Silicon-based Macs)</li><li><code>release:win-x64</code> (Intel-based Windows)</li><li><code>release:win-arm</code> (ARM-based Windows)</li><li><code>release:linux-x64</code> (Intel-based Linux)</li><li><code>release:linux-arm</code> (ARM-based Linux)</li></ul><p>Linux 系统打包会生成多个安装包，如 deb、rpm、zip 和Appimage。这个过程可能还会失败。由于 Appimage 包是公用包，几乎所有的Linux系统都可以使用，所以我建议按照这个来打包。好处是通用、简单，缺点是有点大。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ yarn release:linux-x64 <span class="hljs-comment"># 生成所有预定义的包</span><br>$ yarn electron-builder --linux AppImage --x64 --publish never --prepackaged out/Zettlr-linux-x64 <span class="hljs-comment"># 只生成 Appimage包</span><br>  • electron-builder  version=23.0.3 os=5.15.32-1-MANJARO<br>  • loaded configuration  file=/root/Shr2hst/zettlr/electron-builder.yml<br>  • writing effective config  file=release/builder-effective-config.yaml<br>  • building        target=AppImage <span class="hljs-built_in">arch</span>=x64 file=release/Zettlr-2.2.6-x86_64.AppImage<br>Done <span class="hljs-keyword">in</span> 8.78s.<br></code></pre></div></td></tr></table></figure><p>打包完成后，所有的包都在 Zettlr 根目录下的 release 文件夹中。Windows系统可以直接运行安装。Linux 系统的 Appimage 包还有点事要做。</p><h1 id="appimage-包">Appimage 包</h1><p>首先赋予 Appimage 包可执行权限。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">chmod</span> u+x Zettlr-2.2.6-x86_64.AppImage<br>$ <span class="hljs-built_in">mkdir</span> -p ~/.local/bin/<br>$ <span class="hljs-built_in">cp</span> Zettlr-2.2.6-x86_64.AppImage ~/.local/bin/<br>$ <span class="hljs-built_in">ln</span> -s ~/.local/bin/Zettlr-2.2.6-x86_64.AppImage  ~/.local/bin/zettlr<br>$ ./Zettlr-2.2.6-x86_64.AppImage --appimage-extract<br>$ <span class="hljs-built_in">mkdir</span> -p ~/.local/share/applications/<br>$ <span class="hljs-built_in">mkdir</span> -p ~/.local/share/icons/<br>$ <span class="hljs-built_in">cp</span> squashfs-root/zettlr.desktop ~/.local/share/applications/<br>$ <span class="hljs-built_in">cp</span> squashfs-root/zettlr.png ~/.locals/share/icons/<br>$ <span class="hljs-built_in">rm</span> -rf squashfs-root<br></code></pre></div></td></tr></table></figure><p>输入 <code>vim ~/.local/share/appications/zettlr.desktop</code>修改</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">Exec=AppRun --no-sandbox %U<br></code></pre></div></td></tr></table></figure><p>为</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">Exec=zettlr --no-sandbox %U<br></code></pre></div></td></tr></table></figure><p>保存退出。至此，Zettlr Appimage已经按转完毕，可以直接从桌面启动了。如果是 Windows就没有这么多的麻烦。</p><p>Zettlr 的源码可以删掉也可以保留——爱咋咋地。如果想给 Zettlr添加功能的话可以自己在源码的基础上修改，我对 Zettlr 还是挺满意的。</p><h1 id="后语">后语</h1><p>这篇博客无非就是记录一下自己修改的 Zettlr的经历（虽然只是改了一丢丢）。这里可以谈谈使用 Manjaro 发现的问题。</p><p>记得在写安装常用软件教程的时候我说过自己的 Manjaro 使用不了 Flameshot截图软件，其实还包括 Shutter、Deepin-screenshot、Wemeet等等软件。后两者存在的问题是：可以正常使用，但是截图截的是黑屏、共享的也是黑屏。不信邪的我源码编译了Flameshot，结果发现还是一样无法使用。</p><p>最近转念一想：好家伙，原来是 GNOME 4.1 之后的窗口系统后端默认是Wayland。Wayland是新生代，有天然的优势，但很多软件都没有支持，所以录屏、截屏甚至共享屏幕都使用的X11 的接口，这自然就出现黑屏。</p><p>GNOME也考虑到这一点，所以在用户登陆界面的右下角提供了一个后端选择选项，就是一个齿轮模样。其中的选项：</p><ul><li>GNOME，表示默认使用 Wayland 后端。</li><li>GNOME Classic，是经典的 GNOME 后端，不启用各种插件。</li><li>GNOME Xorg，启用 X11 后端。</li></ul><p>启用 X11 虽然可以使用我上面提到的软件，但是我发现它不像 Wayland默认支持<ruby>触摸板手势<rt>TouchpadGestures</rt></ruby>。这个应该可以通过安装 GNOME Shell<ruby>插件<rt>Extensions</rt></ruby> X11 Gestures支持操作。反正现在我还是安于 Wayland 后端。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zettlr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>极简 VIM 入门</title>
    <link href="/2022/05/09/%E6%9E%81%E7%AE%80-VIM-%E5%85%A5%E9%97%A8/"/>
    <url>/2022/05/09/%E6%9E%81%E7%AE%80-VIM-%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p><ruby>VIM<rt>/vɪm/</rt></ruby>是一个古老的编辑器。有人听说这个编辑器可以脱离鼠标、完全依赖键盘操作之后，会好奇地上各种社交、知识问答类网站询问这款编辑器如何。他们通常会得到这样的回答：学习曲线非常陡峭，但学好之后效率非常。</p><p>听到这样的回答，有些新手就开始退缩，而有些人觉得这值得挑战，选择继续练习。于是他们会跑到网上查看相关的VIM 教程，写教程的人基本都是用过 VIM或者从不同地方复制过各类教程引流，所以他们上来就先要把这个初学者镇住，以展现自己丰富的知识和VIM 经验。请看 VIM 的快捷键：</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/05/09/202205091902478.gif"alt="基础操作" /></p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/05/09/202205091902865.png"alt="进阶操作" /></p><p>就这样，一个初学者还没有入门，基本就被劝退了。这就好比，刚学英语的时候被告知“英语至少有25 万个单词，历史上堆积的甚至超过 40 万个，一个人一辈子大约 8万天，要背完所有的单词至少每天记住 5个单词”，我相信就是丘吉尔也觉得活着好累。所以学 VIM的时候，要想退出很简单 ——找个大佬，让他教你，他基本会把你劝退，因为他大概率上来就是一个快捷键图。</p><p>秉承着劝退新手的使命，我今天也来讲讲如何学习 VIM。</p><h1 id="vim-入门">VIM 入门</h1><p>VIM能够靠键盘操作，其实和它的“语言”有关。想要使用这个编辑器，最简单的方法就是学习它的语言。别吐嘈自己英文不好，VIM的语法就是“动词 + 名词”这么简单。下面我会分两个部分介绍VIM：工作模式和语法。工作模式是最基本的概念，如果使用过VIM，可以直接跳过这一部分。</p><h2 id="工作模式">工作模式</h2><p>VIM 有四种工作模式：</p><ol type="1"><li><ruby>普通模式<rt>Normal Mode</rt></ruby>（正常模式），这是进入 VIM后默认的模式，也是其余模式工作的前提。想要进入这个模式很简单：按<kbd>Esc</kbd> 键即可。</li><li><ruby>插入模式<rt>InsertMode</rt></ruby>，普罗大众眼中编辑器的默认模式。这种模式就是打字时的模式，许多编辑器的默认模式就是这个。</li><li><ruby>命令（行）模式<rt>CommandMode</rt></ruby>，这个模式基本用于批量处理和查找、替换，通过输入命令完成操作。</li><li><ruby>可视（化）模式<rt>VisualMode</rt></ruby>，其实就是选择模式。由于 VIM是键盘操作，所以进行多行选择的时候我们不能通过鼠标操作，这时候就需要借助可视模式。如果你不知道什么叫做多行操作的话，非常好—— 这说明这个模式你基本用不到。</li></ol><p>如果使用 Windows 系统，我还是建议不要靠近VIM，因为你基本不可能习惯键盘操作。在使用 VIM 之前，我建议在家目录下的VIM 配置文件 .vimrc后面添加一些配置。具体使用是：复制下面的设置，在命令行上输入<code>vim ~/.vimrc</code>，回车进入 VIM，输入<kbd>Shift</kbd>+<kbd>g</kbd>，然后<kbd>o</kbd>，<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>v</kbd> 粘贴。按<kbd>Esc</kbd> ，输入 <code>:wq</code>，回车。</p><p>添加这个配置是修改 VIM 的<ruby>状态栏<rt>statusline</rt></ruby>，以便后面学习。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> report=0<br><span class="hljs-built_in">set</span> laststatus=2<br><span class="hljs-built_in">set</span> statusline=%&lt;%F%m%r%h%=%(%&#123;&amp;fileformat&#125;\ %&#123;&amp;encoding&#125;\ %c,%l\ %p%%%)<br></code></pre></div></td></tr></table></figure><h3 id="普通模式">普通模式</h3><p>普通模式需要记住的操作比较少，记住 ——普通模式是不可以修改文件和输入内容的！VIM的普通模式主要用于移动鼠标和视图。很多人习惯使用键盘上的箭头键，但是 VIM使用的是 <kbd>h</kbd>、 <kbd>j</kbd>、<kbd>k</kbd>、<kbd>l</kbd>表示左、下、上、右。为什么这么奇葩？因为上古时代的键盘就是这样的（请看下图），那个时候的编辑器还叫VI （VIM 是 VI 的增强版，VI Improved）。此外，看一下下面键盘的<kbd>Esc</kbd> 键是在 <kbd>Q</kbd>左边，所以那个时候按退出键比现在简单。记住这些就可以了。</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/05/09/202205091946872.jpg"alt="上古时代的键盘" /></p><h3 id="插入模式">插入模式</h3><p>插入模式是从普通模式转换。先见过插入命令：</p><ol type="1"><li>i，insert 的第一个字母，表示在光标之前插入；I，insert大写的第一个字母，表示在这一行的最开始插入。</li><li>a，append 的第一个字母，表示在光标之后插入；A，append大写的第一个字母，表示在这一行的最后插入。</li><li>o，没有对应的英文，表示在光标下一行插入空白行并转到下一行；O，无对应英文，表示在光标上一行添加空白行并撞到上一行。</li><li>s，substitute的第一个字母，表示删除光标下的字母并进入插入模式，即替换；S，substitute大写的第一个字母，表示替换光标所在行。</li></ol><p>现在打开一个文件，像我一样通过 <kbd>h</kbd>、<kbd>j</kbd>、<kbd>k</kbd>、<kbd>l</kbd> 随便选取一个位置。</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/05/09/202205091956771.png"alt="移动到指定位置" /> 现在我在 not 之前插入字符，那就把光标移动到 n上，然后按 <kbd>i</kbd> 键，输入字符，效果如下：</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/05/09/202205092009991.png"alt="输入 you" /> 可以看到，这时候已经进入插入模式，所以左下角有一个“--INSERT --” 标志。其余的命令可以自己尝试。</p><h3 id="命令模式">命令模式</h3><p>要进入命令模式先进入普通模式：按 <kbd>Esc</kbd>。命令模式其实就是普通模式加命令。命令模式的命令以冒号（:）开头，请在输入的时候注意左下角会出现命令—— 冒号需要打出来。</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/05/09/202205092015997.png"alt="命令模式" /></p><p>我们需要记住的命令有：</p><ol type="1"><li><code>:q!</code>回车，退出文件不保存。在普通模式下直接输入该命令。<code>q</code>是 quit 单词的缩写。<code>!</code> 表示否定，即不保存。</li><li><code>:wq</code>回车，保存并退出。<code>w</code> 是 write 的缩写。VIM 编辑器打开文件的时候会生成一个 swap文件，我们的操作都在这个文件，所有操作不会影响原来的文件。如果想要保存，那就把swap 文件的内容<ruby>写到<rt>write</rt></ruby>原文件，所以使用的是 write而不是 save。<code>w</code> 也可以单独使用。</li><li><code>:s/old/new/</code>回车，替换。<code>s</code> 是 substitute的缩写。这个操作只会影响光标所在行的第一个匹配项。不常用，经常使用的是全局替换<code>:%s/old/new/g</code> 。<code>%</code> 表示所有行，<code>g</code>是 globally 的缩写。<code>old</code>是想要替换的字符串，<code>new</code> 是替换后的字符串。</li></ol><p>记住这些就行了。第三个命令甚至不用记住 ——因为一般人不会使用全局替换。</p><h3 id="可视模式">可视模式</h3><p>这个用于选择。在其他编辑器中，我们都是使用鼠标选择，然后滚动滚轮进行选择，在VIM 中选择需要进入可视模式。进入可视模式之前先确认自己在普通模式：按<kbd>Esc</kbd> 。进入可视模式的命令有两个：</p><ol type="1"><li>v，visual 的缩写，通常称为行可视化，进行行选择。</li><li>V，visual 的大写缩写，通常称为块可视化，进行块选择。</li></ol><p>比如下面，我要选择第二第三行，使用行可视化，会看到左下角有 “-- VISUAL--”的标志。然后通过 <kbd>h</kbd>、<kbd>j</kbd>、<kbd>k</kbd>、<kbd>l</kbd> 进行选择。这里使用 <kbd>j</kbd>向下选择。选择完之后可以按 <kbd>Esc</kbd>退出。因为还没有教其他操作，所以这里先不进行其他操作。</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/05/09/202205092026991.png"alt="选择第二第三行" /></p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/05/09/202205092029374.png"alt="进入可视模式" /></p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/05/09/202205092030765.png"title="按 j 进行向下选择" alt="按 j 进行向下选择" /></p><p>下面来看块模式。块模式通常用于插入和删除。比如我要在第一第二第三行之前插入我的大名：光标移动到第一行的第一个字符，<kbd>Shift</kbd>+<kbd>v</kbd>（也就是大写V），把光标往下移动到第三行，输入<kbd>Shift</kbd>+<kbd>i</kbd>，然后输入 chunshuyumao ——注意，这时候只有第一行出现了 chunshuyumao，接下来连按两次 <kbd>Esc</kbd>，完成。</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/05/09/202205092035400.png"alt="Shift + i，输入 chunshuyumao" /></p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/05/09/202205092038342.png"alt="按两次 Esc 键" /></p><p>到这里，最基础的部分就讲完了。开始学习语法部分。</p><h2 id="语法">语法</h2><p>VIM 的语法主要是“动词 [+ 介词] +名词”。介词一般可以省略，但是我下面不会省略介词。</p><p>介绍几个常用的动词：</p><ol type="1"><li>d，delete 的缩写，用于删除。</li><li>y，yank 的缩写，用于复制。这个比较奇葩，因为复制我们都认为是copy，可是 VIM 用 yank（拖拽）表示复制。</li><li>c，change 的缩写，用于修改。</li><li>p，paste 的缩写，用于粘贴。</li><li>v，visual select的缩写，用于选择。我们已经见过了，其实就是可视化。</li><li>r，replace 的缩写，用于替换。</li><li>x，无对应单词，用于删除光标下的单个字符，但是不会进入插入模式。</li></ol><p>第 6 个动词用处不是很大，因为它一般用于修改单个字符；第 7个只是用于删除单个字符。</p><p>名词有：</p><ol type="1"><li>w，word 的缩写，表示一个字。</li><li>s，sentence 的缩写，表示一个句子。</li><li>p，paragraph 的缩写，表示一个段落。</li></ol><p>介词有：</p><ol type="1"><li>i，inside 的缩写，表示在……内部。</li><li>a，around 的缩写，表示在……之外。</li><li>t，to 的缩写，表示到……之前（不包括该字符），数学表达：左闭开 [)。</li><li>f，forward 的缩写，表示到……之前（包括该字符），数学表达：左闭右闭 []。 t 和 f 比较难以理解，其实就是一个包含于不包含的关系。</li></ol><p>所有的操作都要在普通模式下进行，所以请确认你按了 <kbd>Esc</kbd>键。</p><h3 id="动词-介词-名词">动词 + 介词 + 名词</h3><p>看下图，我现在要删除 important —— delete inside word，缩写就是diw。使用 inside ，是因为我们的光标在这个单词之内。</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/05/09/202205092057496.png"title="删除之前" alt="删除之前" /></p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/05/09/202205092059060.png"alt="删除之后" /></p><p>删除之后，我们发现 more 和 than 之间的空格有点大，因为 important被删，空格变成了两个。如果我们想要把空格也删掉，可以在删除 important的时候使用 delete around word（也就是 daw)。如下：</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/05/09/202205092103676.png"title="把单词和空格一起删掉" alt="把单词和空格一起删掉" /></p><p>同理，想要删掉一个句子，使用 delete inside sentence（dis）或者 deletearound sentence（das）。还有删除段落: delete inside paragraph（dip）和delete around paragraph（dap）。</p><h4 id="冷语法">冷语法</h4><p>除了上面的名词，搞编程的同学可能会碰到这样的问题：删除 main函数的内容 —— 但是不删除括号。如下，我们需要做的就是 delete inside{（dt{），结果如下：</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/05/09/202205092207065.png"alt="删除 main 函数花括号内的内容" /></p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/05/09/202205092210408.png"alt="效果" /></p><p>如果想要把花括号也给删了，那就使用 delete around {（da{）。这个 {可以改成任何符号，例如 [、(等等。如果遇到网页使用的<ruby>标签<rt>tag</rt></ruby>，可以使用 t代替，例如我上面的 <code>&lt;img&gt;</code> 标签，我想删掉标签<code>&lt;img&gt;</code> 内的内容就使用 delete insidetag（dit），删除内容和标签就使用 delete around tag（dat)。</p><h3 id="动词-数量词-介词-名词">动词 + 数量词 + 介词 + 名词</h3><p>如果我想删除两个单词呢？删除两个单词用英语怎么说：delete 2 insideword（d2iw）或者 delete 2 around word（d2aw）。注意，如果你使用 inside，空格也会被当作一个单词，所以建议使用 around。</p><p>删除两行？delete 2 inside paragraph（d2ip）或者 delete 2 aroundparagraph。</p><p>修改单词：change inside word（ciw）或者change aroundword（caw）；修改两个单词：change 2 inseide word（c2iw）或者 change 2around word（c2aw）。</p><p>上面的介词都可以省略 ——注意，省略的后果是：不论是句子、单词还是段落，编辑器默认从光标开始。例如使用delete 2word（d2w）：编辑器就认为你所说的两个单词是从光标之后。看下面的例子</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/05/09/202205092057496.png"title="删除之前" alt="删除之前" /></p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/05/09/202205092116759.png"title="不使用介词,，输入 d2w" alt="不使用介词,，输入 d2w" /></p><h3 id="惯用法">惯用法</h3><p>现在将光标移动到第九行，输入 yank insidesentence（yis）复制一行。输入 paste（p）就会粘贴到下一行（大写 P会粘贴到上一行）。</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/05/09/202205092120488.png"alt="复制一行" /></p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/05/09/202205092123546.png"alt="粘贴" /></p><p>虽然听起来很霸气，但是我们删除一行或者复制一行通常不会使用dis（das）或者 yis（yas），因为需要三个字母 ——我们是懒人，单词好越少越好，所以一般使用 dd 或者 yy进行删除和复制。类似的还有使用 cc 代替 change insidesentence（cis）。</p><h3 id="数量词-动词-名词">数量词 + 动词 + 名词</h3><p>这个和 “动词 + 数量词 + 介词 + 名词”差不多，但是一般用于特殊的动词，例如r(replace)、x(删除单个字符)、p(paste)。这些命令一般都是单个使用 ——不存在 paste inside sentence 这个类用法，所以要粘贴多次的使用可以使用 2paste（读作 twice paste）。</p><p>此外还可以搭配 yank 使用 —— yank 2 around sentence（y2as）= 2 yankyank（2yy），这样要简单很多。还有删除 d等等。基本是更简单的用法。当然，其实“动词 + 数量词 + 介词 +名词”也可以省略为“动词 + 数量词 + 名词”。</p><h3 id="其他动词">其他动词</h3><p>上面列出的是常用的动词，这里还有一些补充的动词：</p><ol type="1"><li>u，undo的缩写，用于撤销操作，适用于上面的语法，可以单独使用，也可以搭配数量词（不需要介词）。</li><li><kbd>Ctrl</kbd>+<kbd>r</kbd>，redo的缩写，不适用于上面的语法，单独使用，算作快捷键。撤销撤销操作（我没有多写一个撤销）。</li><li>g，goto 的缩写，用于跳转到指定行。适用于上面的语法，不需要介词。gg表示跳转到第一行，<kbd>Shift</kbd>+<kbd>g</kbd>表示跳转到最后一行。跳转到 45 行使用 45gg。</li><li>z，无对应单词，表示滚动当前行。zz 表示滚动当前行到屏幕中间；zb，b 是bottom 的缩写，表示滚动当前行到屏幕底部；zt，t 是 top的缩写，表示滚动当前行到屏幕顶部。</li><li>w，word 的缩写，做动词表示移动到下一个单词开头。2w表示移动到后面第二个单词的开头。适用与上面的部分语法。</li><li>e，end 的缩写，做动词表示移动到单词的结尾，与 b相反。适用于上面的部分语法。</li><li>b，begin 的缩写，做动词表示移动到单词的开头，与 e相反。是用于上面的部分语法。</li><li>f，find 的缩写，表示查找。ft 表示查找该行的字符 t，并移动到相应位置。</li><li>^，head of line 的符号，表示开头，做动词表示移动到该行的开头，与 $相反。配合 delete使用可以做到从当前字符删除到行首。可以当作名词与大部分动词搭配使用。</li><li>$，end of line 的符号，表示结尾，做动词表示移动到该行的结尾，与 ^相反。可以作为名词与大部分动词搭配使用。</li></ol><h1 id="结语">结语</h1><p>稍微介绍了一下 VIM 的语法，其实完全不算难。比如 b、e、f、w我就很少用。用的多的基本是 goto、delete、insert、yank 和paste。这里的功能基本是我用到的部分，其余如快捷键映射、宏录制甚至 VIM脚本语法都是进阶用法（意思是说，我也未必知道），我们就懒得涉猎了。</p><p>祝 VIM 入门愉快！</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编辑器</tag>
      
      <tag>VIM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在 Linux 上实现回收站</title>
    <link href="/2022/04/29/%E5%9C%A8-Linux-%E4%B8%8A%E5%AE%9E%E7%8E%B0%E5%9B%9E%E6%94%B6%E7%AB%99/"/>
    <url>/2022/04/29/%E5%9C%A8-Linux-%E4%B8%8A%E5%AE%9E%E7%8E%B0%E5%9B%9E%E6%94%B6%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>在 Windows 系统的时候，我会习惯使用快捷键 <kbd>Shift</kbd> +<kbd>delete</kbd> 进行直接删除，感觉这很酷 ——不用经过回收站。当然，时不时还是会后悔自己错删了某个文件，但是 Windows上有太多的数据恢复软件，完全不用担心。使用 Linux之后，我很习惯命令行上的 <code>rm</code>命令，直接把数据删个干净。有次错把自己的一个重要文件给删了，差点没救回来。那时候起，我开始考虑实现一个脚本，就像Windows 那样 —— 不直接删除数据，而是挪到一个地方。</p><h1 id="想法">想法</h1><p>Linux 大部分桌面系统是有回收站的 —— 至少我使用的 GNOME桌面系统是这样的。回收站的位置一般是 <code>~/.local/share/Trash</code>。其中 <code>~</code> 表示家目录，例如我的家目录是<code>/home/chunshuyumao</code>。通过文件管理器删除一个文件，我们可以在回收站目录下看到两个文件:<code>info</code> 和 <code>files</code>。前者是被删文件的信息，例如路径和删除时间；后者是被删文件移动到的位置。</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/04/29/202204291614948.png"alt="空回收站" /></p><p>图形界面删除一个文件之后，可以在回收目录下找到删除的文件和信息：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ tree<br>.<br>├── expunged<br>├── files<br>│   └── test.sh<br>└── info<br>    └── test.sh.trashinfo<br><br>3 directories, 2 files<br></code></pre></div></td></tr></table></figure><p>查看 <code>trashinfo</code> 文件不难发现，这其实是被删文件的信息:</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> info/test.sh.trashinfo<br>[Trash Info]<br>Path=/home/chunshuyumao/test.sh<br>DeletionDate=2022-04-29T16:15:24<br></code></pre></div></td></tr></table></figure><p>现在，我们要做的，就是写一个脚本，做到和图形界面一样的效果：<code>rm</code>不是直接删除，而是移动到固定位置，同时生成一个被删文件的信息。</p><h1 id="实现">实现</h1><p>想法很简单，直接使用 <code>mv</code> 代替 <code>rm</code>。不过我们还需要实现 <code>trashinfo</code>文件，以便可以模仿图形界面恢复文件。</p><h2 id="搭建框架">搭建框架</h2><p>首先创建一个文件，命名为 <code>mv2trash.sh</code>，意思是移动到回收站而不是直接删除。至于脚本放哪里，我的建议是在自己的家目录创建一个<code>.scripts</code> 文件夹，然后在里边放自己写的脚本或配置。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">mkdir</span> ~/.scripts<br>$ vim mv2trash.sh<br></code></pre></div></td></tr></table></figure><p>习惯性地在脚本第一行添加 <code>#!/bin/bash</code>，之前说过这是例行公事。</p><p>首先，我们需要创建一些常量( read only ，符号是 <code>-r</code>)：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-comment"># TrashPath 表示被删文件的路径</span><br><span class="hljs-built_in">declare</span> -r TrashPath=<span class="hljs-variable">$HOME</span>/.local/share/Trash/files<br><span class="hljs-comment"># InfoPath 表示信息文件的位置</span><br><span class="hljs-built_in">declare</span> -r InfoPath=<span class="hljs-variable">$HOME</span>/.local/share/Trash/info<br><br><span class="hljs-comment"># 确认回收站的位置是否存在</span><br>[ ! -e <span class="hljs-string">&quot;<span class="hljs-variable">$TrashPath</span>&quot;</span> ] &amp;&amp; <span class="hljs-built_in">mkdir</span> -p <span class="hljs-string">&quot;<span class="hljs-variable">$TrashPath</span>&quot;</span><br>[ ! -e <span class="hljs-string">&quot;<span class="hljs-variable">$InfoPath</span>&quot;</span> ] &amp;&amp; <span class="hljs-built_in">mkdir</span> -p <span class="hljs-string">&quot;<span class="hljs-variable">$InfoPath</span>&quot;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">main</span></span>() &#123;<br><br>  <span class="hljs-keyword">while</span> [ <span class="hljs-variable">$#</span> -gt 0 ]; <span class="hljs-keyword">do</span><br>    <span class="hljs-comment"># 做一些操作</span><br>    <span class="hljs-comment"># command</span><br>    <span class="hljs-built_in">shift</span><br>  <span class="hljs-keyword">done</span><br>&#125;<br><br><span class="hljs-comment"># 调用函数， &quot;$@&quot; 是传递所有参数</span><br>main <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span><br></code></pre></div></td></tr></table></figure><p><code>$HOME</code> 表示家目录，一般是 <code>/home/username</code>，比如我的家目录 <code>/home/chunshuyumao</code> ，使用<code>$HOME</code> 而不是绝对路径是为了通用性 ——当你移动这个脚本到其他电脑的时候它仍然指的是家目录，即使你的用户名并不是<code>chunshuyumao</code>。</p><p><code>[ -e TrashPath"  ]</code> 判断路径是否存在，<code>-e</code> 是<code>exist</code> 的缩写，前面添加 <code>!</code>则表示否定。<code>mkdir</code> 是 <ruby>创建目录<rt>makedirectory</rt></ruby>的缩写；<code>-p</code> 是 <code>--parents</code>的短命令形式，如果父目录不存在就创建而不是报错。<code>&amp;&amp;</code>表示前一个命令为真就执行后一个命令。因此，只有路径不存在的时候才会创建路径。</p><blockquote><p>-p 可能说的比较奇怪。其实是这样的，mkdir 命令只能创建一级目录，加上-p 就可以创建多级目录。 mkdir file &amp;&amp; mkdir file/filea&amp;&amp; mkdir file/filea/fileb 这就是之能够创建一级目录怎么创建file/filea/fileb 如果使用 -p 或者 --parent 的话，可以直接通过 mkdir -pfile/filea/fileb 一气呵成。</p><p>. 开头的文件是隐藏文件，使用 ls 是看不见的，需要使用 ls -a才可以。</p></blockquote><p>后面我们创建了一个函数 <code>main</code>并调用了它。同时记得，我们把脚本的参数也一并传递了过去。在<code>main</code> 函数中，我们判断，只要参数不为零，就一直循环，同时用<code>shift</code> 移除使用过的参数。</p><h2 id="实现细节">实现细节</h2><p>首先看看我们的实现：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">main</span></span>() &#123;<br><br>  <span class="hljs-keyword">while</span> [ <span class="hljs-variable">$#</span> -gt 0 ]; <span class="hljs-keyword">do</span><br>  <br>    <span class="hljs-built_in">local</span> filename=<span class="hljs-string">&quot;<span class="hljs-subst">$(basename $1)</span>&quot;</span><br>    <span class="hljs-built_in">local</span> filepath=<span class="hljs-string">&quot;<span class="hljs-subst">$(cd $(dirname $1)</span>; pwd)/<span class="hljs-variable">$filename</span>&quot;</span><br>    <span class="hljs-built_in">local</span> trashinfofile=<span class="hljs-string">&quot;<span class="hljs-variable">$InfoPath</span>/<span class="hljs-variable">$filename</span>.trashinfo&quot;</span><br>    <span class="hljs-built_in">local</span> deletiondate=<span class="hljs-string">&quot;<span class="hljs-subst">$(date +%Y-%m-%dT%H:%M:%S)</span>&quot;</span><br>    <br>    <span class="hljs-comment"># 使用系统的移动命令移动文件到指定地点</span><br>    /usr/bin/mv <span class="hljs-string">&quot;<span class="hljs-variable">$filepath</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$TrashPath</span>&quot;</span><br>    <br>    <span class="hljs-comment"># 创建一个 trashinfo 文件</span><br>    <span class="hljs-comment"># 并写入相关信息</span><br>    <span class="hljs-built_in">cat</span> &gt;&gt; <span class="hljs-string">&quot;<span class="hljs-variable">$trashinfofile</span>&quot;</span> &lt;&lt; <span class="hljs-string">_EOF_</span><br><span class="hljs-string">[Trash Info]</span><br><span class="hljs-string">Path=$filepath</span><br><span class="hljs-string">DeletionDate=$deletiondate</span><br><span class="hljs-string">_EOF_</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;rm: remove <span class="hljs-variable">$filepath</span> to <span class="hljs-variable">$TrashPath</span> &quot;</span><br>    <span class="hljs-built_in">shift</span><br>  <span class="hljs-keyword">done</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面我们创建了四个局部变量 —— 也就是 <code>local</code>修饰的那几个变量。这里有几个函数介绍一下：</p><ol type="1"><li><code>basename</code> ，语法：<code>basename path_to_file</code>。这个函数返回给予路径的文件名。我们不知道使用者提供的是什么路径，可能是绝对路径<code>/home/chunshuyumao/test.txt</code> ，也可能是相对路径<code>~/test.txt</code> ，但使用这个 <code>basename</code>函数，它会正确返回 <code>test.txt</code> 这个文件名。</li><li><code>dirname</code>，语法：<code>dirname path_to_file</code>。该函数会返回给予路径的路径名。如果我们提供的是<code>/home/chunshuyumao/scripts/test.sh</code>，函数会返回<code>/home/chunshuyumao/scripts</code>；如果提供的是当前目录下的<code>test.sh</code> ，函数会返回 <code>.</code> ——一个小圆点表示当前路径。为了得到当前位置的绝对路径，我们需要进入这个路径，然后使用<code>pwd</code> 打印当前路径 —— <code>pwd</code> 是<ruby>打印工作目录<rt>Print WorkingDirectory</rt></ruby>的缩写。如果不理解，只需要知道这种方法可以获取文件绝对路径就行了。最后通过拼接，形成了文件的绝对路径。</li><li><code>date</code>，语法：<code>date formating_string</code>。这个函数可以获取当前时间，并按照 <code>formating_string</code>进行格式化。在上面的脚本中，我们希望输出“年-月-日T时:分:秒”。</li></ol><p>获取变量之后使用系统的移动命令移动文件或者文件夹到指定位置即可。注意，这里的移动命令<code>mv</code> 没有简单使用 <code>mv</code> 而是<code>/usr/bin/mv</code> ，这是防止有其他的别名影响。</p><p>最后的 <code>cat</code>一行可能比较难以理解。这里引入一个新的语法糖，我会慢慢解释。如果我们需要创建一个新的文件，并在其中输入一些文字，最常用的方法是打开编辑器然后输入文字、保存、退出。有些时候我们输入的内容太少或者不想大费周章打开一个编辑器，这种时候重复上面的操作就难免有点复杂了。好在Linux Shell 上重定向符号<code>&gt;</code>、<code>&lt;</code>等可以满足我们的需求。下面介绍几种重定向符号：</p><ol type="1"><li><code>&gt;</code>输出重定向符。语法：<code>command &gt; output_file</code>。左边是<ruby>命令<rt>Command</rt></ruby> ，右边是 <ruby>保存文件<rt>OutputFile</rt></ruby>。重定向输出，如果指定的文件不存在会自动生成；可是也要注意：如果存在目标文件，命令会清空文件中的所有内容，然后再把结果写入到目标文件。一句话：如果之前就有这个保存文件，那么保存文件内的原始内容将被删掉。<code>ls</code> 列出当前目录下的文件，使用重定向符号试试：</li></ol><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">ls</span> &gt; list.txt<br>$ <span class="hljs-built_in">ls</span><br>Desktop    Downloads  Music     Public     Videos<br>Documents  list.txt   Pictures  Templates  Zotero<br>$ <span class="hljs-built_in">cat</span> list.txt<br>Desktop<br>Documents<br>Downloads<br>list.txt<br>Music<br>Pictures<br>Public<br>Templates<br>Videos<br>Zotero<br></code></pre></div></td></tr></table></figure><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/05/08/202205081622531.png"title="重定向之后 ls 输出的内容到了 list.txt 当中"alt="重定向之后 ls 输出的内容到了 list.txt 当中" /></p><p>可以看到，使用 <code>&gt;</code> 重定向符号之后 <code>ls</code>命令不再把结果输出到屏幕上，而是输出到我们指定的文件<code>list.txt</code>中。这个时候如果不存在指定的文件，命令就会重建一个文件。这个功能其实很有用，特别是当我们希望把命令的操作结果保存时。</p><p>上面说了，如果这个文件本来就有内容了，这个操作会抹除原始的内容，所以专门有个<code>&gt;&gt;</code> 符号（追加重定向）作为辅助 ——这个符号只是在文件末尾追加内容，而不是抹除然后再输入：</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/05/08/202205081640928.png"alt="使用输出重定向会直接抹除原来的内容" /></p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/05/08/202205081642542.png"alt="使用追加重定向后 list.txt 的内容增加而不抹除原内容" /></p><ol start="2" type="1"><li><code>&lt;</code>输入重定向符。语法：<code>command &lt; input_file</code>。读取右边的文件，并把结果传给左边的命令。下面借助<code>wc -l</code> 计算 <code>list.txt</code> 的行数：</li></ol><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/05/08/202205081636770.png"title="输入重定向" alt="输入重定向" /></p><p>同理，也有一个 <code>&lt;&lt;</code>不过这个一般不单独出现，而是出现在一个被称为 “Bash Here Document”的东西。这个东西的语法是：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">command</span> &lt;&lt; <span class="hljs-string">InputComesFromHere</span><br><span class="hljs-string">...</span><br><span class="hljs-string">...</span><br><span class="hljs-string">...</span><br><span class="hljs-string">InputComesFromHere</span><br></code></pre></div></td></tr></table></figure><p>上面的 <code>.</code> 表示一些文字。其中<code>InputComesFromHere</code>是一个符号，表示从这里开始到下一个同样的符号结束的都是想要输入重定向的文字。这个<code>inputComesFromHere</code> 符号一般随便选择 —— 通常我们会选择<code>EOF</code> 或者 <code>_EOF_</code>，表示 <ruby>文件结束符<rt>EndOfFile</rt></ruby>，因为一般的文件末尾都使用它作为标识。到这里，我上面的命令就可以理解了：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">    <span class="hljs-built_in">cat</span> &gt;&gt; <span class="hljs-string">&quot;<span class="hljs-variable">$trashinfofile</span>&quot;</span> &lt;&lt; <span class="hljs-string">_EOF_</span><br><span class="hljs-string">[Trash Info]</span><br><span class="hljs-string">Path=$filepath</span><br><span class="hljs-string">DeletionDate=$deletiondate</span><br><span class="hljs-string">_EOF_</span><br></code></pre></div></td></tr></table></figure><p>把两个 <code>_EOF_</code> 之间的内容追加到文件<code>"$trashinfofile"</code> 中，这就很直观了。</p><p>我们的脚本基本已经完成，输入 <code>chmod u+x mv2trash.sh</code>赋予脚本可执行权限，然后尝试删除：</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/05/08/202205081709669.png"alt="使用我们的脚本" /></p><p>现在 <code>.local/share/Trash</code>下面有两个文件夹，其中分别装着刚刚删除的文件 <code>list.txt</code> 和<code>list.txt.trashinfo</code>。以后我们删除的文件和生成的文件信息文件也会挪到这些位置。到这里，我们的框架基本搭完了，其实还可以补充更多的细节，例如交互模式—— 用于确认删除。</p><h2 id="实现恢复">实现恢复</h2><p>删除文件之后，我们希望可以做到一键恢复，这就不得不再写一个脚本 ——如果不愿意再写一个脚本，可以选择直接移动文件到原来的位置，然后删除<code>Trash Info</code> 文件。不过我这里还是实现一下自动恢复：</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/05/08/202205082105652.png"alt="恢复效果" /></p><p>上面，我先创建了一个 <code>test.sh</code> 文件，然后删除它，再用<code>rrm</code> 恢复文件。其中的 <code>rm</code> 和 <code>rrm</code>其实是我刚写的两个脚本的文件别名，后面会讲到。可以看到，<code>rrm</code>可以实现直接恢复文件到原来的位置 —— 就是通过读取原本的<code>trashinfo</code> 文件内部的信息。记得吧，我们的<code>trashinfo</code> 文件记录了文件原始目录。</p><p>先创建一个文件，然后再敲代码。我的恢复脚本名是 recover.sh，感觉还是比较直观。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ vim ~/.scripts/recover.sh<br></code></pre></div></td></tr></table></figure><p>按照上面的步骤，我们先写好脚本框架，然后再慢慢补充。路径和上面的删除脚本都一样，照搬。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-comment"># TrashPath 表示被删文件的路径</span><br><span class="hljs-built_in">declare</span> -r TrashPath=<span class="hljs-variable">$HOME</span>/.local/share/Trash/files<br><span class="hljs-comment"># InfoPath 表示信息文件的位置</span><br><span class="hljs-built_in">declare</span> -r InfoPath=<span class="hljs-variable">$HOME</span>/.local/share/Trash/info<br><br><span class="hljs-comment"># 确认回收站的位置是否存在</span><br>[ ! -e <span class="hljs-string">&quot;<span class="hljs-variable">$TrashPath</span>&quot;</span> ] &amp;&amp; <span class="hljs-built_in">mkdir</span> -p <span class="hljs-string">&quot;<span class="hljs-variable">$TrashPath</span>&quot;</span><br>[ ! -e <span class="hljs-string">&quot;<span class="hljs-variable">$InfoPath</span>&quot;</span> ] &amp;&amp; <span class="hljs-built_in">mkdir</span> -p <span class="hljs-string">&quot;<span class="hljs-variable">$InfoPath</span>&quot;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">recover</span></span>() &#123;<br><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">main</span></span>() &#123;<br>  <br>  <span class="hljs-keyword">while</span> [ <span class="hljs-variable">$#</span> -gt 0 ]; <span class="hljs-keyword">do</span><br>    recover <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span><br>    <span class="hljs-built_in">shift</span> <br>  <span class="hljs-keyword">done</span><br>&#125;<br><br>main <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span><br></code></pre></div></td></tr></table></figure><p>接下来只需要补充函数 <code>recover</code>即可。其实这个框架和上一个脚本都差不多 ——只是上一个脚本没有隔离出新的函数罢了。脚本的使用方法：<code>rrm path_to_file1 path_to_file2 ...</code>。这里的而 <code>path_to file1</code> 要求是全路径 ——也就是必须指定文件路径<code>~/.local/share/Trash/files/file1</code>。为什么？其实这是为了避免误恢复，所以只有全路径才能让操作者脑子清醒一点。</p><h3 id="恢复前操作">恢复前操作</h3><p>恢复之前，我们需要做一些工作，最主要的是判断参数的正确性。后面的代码都写在<code>recover</code> 函数体中。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">recover</span></span>() &#123;<br>  <br>  <span class="hljs-comment"># 判断要恢复的文件存在于否，如果不存在直接返回</span><br>  <span class="hljs-keyword">if</span> [ ! -e <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;No such a file or directory: <span class="hljs-variable">$1</span>&quot;</span><br>    <span class="hljs-built_in">return</span> 1<br>  <span class="hljs-keyword">fi</span><br><br>  <span class="hljs-comment"># 获取文件的文件名</span><br>  <span class="hljs-built_in">local</span> filename=<span class="hljs-string">&quot;<span class="hljs-subst">$(basename <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span>)</span>&quot;</span><br>  <span class="hljs-comment"># 拼凑文件信息文件的路径</span><br>  <span class="hljs-built_in">local</span> infofile=<span class="hljs-string">&quot;<span class="hljs-variable">$InfoPath</span>&quot;</span>/<span class="hljs-string">&quot;<span class="hljs-variable">$filename</span>.trashinfo&quot;</span><br>  <span class="hljs-comment"># 判断文件信息文件是否存在，如果不存在则提示恢复者直接手动移动文件到目的目录就可以</span><br>  <span class="hljs-keyword">if</span> [ ! -e <span class="hljs-string">&quot;<span class="hljs-variable">$infofile</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;No such a file: <span class="hljs-variable">$infofile</span> . Please move target file or directory manually.&quot;</span><br>    <span class="hljs-built_in">return</span> 1<br>  <span class="hljs-keyword">fi</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面的操作我们判断恢复文件的存在和拼凑文件信息文件，为后面的恢复做准备。这里的操作我们其实都见过，例如<code>basename</code> 获取文件名，还有 <code>-e</code>判断文件存在。</p><h3 id="开始恢复">开始恢复</h3><p>恢复代码写在上面的代码之后 —— 先看我们的恢复代码：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">local</span> path=<span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> line; <span class="hljs-keyword">do</span><br>  ...<br>  ...<br><span class="hljs-keyword">done</span> &lt; <span class="hljs-string">&quot;<span class="hljs-variable">$infofile</span>&quot;</span><br></code></pre></div></td></tr></table></figure><p>首先声明一个本地变量 —— 我不是很喜欢全局变量。这里使用了一个命令 ——<code>read</code> 。 <code>read</code>命令语法是：<code>read variable</code>。后面的 <code>variable</code>是变量名，可以随便取，我这里的变量名是<code>line</code>。注意，<code>done</code> 之后的重定向 ——其实就是把文件信息文件内的内容一行一行地读出来。重定向我们上面说过了，这就是重定向的用法。这里不停的读取一行一行信息。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">local</span> path=<span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> line; <span class="hljs-keyword">do</span><br>  <span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$line</span>&quot;</span> =~ <span class="hljs-string">&quot;Path&quot;</span> ]]; <span class="hljs-keyword">then</span><br>    path=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;line:$(expr index &quot;$line&quot; &#x27;=&#x27;)&#125;</span>&quot;</span><br>    <span class="hljs-built_in">break</span><br>  <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">done</span> &lt; <span class="hljs-string">&quot;<span class="hljs-variable">$infofile</span>&quot;</span><br></code></pre></div></td></tr></table></figure><p>上面的代码就是判断读入的每一行，如果这行中有 “Path”字样，就进行处理，并退出循环。<code>=~</code>运算符之前也有介绍过，就是判断某一个字符串是否包含另一个字符串。举个例子，我可以使用<code>[[ "$str" =~ "chunshu" ]]</code> 判断 <code>$str</code> 是否包含<code>chunshu</code>这个字符串。如果我们读入的行有 "Path"字样，就说明这就是保存文件路径的一行，后面的命令其实是对这个的处理。</p><p>Shell 用 <ruby>切片<rt>Slice</rt></ruby>切割字符串 —— 之前我们介绍的<code>#</code> 和 <code>%</code> 就属于<ruby>切片<rt>Slice</rt></ruby>。这里使用了两个表达式：</p><ol type="1"><li><code>$&#123;str:from:length&#125;</code>。意思是截取某一个字字符串。<code>str</code>表示字符串，<code>from</code>表示从第几个字符开始（不包括这个字符），<code>length</code>表示总共截取多少个字母 —— 可以省略，表示截取到结尾。</li><li><code>expr index "$str" 'char(s)'</code> 。 表示获取<code>char(s)</code> 在 <code>str</code> 中的下标。<code>expr</code> 和<code>index</code> 是保留字，<code>str</code>表示字符串，<code>char(s)</code> 表示查找的字符或字符串。</li></ol><p>所以 <code>$&#123;line:$(expr index "$line" '=')&#125;</code>表示在这一行中找到 <code>=</code> 的下标，然后截取 <code>=</code>之后的字符串。如果 <code>$line</code> 表示<code>Path=/home/chunshuyumao/file1</code> ，这结果是<code>/home/chunshuyumao/file1</code>。获得路径之后直接使用<code>break</code>跳出 <code>while</code>循环。</p><p>使用系统的 <code>/bin/mv</code> 移动文件到指定位置，使用<code>/bin/rm</code> 删除文件信息文件。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> line; <span class="hljs-keyword">do</span><br>...<br><span class="hljs-keyword">done</span> &lt; <span class="hljs-string">&quot;<span class="hljs-variable">$infofile</span>&quot;</span><br><br><span class="hljs-comment"># 一定要使用全路径命令</span><br><span class="hljs-comment"># Remove From                   To</span><br>/bin/mv <span class="hljs-string">&quot;<span class="hljs-variable">$TrashPath</span>/<span class="hljs-variable">$filename</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$path</span>&quot;</span><br>/bin/rm <span class="hljs-string">&quot;<span class="hljs-variable">$infofile</span>&quot;</span><br><br><span class="hljs-comment"># 输出提示信息</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;recover <span class="hljs-variable">$filename</span> to <span class="hljs-variable">$path</span>&quot;</span><br></code></pre></div></td></tr></table></figure><p>为什么这里的 <code>rm</code> 和 <code>mv</code> 要使用全路径（加<code>/bin</code>）而不是直接使用 <code>rm</code> 和<code>mv</code>？这是为了避免使用错误的命令。后面会有介绍。赋予脚本可执行权限，然后使用。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">chmod</span> u+x ~/.scripts/recover.sh<br></code></pre></div></td></tr></table></figure><h2 id="使用命令别名">使用命令别名</h2><p>我们最开始的目标是防止自己误删文件导致后悔不已，可是现在的脚本是mv2trash.sh 和 recover.sh，我们基本不会使用这种长命令，所以接下来配置命令别名：打开自己的 Shell配置文件 —— 我用的是 Zsh 所以配置的是 ~/.zshrc ，如果你使用的是Bash，配置的是应该是 ~/.bashrc 。如果不知道自己的是什么 Shell ，可以输入<code>echo $SHELL</code> ，看输出结果。</p><p>我使用 VIM 配置 .zshrc 所以操作是：进入 VIM 后，按<kbd>Shift</kbd>+<kbd>g</kbd>转到最后一行，然后输入 <kbd>o</kbd>，输入下面的别名，按 <kbd>Esc</kbd> 键，然后输入 <code>:wq</code> ，回车—— 完成保存退出。在命令行上输入 <code>source ~/.zshrc</code>立即生效。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ vim ~/.zshrc<br><br><span class="hljs-comment"># 这是别名</span><br><span class="hljs-built_in">alias</span> <span class="hljs-built_in">rm</span>=<span class="hljs-variable">$HOME</span>/.scripts/mv2trash.sh<br><span class="hljs-built_in">alias</span> rrm=<span class="hljs-variable">$HOME</span>/.scripts/recover.sh<br><br>$ <span class="hljs-built_in">source</span> ~/.zshrc<br></code></pre></div></td></tr></table></figure><p>完成别名，接下来我们使用 的<code>rm</code>就是自己的脚本，<code>rrm</code>是恢复命令。如果想使用系统的删除命令直接删除某个文件而不是挪到垃圾箱怎么办？简单—— 使用全路径，就是 <code>/bin/rm file</code>。这就是为啥上面的脚本要使用全路径。</p><h1 id="后话">后话</h1><p>其实这个脚本还是可写很多，例如我还实现了脚本的日志 ——不过我看了一下现在字数非常多，没心思再写下去。此外，如果对自己写的脚本不满意，可以使用软件trash-cli。这是大佬实现的命令行垃圾箱，不过我没用过，应该比自己写的好一点。很多Linux 发行版都可以直接安装。使用说明推荐使用 <code>man trash-cli</code>或者 <code>trash-cli --help</code> 查看 ——当然，我没用过，不知道怎么样，自己的够用了。</p><p>后面打算写写 VIM 语言 —— 分享分享 VIM这个被说的神乎其神的编辑器怎么入门。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>脚本</tag>
      
      <tag>技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>好玩的命令行工具</title>
    <link href="/2022/04/24/%E5%A5%BD%E7%8E%A9%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"/>
    <url>/2022/04/24/%E5%A5%BD%E7%8E%A9%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>老习惯，前言牢骚不用看。4 月偷了懒，今天突然心血来潮，更更自己文章 ——不然就过去一个月了。谈谈自己最近做的事，顺便分享一些好玩的命令行命令。自己做的事是闲事，所以直接放前言。</p><p>值得一提的一件事是，参与测试国内首个大型的编程语言。编程语言现在已经不是什么新鲜事—— 当初自己就有一个非计算机系的学弟在只学了 C++的一些皮毛之后，纯手工造了一个新的语言。这种大佬咱没话可说。可惜他完全是新手上车，以初学者的方式理解高级语言，所以略有不足（如果他咨询咨询我的话可能会更好，不过也是，咱也没问人家）。既然如此，这门新的编程语言有何特点？其实不好说，因为人家还在内测，具体很多东西还待商榷。不过我们要知道，目前为止，几乎所有编程界的高级语言都依赖于C/C++，这让它们或多或少执行效率都不咋地 —— 比如Python，堪称龟速。虽然有如 Lua这类的小巧的语言，但是它们往往是大语言的伴生物，不能独当一面。这里就不多做介绍了。</p><p>目前为止，能在效率上和 C/C++ 抗衡，又有自己优势的就是 Rust ——更安全。其余的 Go 或者等等都有待商榷。不过了解 Rust的应该知道，这门语言为了安全，语法变得非常复杂 ——最近自己也试着学学这门语言，一言难尽。有此看来，我参与内测的编程语言的定位很明显了。个人觉得这门语言还是很优秀的，因为有很多先辈的经验。同样，因为作为“国货之光”，大家可能会对它抱有很大的期望——如果它给你的感觉不大好，那很可能是你给它倾注的期望太大了。两边都没有错，希望要多一点理解。</p><p>另一个要说的，就是中文编程。我实在无法理解为什么很多人对中文编程那么执着？诚然，中文更符合我们的习惯—— 可是中文的输入一直是个问题。历史传说的 26键打不过九键，拼音打不过双拼，双拼打不过五笔……这种故事多了。如果要创造一个中文编程，最好的方式就是按照国人的思维创造。思维方式不同，照搬国外语言然后换一个中国字的结果就是——文字游戏。比如易语言，这门语言确实是中文编程，咱也不深究，但是使用函数方法的时候，我们又需要输入半角符号—— 基本等于 C语言里的宏定义了，但是易语言至少做了一些创新。反观一些模仿者，就说前一阵子刚出现的某中文操作系统和创造者创造的“甲、乙”语言—— 完全就是收割智商，可结果还是有一班信徒。至此，咱也没话可说了 ——早知道智商税这么好赚……</p><h1 id="正文">正文</h1><p>今天要介绍的是一些命令行工具 —— 有些不仅仅是 Linux系统才可以使用。</p><ol type="1"><li>cmus 命令行音乐播放器</li><li>FFmpeg 视频和音频工具</li><li>Telnet 远程登陆工具</li></ol><h2 id="cmus-命令行音乐播放器">cmus 命令行音乐播放器</h2><p>使用 Linux 作为主系统之后，我很习惯直接使用命令行解决大多数问题 ——说实在，我就没打开过自己的文件管理器几次。虽然我例行公事地下载了 VLC媒体播放器 ——一个非常优秀的跨平台多媒体播放器，但是自己很少使用。简而言之，咱基本只使用命令行。</p><p>敲命令怎么能让耳朵闲着？为了在使用命令行的时候可以听歌放松，我选择了<a href="https://github.com/cmus/cmus" title="cmus">cmus</a>播放器，一个纯 C 语言写的命令行播放器，内存和速度没得说 ——贼低贼快。大多数的 Linux 发行版都可以直接用命令行安装，我用的是 Manjaro，所以使用 <code>sudo pacman -S cmus</code> 安装。</p><p>安装完毕之后在命令行上输入 <code>cmus</code>，回车打开，界面如下：</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/04/24/202204242119118.png"alt="cmus 界面" /></p><p>现在的 cmus 还没有音乐，我们需要导入。确认进入 cmus之后，直接在键盘上输入 <code>:a ~/Music</code>，回车。眼尖的同学会发现，cmus 的命令和 VIM 很相似。<code>:</code>是命令行模式的标志，所以一定要打出来；<code>a</code> 表示 add，也可以直接使用 <code>add</code> 长指令；后面的 <code>~/Music</code>是音乐路径，这是我放音乐的地方。刚刚的命令也可以写成这样<code>:add ~/Music</code>。</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/04/24/202204242139772.png"alt="添加音乐" /></p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/04/24/202204242152627.png"alt="添加音乐后" /></p><h3 id="基本操作">基本操作</h3><p>因为和 VIM 差不多，所以使用 <kbd>j</kbd>、<kbd>k</kbd>上下移动，<kbd>h</kbd>、<kbd>l</kbd> 向前向后调整播放进度， <kbd>z</kbd>播放上 一首，<kbd>b</kbd> 播放下一首，<kbd>c</kbd>暂停/播放，<kbd>x</kbd> 从头播放，<kbd>v</kbd>停止，<kbd>CTRL</kbd>+<kbd>r</kbd> 单曲循环/歌单循环，<kbd>e</kbd>添加下一首播放，<kbd>tab</kbd>切换<strong>艺术家</strong>和<strong>音乐库</strong>两列等等。更多操作可以使用<code>man cmus</code> 查看。</p><p>此外，还有 <kbd>CTRL</kbd>+<kbd>l</kbd> 刷新缓存 ——因为导入的音乐有些信息未必完整，最后需要手动修改。个人觉得 cmus很适合命令行的极度爱好者 —— 还有我这类附庸风雅的。</p><h2 id="ffmpeg-音视频工具">FFmpeg 音视频工具</h2><p>这个东东来历大了，现在市面上搞音视频的不认识这家伙都不好意思说自己不认识。我不喜欢什么东西都往自己电脑上装，所以之前没打算使用cmus，而是想自己写一个命令行脚本播放音乐，当时盯上的后端就是这东西。后来是写了一点，但是惊奇地发现：原来我的电脑自己就带了cmus ！果断中途放弃自己写脚本的想法。太讽刺了 ——电脑自己安装就觉得心安理得……</p><p>我今天介绍 <a href="https://ffmpeg.org/" title="FFmpeg">FFmpeg</a>主要是音视频的转化。使用 Windows的时候，我基本不会选择命令行，而是直接使用格式工厂(当然，格式工厂也是靠FFmpeg)，不过到了 Linux ——时代就变了。简单来说，如果你有一个视频，而且你恰好想提取它的的音频，那么恭喜你，FFmpeg 可以满足你。FFmpeg 是跨平台的，所以也可以在 Windows 上找到。Linux下直接使用自己发行版的包管理器就可以安装，我的使用 Manjaro :<code>sudo pacman -S ffmpeg</code>。</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/04/24/202204242216842.png"alt="FFmpeg 官网" /></p><p><code>ffmpeg -i input_file.mp4 output_file.mp3</code>就可以提取视频的音频。当然，各种操作多了去了，咱不是搞音视频开发的，很多参数看不懂，基本的操作了解就行。通过<code>man ffmpeg</code> 或者 <code>ffmpeg --help</code>查看更多的命令。FFmpeg 通常会附带 FFplay，可以进行音视频的播放，功能还是很强大的 —— 不过我使用它来听过歌<code>ffplay -showmode 0 -loop -1 -i unput_file.mp3</code>。<code>-showmode 0</code>后面的 <code>0</code> 表示不用打开播放界面，因为播放界面会打开一个 GUI.<code>-loop</code> 是循环次数，后面跟一个数字，我接的是 <code>-1</code>(负一)，表示无限循环，如果是 <code>1</code> 、<code>3</code>等，那就是循环一次或者三次。<code>-i</code> 后面跟着播放的文件。</p><h2 id="telnet-远程登陆工具">Telnet 远程登陆工具</h2><p>Telnet是一个远古的工具，在现代生产生活中扮演无名小卒，但是人家也曾辉煌过。现在我要介绍的，是建立在Telnet 上的两个好玩东西：</p><ol type="1"><li><ruby>字符艺术<rt>ASCII</rt></ruby>《星球大战》</li><li><ruby>字符艺术<rt>ASCII</rt></ruby> 世界地图。</li></ol><p>上古时代有个大佬把《星战》做成了字符艺术，现在我们只需要在命令行上输入<code>telnet towel.blinkenlights.nl</code> 就可以快速过一遍《星战》了 ——作为非《星战》迷，我表示忍受不了电影的画质，但是很喜欢<ruby>字符艺术<rt>ASCII</rt></ruby>。</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/04/24/202204242231346.png"alt="二十世纪福克斯" /></p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/04/24/202204242229855.png"alt="老故事会了" /></p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/04/24/202204242227215.png"alt="家政机器原型" /></p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/04/24/202204242227678.png"alt="牛魔王" /></p><p>其次就是命令行版的“谷歌地图”了—— <code>telnet mapscii.me</code>，响应速度贼快。键盘操作，基本是<kbd>h</kbd>、<kbd>j</kbd>、<kbd>k</kbd>、<kbd>l</kbd>左上下右移动，<kbd>a</kbd>、<kbd>z</kbd>放大缩小。</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/04/24/202204242234230.png"alt="image-20220424223452168" /></p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/04/24/202204242236997.png"alt="我大南开" /></p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/04/24/202204242239603.png"alt="我大新开湖" /></p><p>当然，每次输入这么长的命令很麻烦，所以直接在自己家目录的 Shell配置文件添加一下代码，我用 VIM 打开自己的 ZSh 配置文件</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ vim ~/.zshrc<br><br><span class="hljs-built_in">alias</span> map=<span class="hljs-string">&quot;telnet mapscii.me&quot;</span><br><span class="hljs-built_in">alias</span> strwrs=<span class="hljs-string">&quot;telnet towel.blinkenlights.nl&quot;</span><br></code></pre></div></td></tr></table></figure><p>保存退出后输入 <code>source ~/.zshrc</code> 就可以输入<code>map</code> 或者 <code>strwrs</code>代替长长的指令了。这里说明一下，如果使用的是 Bash， 需要配置的是<code>.bashrc</code> 文件。</p><h1 id="后语">后语</h1><p>本来想再推荐几个命令行游戏的，不过自己玩玩之后发现没玩明白 ——索性就不介绍了。其实今天介绍的都比较冷门 ——网易云其实也有命令行版本、Telnet 都是上古的工具了。还有诸如cowsay、sl、oneko 等等好玩的东西没介绍 ——不过也没办法，很多人现在谈到好玩的命令行就提 cowsay让我觉得这个东西没必要介绍。</p><p>这篇文章算是敷衍忪懒的四月吧，希望五月能再勤一点。(也许后面会更一些Rust 的文章？)</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>命令行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Chevereto 配合 PicGo 搭建自己的图床</title>
    <link href="/2022/03/31/Chevereto%E9%85%8D%E5%90%88PicGo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9B%BE%E5%BA%8A/"/>
    <url>/2022/03/31/Chevereto%E9%85%8D%E5%90%88PicGo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>前一阵子，自己的图床没了觉得很可惜，当时还想，要不要去租个网络存储服务？等到冷静下来之后才想起：我有一个服务器来着！真是神奇。</p><p>有了想法自然要付诸行动，准备搭建自己的图床。之前我曾试着手动搭过<ruby>LNMP<rt>Linux Nginx MariaDBPHP</rt></ruby>，可惜失败了。此外我还在自己的服务器里装过OpenResty，所以还得进行一些清理工作。不得不说，当初搭建环境都是一次性代过，没有给服务器来个快照或者备份什么的，导致可能乱装了点啥——不过大多数时候我都会选择卸载掉自己安装的东东，除非哪个配置文件我忘了。</p><blockquote><p>LNMP 原来是指 Linux、Nginx、MySQL 和 PHP。只不过我用的是MariaDB，所以没带上 MySQL.</p></blockquote><h1 id="准备">准备</h1><p>搭建图床服务的环境如下：</p><ol type="1"><li>Linux 服务器，我用的是 Rocky Linux 8.5, 同等于 RHEL 8 和 CentOS8。因为安装完成之后我才写的博客，所以这次用 Docker 下的 Rocky Linux 8.5演示，勉强看作一个虚拟机吧。</li><li><a href="https://www.lnmp.org/"title="LNMP">LNMP</a>，一键安装环境脚本，比手动简单多。我手动搭建过，各种配置太麻烦。这里提供一键安装它不香吗？</li><li>Chevereto，一个图床自建程序。</li><li>PicGo, 选择性。</li></ol><p>下面我们慢慢介绍。</p><h2 id="lnmp-安装">LNMP 安装</h2><p>LNMP是一个网站服务器框架。简而言之，网络上很多东西都建立在这个框架基础之上。只要搭好这个框架，除了图床还可以快速搭建博客、网站等等。背景什么的咱就不介绍了——毕竟我也不是行家。</p><p>登陆自己的服务器，下载一个叫做 screen 的程序。简单说一下，使用 SSH登陆服务器久不操作连接会自己断开。当然，为什么我们不操作呢，是吧？其实还是有可能的，比如安装软件，特别是Linux 系统，有些时候编译某些东东的时间很长，长时间不操作 SSH链接会自己断开。在 Linux系统中，我们的操作基本都来自操作终端——就是我们的命令行——如果连接断开，终端就终止了。终端终止，我们的所有操作就都终止了。这样我们不得不重试，重试之后又断开，反反复复。</p><p>为了避免这种情况，我们使用 screen命令创建一个独立于当前终端的空间，即使我们的连接突然断了，命令仍然被执行。这就是保命的东西。我们的操作基本都需要超级管理员权限，所以索性切换到超级管理员——root</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">su - root<br>yum install screen -y<br></code></pre></div></td></tr></table></figure><p>安装完成之后使用 <code>screen -S lnmp</code> 创建一个叫做 lnmp的空间。下载 <a href="https://www.lnmp.org/" title="LNMP">LNMP</a>一键安装脚本，然后解压，进入自己解压的文件夹：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">axel -n 32 http://soft.vpser.net/lnmp/lnmp1.8.tar.gz<br>tar zxf lnmp1.8.tar.gz<br>cd lnmp1.8<br></code></pre></div></td></tr></table></figure><p>你可以选择自己喜欢的下载方式，我喜欢用 Axel 。</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/03/31/202203311924121.png"alt="下载解压" /></p><p>使用 <code>ls</code> 查看你的目录，输入 <code>./install.sh</code>进行安装。如果你用的和我一样，都是 Rocky Linux,那么恭喜你，你中奖了，喜提错误警告：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">Unable to get Linux distribution name, or do NOT support the current distribution.<br></code></pre></div></td></tr></table></figure><p>这是因为这个脚本没有为 Rocky Linux准备。现在有两个选择：选择其他发行版，自己动手改脚本。我选择后者。</p><p>输入 <code>vim include/main.sh</code> 打开脚本，按 <kbd>/</kbd>，输入Get_Dist_Name 找到目标函数，如下。回车。</p><p>在 <code>if</code> 后面添加</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">elif grep -Eqi &quot;Rocky Linux&quot; /etc/issue || grep -Eq &quot;Rocky Linux&quot; /etc/*-release ;then<br>    DISTRO=&#x27;CentOS&#x27;<br>    PM=&#x27;yum&#x27;<br></code></pre></div></td></tr></table></figure><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/03/31/202203311928363.png"alt="打开脚本" /></p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/03/31/202203311935014.png"alt="修改配置" /></p><p>这其实是让脚本以为自己在 CentOS 系统上运行——我说过 Rocky Linux 兼容CentOS，所以没必要担心。按 <kbd>Esc</kbd>，输入<code>:wq</code>，回车，保存退出。重新执行脚本。</p><p>重新执行之后脚本会让你选择自己的数据库，如果知道的话就选择，不懂的直接默认。我选择最新的MariaDB 10.4.19，所以输入 10，后面设置数据库密码。</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/03/31/202203311940652.png"alt="选择数据库类型" /></p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/03/31/202203311943548.png"alt="设置密码" /></p><p>安装 PHP。这就不是版本越高越好了，暂且选择 7.1吧，因为我现在的数据库和 Chevereto支持的就是这个版本。后面的那个内存分配器随便选择，也可以默认不选，我选择2。然后回车安装。</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/03/31/202203311946674.png"alt="PHP版本" /></p><p>到这里，基本可以洗洗睡了——会安装很久。我的服务器在安装过程中 CPU使用率直接飙到 90% 以上，基本使劲浑身解数来解决编译问题，最后还是花了126 分钟，简直慢到死。不过现在是在自己的电脑演示，速度还是挺快的。</p><p>如果在等待的过程中，你的 SSH连接断开了，你可以再次登陆自己的服务器，然后用<code>screen -r lnmp</code>恢复原来的工作。如果你忘了自己给取的名字是啥，使用<code>screen -list</code> 查看。等到运行结束之后，可以直接用<code>exit</code> 退出 screen .</p><p>我们使用脚本的另一个好处是，如果自己的环境配错了，可以修改。比如我安装了PHP 高版本，但是需要的是低版本，可以是使用 <code>./upgrade.sh</code>进行修改。手动的话，比较麻烦。同理，如果想要卸载，也可以使用我们下载的LNMP 中的脚本完成。也可以去 <a href="https://www.lnmp.org/"title="LNMP">LNMP</a> 脚本官网查看教程。</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/03/31/202203312009531.png"alt="安装完成" /></p><p>安装完成，使用了 22分钟，比服务器强多了。我没有域名，所以就不搞虚拟主机了，直接上 IP.</p><p>看最后几行，上面提示 nginx、php-fpm等都没有运行——按理来说是应该运行的，不过我用的 Docker,所以不行而已。如果使用虚拟机或者服务器，通常应该没问题。例行公事，给他们开机自启的权限：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">systemctl <span class="hljs-built_in">enable</span> nginx<br>systemctl <span class="hljs-built_in">enable</span> php-fpm<br>systemctl <span class="hljs-built_in">enable</span> mariadb<br><br>systemctl restart nginx<br>systemctl restart php-fpm<br>systemctl restart mariadb<br></code></pre></div></td></tr></table></figure><p>这时候，<code>/home</code> 目录下会多出几个 www 开头的用户，其中wwwroot 目录下的 default就是我们的图床位置——可以随意改变位置，但是我只按照这个目录演示。</p><p>可以看到 default 目录下有一个 phpmyadmin文件夹，待会我们会访问它。</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/03/31/202203312027429.png"alt="phpmyadmin" /></p><p>打开配置文件，找到 server 有 <code>listen 80</code>的那一部分配置。在 <code>include enable-php.conf</code>后面添加以下配置：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">vim /usr/local/nginx/conf/nginx.conf<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">location / &#123;<br>    try_files <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span>/ /index.php?<span class="hljs-variable">$query_string</span>;<br>&#125;<br><br>location ~ [^/]\.php(/|$) &#123;<br>    fastcgi_pass unix:/tmp/php-cgi.sock;<br>    fastcgi_index index.php;<br>    include fastcgi.conf;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/03/31/202203312033765.png"alt="配置" /></p><p>注意配置里的一些字段，例如后面有的图片格式后面的括号显示有效期（expires）是30 天。你可以修改自己的。</p><p>可以把 servername 改为自己的服务器公网 IP。</p><p>修改完之后，在浏览器中输入 <code>http://ip/phpmyadmin</code>登陆创建数据库，用户是 root，密码是你刚刚创建的，我的是chunshuyumao.</p><blockquote><p>http://ip/phpmyadmin 中的 IP 是指你的服务器公网IP，而不是这两个字符。</p></blockquote><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/03/31/202203312040197.png"alt="登陆选择数据库" /></p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/03/31/202203312043700.png"alt="创建图床数据库" /></p><p>创建数据库的时候，编码选择 utf8_general_ci .我对数据库不是很了解，不能给专业的解释，只能告诉你这样避免乱码。</p><h2 id="chevereto">Chevereto</h2><h3 id="安装">安装</h3><p>准备安装 <a href="https://github.com/rodber/chevereto-free"title="Chevereto">Chevereto</a>。到 GitHub 下载压缩包或直接使用<code>git clone</code>，<a href="https://chevereto-free.github.io/"title="Chevereto官网">官网</a>了解教程。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">cd /tmp<br>axel -n 32 https://github.com/rodber/chevereto-free/archive/refs/heads/1.6.zip<br></code></pre></div></td></tr></table></figure><p>下载完之后解压、移动到 default 目录：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">unzip chevereto-free-1.6.zip &amp;&amp; mv chevereto-free-1.6/* /home/wwwroot/default/<br></code></pre></div></td></tr></table></figure><p>我下载的是 1.6版，解压的时候需要看自己下载的是第几版，不要照抄我的步骤。解压之后default 目录应该长这样：</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/03/31/202203312106787.png"alt="default 目录" /></p><p>现在可以到浏览器直接输入你的服务器公网 IP 了：</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/03/31/202203312107148.png"alt="登陆 Chevereto" /></p><p>当然，你最初看到的不是这个，而是一个初始界面。我没办法演示，但是你知道要填写这类信息就行：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">Database host --&gt; 这个不用动<br>Database name --&gt; 这个是你刚刚新建的数据库名字，我记得是 picbed<br>Database user --&gt; 填 root <br>Database user password --&gt; 上面你创建的密码，我的是 chunshuyumao<br></code></pre></div></td></tr></table></figure><p>之后就是你的一些信息了，随便填写，其中那三个邮箱地址可以一样。最后的Website mode 选择Person，如果你用的是中文的话是”个人“的意思。最后登陆即可。</p><h3 id="配置">配置</h3><p>登陆 Chevereto, 右上角选择 Dashbord --&gt; Settings --&gt;Website，修改 Website privacy mode 为 private,这样你的网站就不会被别人接触到了。</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/03/31/202203312120424.png"alt="设置" /></p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/03/31/202203312121054.png"alt="设置" /></p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/03/31/202203312123309.png"alt="修改为Website privacy mode 为 priavte" /></p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/03/31/202203312127809.png"alt="上传的图片" /></p><p>你点击右上角的上传按钮进行上传——这个应该可以调成中文，我只是不想调而已。</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/03/31/202203312129523.png"alt="上传" /></p><p>图床安装完毕。你的服务器里，图床在 /home/wwwroor/default/images下边。</p><h3 id="配合-picgo">配合 PicGO</h3><p>如果你愿意使用 PicGO, 我很乐意告诉你怎么做。</p><p>打开 PicGo 查找 Chevereto 插件并安装，配置的时候 Url 写http://ip/api/1/upload。例如我的：</p><blockquote><p>这里的 IP 指的是你的服务器公网 IP，不是两个字符。如果你选择了其他端口，请把端口带上：</p><p>http://ip:port/api/1/upload</p><p>例如：</p><p>http://888.777.666:8080/api/1/upload 就是 IP 为 888.777.666 ，端口为8080</p></blockquote><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/03/31/202203312135945.png"alt="搜索 Chevereto 插件" /></p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/03/31/202203312136390.png"alt="配置" /></p><p>还缺一个 Key。打开我们的 Chevereto --&gt; Dash Board --&gt; Settings--&gt; Website --&gt; API，把你的 Key 复制一份填写即可。</p><p><imgsrc="http://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/2022/03/31/202203312139840.png"alt="Key" /></p><p>最后你就可以使用 PicGo 开心地上传自己的图床了！</p><p>——当然，你得记得在 PicGo 中把 Chevereto 设置为默认图床。</p><h1 id="后语">后语</h1><p>这次没有超过 3000字，又是一次胜利！步骤其实很简单，只是我们不够专业，所以才会觉得难。搭建完之后我试了试，发现图床并没有被公众号屏蔽——妙啊！这样一来，我以后要做的就是使用自己的图床，然后找个时间上传到GitHub。因为我的服务器只有一年的时间，到期我也未必续费，所以肯定需要转移自己的图片。一年之后的事一年之后再思考吧，现在为以后打算——以后就没事可做了。</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图床</tag>
      
      <tag>Chevereto</tag>
      
      <tag>PicGo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>闲话</title>
    <link href="/2022/03/27/%E9%97%B2%E8%AF%9D/"/>
    <url>/2022/03/27/%E9%97%B2%E8%AF%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>今天只想说一些闲话。</p><h1 id="正经吐嘈">正经吐嘈</h1><p>最近自己的<ruby>码云<rt>Gitee</rt></ruby>图床仓库因为外链访问过多被官方封了，当然，人家还是给了我备份的机会。其实当时还是觉得蛮奇怪的，毕竟我只是用于自己的博客和临时作为微信的图床——公众号屏蔽外链但没有屏蔽<ruby>码云<rt>Gitee</rt></ruby>。后来发现除我之外，其他人也有同样的情况。不知是该喜还是该忧。找时间把自己的东西记录下来已经是万幸了，如今再添加这么一层阻碍，公众号基本没戏了——除非公众号更新的都是没有图片的文章。</p><p>公众号没有强制使用<ruby>码云<rt>Gitee</rt></ruby>的意思，而是我写文章使用的是Markdown.写完之后通过其他途径复制到公众号，这样就省去了排版的时间。为了减少和平台相关，我的图片通常放到某些地方——例如图床。放到图床之后，在Markdown里只需要使用图片的链接就可直接看到图片。公众号屏蔽了很多的网络链接——所以顺带就把我的图床链接也给屏蔽了。之前我一直用sm.ms图床，后来发现公众号使用不了就改用<ruby>码云<rt>Gitee</rt></ruby>。</p><p>当初没有想过码云是不允许使用仓库作为图床的。最近可能因为自己的博客被浏览的次数比较多，至少<ruby>码云<rt>Gitee</rt></ruby>方面给的理由是外链访问过多，所以引起了别人的注意。为了安全起见，我把自己的图片转移到了GitHub平台——因为这个平台说过把它用作图床不违法。国外的平台访问较慢，不过加加速就可以了。</p><p>然而问题来了，公众号屏蔽 GitHub.公众号不屏蔽的基本是国内付费的专用网络存储平台，例如 阿里云OSS这类。用图床无非就是图简单，上传到公众号之后，公众号会保存备份。为了一个临时的存储去开通专用服务没多大必要——虽然也不贵，所以我就笃定使用GitHub了。这么一来，我的图片自然就转不了公众号了。当然，我可以选择手动上传，然后一个一个插入文章中。可惜我只是玩玩公众号，不想花大量的体力劳动在这些无意义的事。我本来就很懒，多一秒的事我都觉得烦，自然不愿意受这种罪。最后思来想去，觉得确实没必要为了公众号的图片上传大费周章。</p><p>其实我是有想过其他办法的，比如昨天我就几乎花了一天测试各种图床，希望有一个可以被公众号接纳——我最开始只是想写公众号，后来才去玩博客。可惜，国内被公众号接纳的图床都是不可能白嫖的。反正也是白嫖，我又有什么理由争辩？嫖不了只能说明我们需要回报社会了。</p><p>其实得知自己仓库被封的时候我刚写完一篇博客，寻思着这个时间检查错别字然后发公众号——因为公众号允许更改的错别字有限，我公众号的推送就一堆错别字。结果看看邮箱才发现麻烦大了。写了封信给管理员，人家好歹抽出时间看了我的信，给咱解了封——毕竟咱小喽罗，掀不起风浪。不过俗话说的好，一朝被蛇咬十年怕井绳。今天不知者被封16 小时，后面就是再犯了，鬼知道封多久。果断卷铺盖走人。</p><p>迁移图片的时候还行，无非就是修改一下图片链接地址。然而 GitHub毕竟访问慢，在不违法的情况下正常使用它有点吃力。迁移只需要修改博客也是一大幸——突然觉得公众号保留图片的备份真好，免得自己之前的推送图片全飞了。因为之前写过一篇把<ruby>码云<rt>Gitee</rt></ruby>变图床的推送和博客，博客是可以修改，公众号改不了了。这里还是说说，慎用<ruby>码云<rt>Gitee</rt></ruby>作为图床，至少对我来说，我已见识过惊吓带来的恐慌。</p><p>刚写完自己的文章，图床就被封着实有点神奇，迁移图片的时候走了很多弯路，无意中还删了自己刚写完的文章。不得不说，完全没有后悔药。好巧不巧，我的坚果云当时同步的位置恰好没改过来，Typora的草稿恢复区也只有我写的第二篇，Linux 的 debugfs我又不会用——毕竟之前没碰到过这种情况。等到了解 debugfs之后发现实操和理想中的不一样。情急之下，下载 Pandoc 准备将自己的博客HTML 文件转换为Markdown。结果发现，转换成功是成功了，但是排版惨不忍睹。所有的补救措施都没有用，我只好纯手工把网页上的文字重新复制下来，重写一遍Markdown版本的文章。就这样，一天就在尝试寻找不被屏蔽的图床和恢复文章中过去了。</p><p>当时都想摆——毕竟博客保留了一份 HTML版，又害怕自己上传博客的时候喜欢清除以前的文章，搞不好哪天就被自己手贱清掉了，最后才选择手动复制。因为是复制的，我也就懒得检查有没有错别字了——自己觉得还原度还行。</p><p>因为那两篇博客的图片都很多，如果不手动上传图片到公众号是没有办法直接发布的。既然这么麻烦，索性摆烂，直接不上传公众号了。如果以后再写有关的推送，可能会选择多一点的语言描述，尽量减少图片的使用。</p><p>这有点负能量，不过看看自己公众号，最近还是有几个人关注的，寻思着多半是觉得其中的某些推送写的还可以，选择了关注。不过照此看来，将来的推送少有图片，写的还可以的推送就不大可能了。这都什么年代了，谁还看文字？所以今天心血来潮，写写最近的状况，不想让自己关注的公众号晾着的小伙伴可以取关了。</p><h1 id="后语">后语</h1><p>老规矩，有前言自然有后语，这叫例行公事。其实也没有写的那么悲观，只是觉得有点可惜。我之前选择公众号而不是博客就是因为公众号会保存我的文字和图片，玩博客还需要依靠图床。不架设自己的博客系统就得依赖别人的服务，靠别人的东西哪天别人收走了自己一无所有。综合来说，还是公众号好一点——至少只要自己不违法，那东西就在那里。可惜现在情况变了，在简便和稳定面前，我选择了简便——毕竟自己这么说也还保留着博客源文件，如果真的突然博客也不能用了，源文件在，哪里不能记录？但要为了保留自己的一份备份，花大把时间上传图片，然后再一个一个插入到文章当中，我可做不到。只希望公众号哪天可以解除一些不必要的外链屏蔽。</p><p>等因奉此。</p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图床</tag>
      
      <tag>公众号</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于百度翻译 API：手撸一个命令行翻译脚本--进阶</title>
    <link href="/2022/03/26/%E5%9F%BA%E4%BA%8E%E7%99%BE%E5%BA%A6%E7%BF%BB%E8%AF%91-API%EF%BC%9A%E6%89%8B%E6%92%B8%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BF%BB%E8%AF%91%E8%84%9A%E6%9C%AC-%E8%BF%9B%E9%98%B6/"/>
    <url>/2022/03/26/%E5%9F%BA%E4%BA%8E%E7%99%BE%E5%BA%A6%E7%BF%BB%E8%AF%91-API%EF%BC%9A%E6%89%8B%E6%92%B8%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BF%BB%E8%AF%91%E8%84%9A%E6%9C%AC-%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>正事从 2. 开始，前言只是发牢骚。</p><p>前面我们已经完成了翻译脚本的基本功能。所有的编程语言最大的问题一直是字符串，Shell也一样。当我准备写下这一篇的时候还在想：要不要先出一篇介绍 Shell编程的博客？Shell语言和其他的编程语言也不太一样，我们更习惯叫它“脚本语言”，可惜这也不够准确。我觉得要真的做比较，可以看出做是高级的批处理语言。</p><p>前一阵子的翻译脚本，实际看来不复杂。原本打算一篇写完，结果还没写多少就突破三千字。不得不说，现在市面上各种叫嚣几分钟学会某种东西的声音太多，能有人抽出时间看完三千字不大可能，所以我直接断笔，把剩下的部分独立出来。这次尽量一篇写完。</p><h1 id="参数">参数</h1><p>前一篇我们让脚本后面的参数直接充当 query参数的值，也就是说我们只能这样使用我们的翻译脚本<code>./mt.sh 翻译的文本</code>。可是看到 Linux上的命令通常都有很多的命令参数，怎么看自己的脚本都太简单了。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203260911243.png"alt="简单脚本" /></p><p>此外，我们的脚本如果被其他人使用，别人不知道怎么使用怎么办？我们还希望自己的脚本可配置翻译语言和目的语言。鉴于这些要求，我们需要扩展之前的命令行参数。</p><p>这里复习一下：所谓命令行参数，指的是脚本之后跟着的字符。举个例子：<code>./mt.sh chun shu yu mao</code>的命令行参数是<code>./mt.sh</code>、<code>chun</code>、<code>shu</code>、<code>yu</code>和<code>mao</code>，其中参数使用<code>$n</code>表示，n是阿拉伯数字，不能超过 9 。</p><p>先确定我们需要什么参数。根据之前的分析，我们知道：from 表示源语言，to表示目的语言，q表示翻译文本。那好，我们就设置这些参数。我们习惯在参数前面加<code>-</code>表示参数，其中长参数使用两个短杆，短参数用一个。所以我们的目标是这样：</p><table><thead><tr class="header"><th style="text-align: center;">参数值</th><th style="text-align: center;">短参数</th><th style="text-align: center;">长参数</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">from</td><td style="text-align: center;">-f</td><td style="text-align: center;">--from</td></tr><tr class="even"><td style="text-align: center;">to</td><td style="text-align: center;">-t</td><td style="text-align: center;">--to</td></tr><tr class="odd"><td style="text-align: center;">q</td><td style="text-align: center;">-q</td><td style="text-align: center;">--query</td></tr></tbody></table><p>以后我们希望这样调用脚本：<code>./mt.sh -f en -t zh -q Yeah</code>，这样写的好处是可以随意调换参数位置，例如可以这样写：<code>./mt.sh -q Yeah -t zh -f en</code></p><h1 id="解析参数">解析参数</h1><p>要读取参数，我们需要一个循环。Shell 中的循环可以使用 while。然后我们需要获取参数的个数，这样我们才能确定循环的次数。在 Shell 使用<code>$#</code> 获取参数个数，所以我们的脚本框架是这样的：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">while [ $# -gt 0 ]; do<br>   <br>    echo $1<br>    <br>    shift<br>done<br></code></pre></div></td></tr></table></figure><p>在 Shell中使用比较需要放到一个方括号<code>[]</code>里边，而且数值比较不能使用<code>&lt;</code> 等符号，而是英语简写。</p><table><thead><tr class="header"><th style="text-align: center;">中文</th><th style="text-align: center;">简写</th><th style="text-align: center;">英文</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">小于</td><td style="text-align: center;">-lt</td><td style="text-align: center;">less than</td></tr><tr class="even"><td style="text-align: center;">大于</td><td style="text-align: center;">-gt</td><td style="text-align: center;">greater than</td></tr><tr class="odd"><td style="text-align: center;">等于</td><td style="text-align: center;">-eq</td><td style="text-align: center;">equal</td></tr><tr class="even"><td style="text-align: center;">小于等于</td><td style="text-align: center;">-le</td><td style="text-align: center;">less than or equal</td></tr><tr class="odd"><td style="text-align: center;">大于等于</td><td style="text-align: center;">-ge</td><td style="text-align: center;">greater than or equal</td></tr><tr class="even"><td style="text-align: center;">不等于</td><td style="text-align: center;">-ne</td><td style="text-align: center;">not equal</td></tr></tbody></table><p>我们的 while 循环就是表示：当参数个数大于 0个的时候开始是循环。要注意，因为 <code>$0</code>默认表示脚本的名字，<code>$#</code>不把它算上。也就说，<code>./mt.sh chun shu yu mao</code> 的参数总数是 4而不是 5.</p><p><code>shift</code> 表示偏移。这个有点难理解：还是拿<code>./mt.sh chun shu yu mao</code> 来说，原本 <code>$1</code> 表示<code>chun</code>，使用一个 <code>shift</code> 之后 <code>$1</code>变成了 <code>shu</code>，再使用就是 <code>yu</code> 。<code>shift</code>偏移之后参数个数就少了，所以我们处理完一个参数就用 <code>shift</code>扔掉这个参数，直到所有参数都被处理完。</p><p>想要判断这个参数是 <code>-t</code> 还是 <code>-f</code>，大家的想法可能是 <code>if</code> 语句。但是在这里， <code>if</code>语句不好处理，推荐使用 <code>case</code> 语句。<code>case</code> 就像C/C++ 语言中的 <code>switch</code>，Python3.10 之后的 <code>match</code>。<code>case</code> 还可以用 <code>|</code> 表示或者，例如<code>ab|bc</code> 表示匹配 <code>ab</code> 或者 <code>bc</code>，语法是：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">case 参数 in<br>匹配1) 处理<br>;;<br>匹配2) 处理<br>;;<br>匹配3|匹配4) 处理<br>;;<br>esac<br></code></pre></div></td></tr></table></figure><p>​ 既然如此，我们的脚本应该这样</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> [ <span class="hljs-variable">$#</span> -gt 0 ]; <span class="hljs-keyword">do</span><br><br>  <span class="hljs-keyword">case</span> <span class="hljs-variable">$1</span> <span class="hljs-keyword">in</span><br>    <span class="hljs-string">&#x27;-t&#x27;</span>|<span class="hljs-string">&#x27;--to&#x27;</span>) <br>    to=<span class="hljs-variable">$2</span><br>    <span class="hljs-built_in">shift</span><br>    ;;<br>    <span class="hljs-string">&#x27;-f&#x27;</span>|<span class="hljs-string">&#x27;--from&#x27;</span>)<br>    from=<span class="hljs-variable">$2</span><br>    <span class="hljs-built_in">shift</span><br>    ;;<br>    <span class="hljs-string">&#x27;-q&#x27;</span>|<span class="hljs-string">&#x27;--query&#x27;</span>)<br>    query=<span class="hljs-variable">$2</span><br>    <span class="hljs-built_in">shift</span><br>    ;;<br>  <span class="hljs-keyword">esac</span><br>  <span class="hljs-built_in">shift</span><br><span class="hljs-keyword">done</span><br></code></pre></div></td></tr></table></figure><p>我们判断了 <code>$1</code>表示某个符号之后，直接读取它后边的参数，所以读取<code>$2</code>，过程如下：</p><ol type="1"><li>执行脚本 <code>./mt.sh -f en -t zh -q text</code></li><li>进入 <code>case</code> ，判断 <code>$1</code> 是<code>-f</code>，所以读取 <code>$2</code> 也就是<code>en</code>。执行一次偏移，现在 <code>$1</code> 变成了<code>en</code>.</li><li>跳出 <code>case</code>，执行一次 <code>shift</code> ，现在<code>$1</code> 是 <code>-t</code> .</li><li>下一次循环，又回到第 2 步</li></ol><p>在 Shell 中，我们有一个简写：如果前一步执行成功，我们可以用<code>&amp;&amp;</code> 执行下一步，所以上面可以写成这样：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">while [ $# -gt 0 ]; do<br><br>case $1 in<br>&#x27;-t&#x27;|&#x27;--to&#x27;) to=$2 &amp;&amp; shift ;;<br>&#x27;-f&#x27;|&#x27;--from&#x27;) from=$2 &amp;&amp; shift ;;<br>&#x27;-q&#x27;|&#x27;--query&#x27;) query=$2 &amp;&amp; shift ;;<br>esac<br>shift<br>done<br></code></pre></div></td></tr></table></figure><p>现在我们的脚本如下，顺便测试一下：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">encoding:utf-8</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">翻译 HTTPS 地址</span><br>declare -r basic_url=&quot;https://api.fanyi.baidu.com/api/trans/vip/translate&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">APPID</span><br>declare -r appid=&quot;xxxxxxxxxxxxxxxxxxxx&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">密钥</span><br>declare -r token=&quot;xxxxxxxxxxxxxxxxxxxx&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">random code</span> <br>declare salt=$(openssl rand -base64 18|cut -c 1-10)<br><br>decalre from<br>declare to<br>declare query<br><br>while [ $# -gt 0 ]; do<br>  case $1 in<br>    &#x27;-t&#x27;|&#x27;--to&#x27;) to=$2 &amp;&amp; shift ;;<br>    &#x27;-f&#x27;|&#x27;--from&#x27;) from=$2 &amp;&amp; shift ;;<br>    &#x27;-q&#x27;|&#x27;--query&#x27;) query=$2 &amp;&amp; shift ;;<br>  esac<br>  shift<br>done<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">翻译</span><br>sign=$(echo -n &quot;$appid$query$salt$token&quot; | md5sum | cut -c 1-32)<br><br>query=$(echo &quot;$query&quot; | tr -d &#x27;\n&#x27; | xxd -plain | sed &#x27;s/\(..\)/%\1/g&#x27;)<br>query=$(echo $query | sed &#x27;s/ //g&#x27; )<br><br>result=$(curl &quot;$basic_url?q=$query&amp;from=$from&amp;to=$to&amp;appid=$appid&amp;salt=$salt&amp;sign=$sign&quot; 2&gt;/dev/null)<br>result=&quot;$&#123;result##*dst\&quot;:\&quot;&#125;&quot;<br>echo -e $&#123;result%\&quot;\&#125;\]\&#125;&#125;<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203261002830.png"alt="中英互译" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203261006717.png"alt="中英互译" /></p><p>大多数时候，我们都是从英文翻译到中文，每次都写这么多的参数实在麻烦，所以我们在<code>while</code> 之后写参数默认值：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">while [ $# -gt 0 ]; do<br>  case $1 in<br>    &#x27;-t&#x27;|&#x27;--to&#x27;) to=$2 &amp;&amp; shift ;;<br>    &#x27;-f&#x27;|&#x27;--from&#x27;) from=$2 &amp;&amp; shift ;;<br>    &#x27;-q&#x27;|&#x27;--query&#x27;) query=$2 &amp;&amp; shift ;;<br>  esac<br>  shift<br>done<br><br>if [ -z $from ]; then <br>  from=&#x27;auto&#x27;<br>fi<br><br>if [ -z $to ]; then<br>  to=&#x27;zh&#x27;<br>fi<br><br>sign=$(echo -n &quot;$appid$query$salt$token&quot; | md5sum | cut -c 1-32)<br></code></pre></div></td></tr></table></figure><p><code>[ -z $from ]</code> 表示，如果 <code>$from</code> 是空( zero)的字符串，就执行 <code>if</code>里边的语句。这样看起来有点不舒服，我们可以用上面学到的知识修改成下面的语句：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">[ -z $from ] &amp;&amp; from=&#x27;auto&#x27;<br>[ -z $to ] &amp;&amp; to=&#x27;zh&#x27;<br></code></pre></div></td></tr></table></figure><p>上面两种形式是等价的，大抵意思是说：源语言自动判断——百度翻译有这个功能，目标语言默认是中文。这样，如果我们可以简单使用<code>./mt.sh -q 文本</code> 进行翻译。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203261018479.png"alt="测试" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203261021075.png"alt="阿拉伯语" /></p><p>到这里，翻译部分基本讲完了。</p><h1 id="拓展功能">拓展功能</h1><p>大多数的命令行工具都可以使用 <code>命令 --help</code>查看帮助，所以我们也假模假样搞一个帮助的文本。我的文本如下：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">&#x27;-h&#x27;|&#x27;--help&#x27;)<br>  echo &quot;Usage: $0 [OPTION]&quot; <br>  echo &quot;Valid options are:&quot;<br>  echo -e &quot; -q, --query\t\ttext want to translate&quot;<br>  echo -e &quot; -f, --from\t\tsource language. auto detect default&quot;<br>  echo -e &quot; -t, --to\t\tdestinate language, Chinese default&quot;<br>  echo -e &quot; -l, --list\t\tlist all support languages&quot;<br>  echo -e &quot; -i, --interact\t\tenter interact mode&quot;<br>  echo -e &quot; -c, --clear\t\tclear the screen&quot;<br>  echo -e &quot; cmd\t\t\tonly on interact mode. use to set settings, same as above.&quot;<br>  echo &quot;&quot;<br>  echo &quot;example:&quot;<br>  echo &quot;$0 -f en -t zh -q &#x27;I like it.&#x27;&quot;<br>  echo &quot;$0 &#x27;I like it&#x27;&quot;<br>  echo &quot;&quot;<br>  echo &quot;when use &#x27;$0 -i&#x27; you can type such command to change settings&quot;<br>  echo &quot;    &gt;cmd -f zh -t en&quot;<br>  ;;<br></code></pre></div></td></tr></table></figure><p>把上面的文本放到 <code>while</code> 循环的 <code>case</code>中。这里我还写了一些拓展，例如交互模式(interact mode)。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203261028368.png"alt="帮助" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203261030188.png"alt="使用帮助" /></p><p>可以看到，列出帮助之后脚本仍旧执行翻译，所以后面出现报错。我们需要设置列出帮助之后直接退出脚本，在脚本中写下<code>exit 0</code>。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">echo &quot;    &gt;cmd -f zh -t en&quot;<br>exit 0<br>;;<br></code></pre></div></td></tr></table></figure><h2 id="函数">函数</h2><p><code>case</code> 分支 <code>--help</code>看起来占位置，还不好看。我们可以写一个函数，把里边的语句单独提出来，然后调用脚本，这样脚本就可以写成：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">function uasge()&#123;<br><span class="hljs-meta prompt_">   # </span><span class="language-bash">这里写 <span class="hljs-built_in">echo</span> ...</span><br>&#125;<br><br>while [ $# -gt 0 ]; do<br>  case $1 in<br>    &#x27;-t&#x27;|&#x27;--to&#x27;) to=$2 &amp;&amp; shift ;;<br>    &#x27;-f&#x27;|&#x27;--from&#x27;) from=$2 &amp;&amp; shift ;;<br>    &#x27;-q&#x27;|&#x27;--query&#x27;) query=$2 &amp;&amp; shift ;;<br>    &#x27;-h&#x27;|&#x27;--help&#x27;) usage &amp;&amp; exit 0 ;;<br>  esac<br>  shift<br>done<br></code></pre></div></td></tr></table></figure><p>Shell中的脚本调用不用括号，直接列出函数名，如果有参数就直接放后面：<code>func para1 para2 para3</code>.</p><p>同理，完善 <code>--list</code> 列出支持的语言翻译的时候可以写成</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">function uasge()&#123;<br><span class="hljs-meta prompt_">   # </span><span class="language-bash">这里写 <span class="hljs-built_in">echo</span> ...</span><br>&#125;<br><br>function language_support()&#123;<br><br>  echo -e &quot;name\t\tid&quot;<br>  echo -e &quot;Chinese\t\tzh&quot;<br>  echo -e &quot;  --Traditional\tcht&quot;<br>  echo -e &quot;  --Classical\twyw&quot;<br>  echo -e &quot;  --Cantonese\tyue&quot;<br>  echo -e &quot;English\t\ten&quot;<br>  echo -e &quot;Japanese\tjp&quot;<br>  echo -e &quot;Spanish\t\tspa&quot;<br>  echo -e &quot;Russian\t\tru&quot;<br>  echo -e &quot;Italic\t\tit&quot;<br>  echo -e &quot;Polish\t\tpl&quot;<br>  echo -e &quot;Danish\t\tdan&quot;<br>  echo -e &quot;Romanian\trom&quot;<br>  echo -e &quot;Hugarian\thu&quot;<br>  echo -e &quot;Korean\t\tkor&quot;<br>  echo -e &quot;Thai\t\tth&quot;<br>  echo -e &quot;Portuguese\tpt&quot;<br>  echo -e &quot;Greek\t\tel&quot;<br>  echo -e &quot;Bulgarian\tbul&quot;<br>  echo -e &quot;Finnish\t\tfin&quot;<br>  echo -e &quot;Slovene\t\tslo&quot;<br>  echo -e &quot;French\t\tfra&quot;<br>  echo -e &quot;Arabic\t\tara&quot;<br>  echo -e &quot;German\t\tde&quot;<br>  echo -e &quot;Dutch\t\tnl&quot;<br>  echo -e &quot;Estonia\t\test&quot;<br>  echo -e &quot;Czech\t\tcs&quot;<br>  echo -e &quot;Swedish\t\tswe&quot;<br>  echo -e &quot;Vietnamese\tvie&quot;<br>  echo -e &quot;and so on&quot;<br>&#125;<br><br>while [ $# -gt 0 ]; do<br>  case $1 in<br>    &#x27;-t&#x27;|&#x27;--to&#x27;) to=$2 &amp;&amp; shift ;;<br>    &#x27;-f&#x27;|&#x27;--from&#x27;) from=$2 &amp;&amp; shift ;;<br>    &#x27;-q&#x27;|&#x27;--query&#x27;) query=$2 &amp;&amp; shift ;;<br>    &#x27;-h&#x27;|&#x27;--help&#x27;) usage &amp;&amp; exit 0 ;;<br>    &#x27;-l&#x27;|&#x27;--list&#x27;) language_support &amp;&amp; exit 0 ;;<br>  esac<br>  shift<br>done<br></code></pre></div></td></tr></table></figure><p>到这里，我们的脚本基本完善了，就差一个交互模式了。</p><h2 id="交互模式">交互模式</h2><p>每次翻译我们都需要执行一次脚本太麻烦了，我们希望可以做到执行一次脚本后保留之前的设置继续翻译。此外，如果我们突然想改变翻译的一些设置，也可通过交互模式直接改变，而不用退出重新设置。这基本是交互模式的工作。</p><p>交互模式，顾名思义，我们就用 <code>-i</code> 和<code>--interact</code> 代替。在你的 <code>case</code>给交互模式赏一个分支：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">&#x27;-i&#x27;|&#x27;--interact&#x27;)<br>;;<br></code></pre></div></td></tr></table></figure><p>如果调用交互模式的指令是：<code>./mt.sh -i -f en -t zh</code>，我们希望脚本先分析完参数再执行交互模式。这样一来，<code>case</code>的交互模式分支就不能用函数了。我们设置一个标志符，确认是不是交互模式。大概如下：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><br>declare -i interaction=0<br>while [ $# -gt 0 ]; do<br><span class="hljs-meta prompt_">  # </span><span class="language-bash">...</span><br>    &#x27;-i&#x27;|&#x27;--interact&#x27;) interaction=1 ;;<br><span class="hljs-meta prompt_">  # </span><span class="language-bash">...</span><br>done<br></code></pre></div></td></tr></table></figure><p>后面我们再判断是不是交互模式。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">[ -z $from ] &amp;&amp; from=&#x27;auto&#x27;<br>[ -z $to ] &amp;&amp; to=&#x27;zh&#x27;<br><br>[ $interaction -eq 1 ] &amp;&amp; interact &amp;&amp; exit 0<br></code></pre></div></td></tr></table></figure><p>这次就需要写一个 interact 函数了。可以把函数放到 <code>while</code>循环之前。</p><p>我们的想法是，交互模式一行一行读取我们的输入，就像这样：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203261109882.png"alt="交互模式" /></p><p>上面我设置了 <code>cmd</code>作为交互模式修改设置的关键字，也就是而已使用 <code>cmd + 参数</code>修改语言翻译的设置。</p><p>交互模式的函数如下：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">function interact()&#123;<br><br>  while read -p &quot;&gt;&quot; query; do<br>    [[ -z &quot;$query&quot; ]] &amp;&amp; continue<br>    [[ &quot;$query&quot; =~ &quot;cmd &quot; ]] &amp;&amp; commands &amp;&amp; continue<br>    <br>    # translate<br>  done<br>&#125;<br></code></pre></div></td></tr></table></figure><p>一行一行解释，<code>read</code> 是 Shell 读取输入的方式，就像 Python的 input()、C++ 的 std::cin 、C 语言的 scanf() 等。<code>-p</code>表示不换行，后面跟着提示符 <code>&gt;</code>，然后就是读取的字符。我们使用 <code>while</code>读取循环，也就说，只有存在输入的时候才执行下面的语句，避免一直循环占用内存。</p><p>下一行表示，如果没有输入——例如我们直接回车——那继续循环，不执行命令。</p><p>再下一行表示，如果 <code>query</code> 包含 <code>cmd</code>字符串，那就执行 commands 函数，然后继续循环，不执行后面的语句。</p><blockquote><p>Shell 中判断是否包含某一字符串使用 <code>=~</code> ，例如 A字符串是否包含 B 字符串</p><blockquote><p>[[ A =~ B ]]</p></blockquote></blockquote><p>再后面就是我们的翻译语句了。</p><p><strong>拷贝</strong>我们的翻译语句，放到 <code>#translate</code>的位置，就像这样：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">function interact()&#123;<br><br>  while read -p &quot;&gt;&quot; query; do<br>    [[ -z &quot;$query&quot; ]] &amp;&amp; continue<br>    [[ &quot;$query&quot; =~ &quot;cmd &quot; ]] &amp;&amp; commands &amp;&amp; continue<br>    <br>    sign=$(echo -n &quot;$appid$query$salt$token&quot; | md5sum | cut -c 1-32)<br><br>    query=$(echo &quot;$query&quot; | tr -d &#x27;\n&#x27; | xxd -plain | sed &#x27;s/\(..\)/%\1/g&#x27;)<br>    query=$(echo $query | sed &#x27;s/ //g&#x27; )<br><br>    result=$(curl &quot;$basic_url?q=$query&amp;from=$from&amp;to=$to&amp;appid=$appid&amp;salt=$salt&amp;sign=$sign&quot; 2&gt;/dev/null)<br>    result=&quot;$&#123;result##*dst\&quot;:\&quot;&#125;&quot;<br>    echo -e $&#123;result%\&quot;\&#125;\]\&#125;&#125;<br>  done<br>&#125;<br><br>declare -i interaction=0<br>while [ $# -gt 0 ]; do<br>  case $1 in<br>    &#x27;-t&#x27;|&#x27;--to&#x27;) to=$2 &amp;&amp; shift ;;<br>    &#x27;-f&#x27;|&#x27;--from&#x27;) from=$2 &amp;&amp; shift ;;<br>    &#x27;-q&#x27;|&#x27;--query&#x27;) query=$2 &amp;&amp; shift ;;<br>    &#x27;-h&#x27;|&#x27;--help&#x27;) usage &amp;&amp; exit 0 ;;<br>    &#x27;-l&#x27;|&#x27;--list&#x27;) language_support &amp;&amp; exit 0 ;;<br>    &#x27;-i&#x27;|&#x27;--interact&#x27;) interaction=1 ;;<br>  esac<br>  shift<br>done<br><br>[ -z $from ] &amp;&amp; from=&#x27;auto&#x27;<br>[ -z $to ] &amp;&amp; to=&#x27;zh&#x27;<br><br>[ $interaction -eq 1 ] &amp;&amp; interact &amp;&amp; exit 0<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">翻译</span><br>sign=$(echo -n &quot;$appid$query$salt$token&quot; | md5sum | cut -c 1-32)<br><br>query=$(echo &quot;$query&quot; | tr -d &#x27;\n&#x27; | xxd -plain | sed &#x27;s/\(..\)/%\1/g&#x27;)<br>query=$(echo $query | sed &#x27;s/ //g&#x27; )<br><br>result=$(curl &quot;$basic_url?q=$query&amp;from=$from&amp;to=$to&amp;appid=$appid&amp;salt=$salt&amp;sign=$sign&quot; 2&gt;/dev/null)<br>result=&quot;$&#123;result##*dst\&quot;:\&quot;&#125;&quot;<br>echo -e $&#123;result%\&quot;\&#125;\]\&#125;&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到，有好多重复的语句，特别是翻译的部分，所以我们写一个翻译的函数，直接调用：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">function translate()&#123;<br><br>  sign=$(echo -n &quot;$appid$query$salt$token&quot; | md5sum | cut -c 1-32)<br><br>  query=$(echo &quot;$query&quot; | tr -d &#x27;\n&#x27; | xxd -plain | sed &#x27;s/\(..\)/%\1/g&#x27;)<br>  query=$(echo $query | sed &#x27;s/ //g&#x27; )<br><br>  result=$(curl &quot;$basic_url?q=$query&amp;from=$from&amp;to=$to&amp;appid=$appid&amp;salt=$salt&amp;sign=$sign&quot; 2&gt;/dev/null)<br>  result=&quot;$&#123;result##*dst\&quot;:\&quot;&#125;&quot;<br>  echo -e $&#123;result%\&quot;\&#125;\]\&#125;&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后脚本变成</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">function interact()&#123;<br><br>  while read -p &quot;&gt;&quot; query; do<br>    [[ -z &quot;$query&quot; ]] &amp;&amp; continue<br>    [[ &quot;$query&quot; =~ &quot;cmd &quot; ]] &amp;&amp; commands &amp;&amp; continue<br>    <br>    translate<br>  done<br>&#125;<br><br>declare -i interaction=0<br>while [ $# -gt 0 ]; do<br>  case $1 in<br>    &#x27;-t&#x27;|&#x27;--to&#x27;) to=$2 &amp;&amp; shift ;;<br>    &#x27;-f&#x27;|&#x27;--from&#x27;) from=$2 &amp;&amp; shift ;;<br>    &#x27;-q&#x27;|&#x27;--query&#x27;) query=$2 &amp;&amp; shift ;;<br>    &#x27;-h&#x27;|&#x27;--help&#x27;) usage &amp;&amp; exit 0 ;;<br>    &#x27;-l&#x27;|&#x27;--list&#x27;) language_support &amp;&amp; exit 0 ;;<br>    &#x27;-i&#x27;|&#x27;--interact&#x27;) interaction=1 ;;<br>  esac<br>  shift<br>done<br><br>[ -z $from ] &amp;&amp; from=&#x27;auto&#x27;<br>[ -z $to ] &amp;&amp; to=&#x27;zh&#x27;<br><br>[ $interaction -eq 1 ] &amp;&amp; interact &amp;&amp; exit 0<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">翻译</span><br>translate<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203261129188.png"alt="交互" /></p><p>接下来写 <code>commands</code>. 编写 <code>commands</code>函数之前我们知道，其内部的解析实际上和解析脚本参数基本一样，所以我们要做的就是去除<code>cmd</code>字符串，然后把后面的参数发给原本的参数解析函数——原本只是普通语句，我们也需要把它封装起来，所以就变成下面这样：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">...</span><br><br>function commands()&#123;<br><br>  local args=$(echo &quot;$query&quot; | sed &#x27;s/cmd\ //g&#x27;)<br>  query=&#x27;&#x27;<br>  settings $args<br>&#125;<br><br>function interact()&#123;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">...</span><br>&#125;<br><br>declare -i interaction=0<br><br>function settings()&#123;<br><br>  while [ $# -gt 0 ]; do<br>    case $1 in<br>      &#x27;-t&#x27;|&#x27;--to&#x27;) to=$2 &amp;&amp; shift ;;<br>      &#x27;-f&#x27;|&#x27;--from&#x27;) from=$2 &amp;&amp; shift ;;<br>      &#x27;-q&#x27;|&#x27;--query&#x27;) query=$2 &amp;&amp; shift ;;<br>      &#x27;-h&#x27;|&#x27;--help&#x27;) usage &amp;&amp; return 0 ;;<br>      &#x27;-l&#x27;|&#x27;--list&#x27;) language_support &amp;&amp; return 0 ;;<br>      &#x27;-i&#x27;|&#x27;--interact&#x27;) interaction=1 ;;<br>      *） query=$1 ;;<br>    esac<br>    shift<br>  done<br>&#125;<br><br>settings $@<br><br>[ -z $from ] &amp;&amp; from=&#x27;auto&#x27;<br>[ -z $to ] &amp;&amp; to=&#x27;zh&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">...</span><br></code></pre></div></td></tr></table></figure><p>鉴于放到了函数里，我们就不使用 <code>exit 0</code> 了，而是改成<code>return 0</code> . 而且，我们的 <code>while</code>循环多了一个分支<code>*</code>，这个表示，如果没有任何标志的话，默认直接翻译无法解析的参数。其实就是一句话：脚本之前必须用<code>-q</code> 指明翻译的文本，现在不用了，可以这样用<code>./mt.sh text</code>。</p><p>至此，我们的脚本写完了。当然，眼尖的同志看到，我还没有实现<code>clear</code> 指令呢！没事，这让你们自己探索。</p><h1 id="后语">后语</h1><p>又超过三千字了，这使我不得不结束这篇文章。脚本可拓展的其实还很多，有兴趣可以试试。我附上两个脚本——mt1.sh和 mt.sh.前者是写这篇文章使用的脚本，后者是我之前写的完整的脚本。因为蓝奏云不支持<code>sh</code> 格式，所以我重命名为 <code>mt1.sh.txt</code> 和<code>mt.sh.txt</code>。下载之后只需要把扩展名中的 <code>.txt</code>删掉就可以了。</p><h1 id="相关脚本">相关脚本</h1><p>脚本: https://wwb.lanzoub.com/b017dhqaf 密码: chunshuyumao</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>翻译</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于百度翻译 API：手撸一个命令行翻译脚本</title>
    <link href="/2022/03/24/%E5%9F%BA%E4%BA%8E%E7%99%BE%E5%BA%A6%E7%BF%BB%E8%AF%91-API%EF%BC%9A%E6%89%8B%E6%92%B8%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BF%BB%E8%AF%91%E8%84%9A%E6%9C%AC/"/>
    <url>/2022/03/24/%E5%9F%BA%E4%BA%8E%E7%99%BE%E5%BA%A6%E7%BF%BB%E8%AF%91-API%EF%BC%9A%E6%89%8B%E6%92%B8%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BF%BB%E8%AF%91%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>今天费了九牛二虎之力，手撸了命令行翻译软件。原本是件好事，晚上准备记录的时候遇见了一件伤心事：我的Gitee 图床仓库被屏蔽了。不大清楚为什么自己的图片外链访问过多？想想 PicGO上是使用 Gitee的不在少数，偏偏我遇上了。看来自己的博客每次都有成千上万人浏览。不过我本就没有准备在一棵树上吊死，我还有sm.ms 图床，虽然慢了点。卑躬屈膝地给 Gitee管理员写了封信，好歹让我能备份自己的图片吧，咱也没啥要求了。既然如此，大家还是好好考虑一下要不要用Gitee，至少目前我是没办法用了。</p><p>闲话少叙，正事还没讲呢。</p><p>一直以来我都是用translate-shell<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://github.com/soimort/translate-shell/">[1]</span></a></sup>，一个简单的命令行翻译软件，给自己翻译。最近想想，我好像之前申请过百度翻译开放平台的一个账号。那时候我还用Windows，所以也使用<strong>知云文献翻译</strong><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="http://www.zhiyunwenxian.cn/">[2]</span></a></sup>。<strong>知云文献翻译</strong>还是很良心的，可惜没有Linux平台。<strong>知云</strong>允许自定义<ruby>百度翻译API<rt>ApplicationProgrammingInterface</rt></ruby>，好奇心驱使下我就申请了百度翻译的账号。后来用了多少没看，文献也啥好翻译的，时不时查一个词还不错。</p><p>translate-shell<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://sourceforge.net/projects/translate-shell.mirror/">[3]</span></a></sup> 功能强大，如果使用Linux，可以直接命令行安装，我用的 Manjaro Linux, 所以安装方式是：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo pacman -S translate-shell<br></code></pre></div></td></tr></table></figure><p>其他发行版就用你们熟悉的方式吧。安装完成之后使用 <code>trans</code>进行翻译。具体可以参照<ruby>帮助<rt>man</rt></ruby>。</p><p>使用一阵子之后，我突然也想搞自己的翻译软件？当然，我打算用 shell/bash直接写个脚本。其实这样也有好处：好歹让我习惯 bash的用法。话不多少，准备：</p><ol type="1"><li>百度翻译开发账号<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="https://fanyi-api.baidu.com/">[4]</span></a></sup></li><li>Linux 平台，可以是<ruby>适用于 Windows 的 Linux 子系统( WSL)<rt>Windows Subversion for Linux</rt></ruby>，Linux虚拟机、主机、服务器，Cygwin<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="https://www.cygwin.com/">[5]</span></a></sup>，也许 Windows 上的 Git Bash 也可以？</li></ol><p>我使用的是 Manjaro 5.15 内核，bash 是5.1。其实这些都不用在意：我列出来就是假装自己很懂而已，大多数情况下这些东东都是兼容的。</p><h1 id="申请百度翻译账号">申请百度翻译账号</h1><p>开工之前，我们先去百度翻译官网申请一个账号：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203/202203250946067.png"alt="申请账号" /></p><p>申请完之后选择<strong>文档与支持–&gt;开发者文档</strong>，选择右边的<strong>开通链接</strong>，选择<strong>通用翻译</strong>。其他的服务以后有兴趣自己试试。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251000872.png"alt="开通链接" /></p><p>填申请。因为我已经申请过通用翻译，所以这里开了一个其他翻译方式，对照着看就差不多了。填完之后直接申请，基本秒通过。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251002303.png"alt="申请" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251004510.png"alt="通过" /></p><p>完成之后选择<strong>开发者信息</strong>，记住右边的 <strong>APPID</strong> 和密<ruby>钥<rt>yuè</rt></ruby>。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251028435.png"alt="重要东东" /></p><p>选择<strong>文档与支持</strong>，<strong>接入服务</strong>版块介绍了<strong>通用翻译</strong>的一些信息，基础的翻译而已，不用太较真——<strong>开发者文档</strong>有<strong>通用翻译</strong>使用的介绍。接下来我们基本都是看<strong>通用翻译</strong>的<strong>开发文档</strong>。很大程度上，大家可以自己动手造，用不着看我的演示。不过我还是介绍自己踩过的坑。百度的开发者文档做的还挺好，后面还有各种语言的事例，如果不使用Bash 的话可以看看——我之前也用 Python 写过一个，觉得还可以。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251029605.png"alt="文档支持" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251031898.png"alt="通用翻译" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251032376.png"alt="使用方式" /></p><h1 id="开始制作">开始制作</h1><p>我后面基本是按照百度翻译的文档进行介绍，所以难免有抄袭的铁证。</p><p>首先是<strong>通用翻译</strong>的地址</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">https://fanyi-api.baidu.com/api/trans/vip/translate<br></code></pre></div></td></tr></table></figure><p>随便打开一个 Shell 脚本文件。我用 VIM 编辑器，所以使用 VIM 打开。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">vim mt.sh<br></code></pre></div></td></tr></table></figure><blockquote><p>因为 Bash 兼容性很强，现在的 Linux 基本都是配置 Bash，所以我可能会Shell 和 Bash 混用，大家只要知道我讲的是 Bash 就行了。</p><p>Bash 是 Bourne Again Shell 的缩写，以前有个 Bourne Shell, 所以是Again .</p><p>文件名叫做 mt.sh 是因为它是 My Translater，懒得写那么多字母，干脆就是mt.</p></blockquote><p>在脚本最上面写下</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">encoding:utf-8</span><br></code></pre></div></td></tr></table></figure><p>​ <imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251048397.png"alt="杀棒(shabang)" /></p><blockquote><p><code>#！</code> 这个符号读作 shabang 或者 hashbang.它的作用不用深究，例行公事写下来就行。</p><p>下面的 <code>encoding</code> 相信写过 Python的人都比较习惯，例行公事，不写也没事。</p></blockquote><p>接下来就是写下自己的信息，HTTPS 地址和APPID、密钥等。<code>declare -r</code> 声明这些是常量( Read Only)，可有可无，例行公事。文档中还提到 Salt参数，说是一个随机码，既然是随机的，我们也随便给它一个。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">翻译 HTTPS 地址</span><br>declare -r basic_url=&quot;https://fanyi-api.baidu.com/api/trans/vip/translate&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">APPID</span><br>declare -r appid=&quot;20222231001673136&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">密钥</span><br>declare -r token=&quot;L4Jr77zOjy91cKx9_4oP&quot;<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251053579.png"alt="信息" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251055525.png"alt="Salt" /></p><p>在 Linux 系统生成随机数的方式还是蛮多，我对 <code>openssl rand</code>比较满意，所以就用它了，在自己的脚本中写入:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">declare -r salt=$(openssl rand -base64 18|cut -c 10)<br></code></pre></div></td></tr></table></figure><ol type="1"><li>先看内部， <code>openssl rand</code>是一条指令，用于生成随机数，<code>-base64</code> 是使用 64个可打印的字符，<code>18</code> 表示我要生成 18 个字符。</li><li><code>|</code> 在 Linux中表示<strong>管道符</strong>，意思是把右边输出当作左边的输入。也就是说，<strong>管道符</strong>右边的输出是左边的输入。不了解也没事，知道这么一件事就可以了。</li><li><code>cut</code> 表示截断输入，通常是字符或者文件。<code>-c</code>表示按照字符截断，<code>10</code> 表示截取第 10 个字符。如果想截取 10个字符，需要用 <code>1-10</code>。原本我是想截取 10个的，但是发现的时候已经截图了，那就算了。</li><li><code>$()</code>表示获取括号里边计算的结果。简而言之就是，获取括号里指令的结果。</li></ol><p>上面的 <code>cut -c 10</code> 指令可有可无，一来文档没有说 Salt有没有长度限制，二来其实管道符右边的式子也可以控制生成的长度。随便吧，最简单就是以下的表示：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">declare -r salt=$(openssl rand -base64 10)<br></code></pre></div></td></tr></table></figure><h2 id="签名">签名</h2><p>接下来准备生成<ruby>签名<rt>sign</rt></ruby>。什么是<ruby>签名<rt>sign</rt></ruby>？其实就是我们翻译的请求信息。根据文档要求，签名应该长这样:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">MD5(appid+q+salt+token)<br></code></pre></div></td></tr></table></figure><p>其中，<code>q</code> 是 query 的缩写，就是我们想要翻译的文字，UTF-8编码——不了解编码不用管，知道就行。</p><p>我们准备了 appid、salt 和 token 了，现在只差q。为了方便调试，我们声明一个 q, 取名 query。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">delcare query=&quot;like&quot;<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251121224.png"alt="query" /></p><p>首先拼接字符串，然后取 MD5</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">tmpStr=<span class="hljs-string">&quot;$appid$query$salt$token&quot;</span><br>sign=<span class="hljs-constructor">$(<span class="hljs-params">echo</span> -<span class="hljs-params">n</span> <span class="hljs-params">tmpStr</span> | <span class="hljs-params">md5sum</span> | <span class="hljs-params">cut</span> -<span class="hljs-params">c</span> 32)</span><br></code></pre></div></td></tr></table></figure><p>解释一下，我们用 <code>md5sum</code> 生成 MD5，然后只取 32个字符——因为文档说我们只需要 32 位。Shell 语言和 Perl语言很相似，可能在其他高级语言里想要获取某一个变量的值，我们可以直接使用这个变量名；但是在Shell 里，我们需要用 <code>$</code>符号获取变量值，最正规的方式是：<code>$&#123;appid&#125;</code>。因为要拼接成一个字符串，所以建议拼接的两边加上双引号。Shell的字符串拼接也很有趣，直接把两个字符串放一起就行了。</p><blockquote><p><code>-n</code> 非常重要，别丢了</p></blockquote><p>举个例子，其他语言的语言拼接：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">python</span><br>str1 = &quot;Hello&quot;<br>str2 = &quot;World&quot;<br>str3 = str1 + str2<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">cpp</span><br>std::string str1&#123; &quot;Hello&quot; &#125;;<br>std::string str2&#123; &quot;World&quot; &#125;;<br>std::string str3&#123; str1 + str2 &#125;;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">lua</span><br>local str1 = &quot;Hello&quot;<br>local str2 = &quot;World&quot;<br>local str3 = str1..str2<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Shell/Perl</span><br>str1=&quot;Hello&quot;<br>str2=&quot;World&quot;<br>str3=&quot;$str1$str2&quot;<br></code></pre></div></td></tr></table></figure><p>闲话少叙，其实上面的两行可以写成一行：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sign=$(echo -n &quot;$appid$query$salt$token&quot; | md5sum | cut -c 32)<br></code></pre></div></td></tr></table></figure><h2 id="翻译">翻译</h2><p>获取签名之后就可以使用百度翻译提供的 API 翻译了。在 Shell脚本中，我们使用大名鼎鼎的 cURL 进行网路请求。首先声明，我对 cURL不熟，一般我都不用它——因为学不会。</p><p>cURL 请求的命令是：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">curl url<br></code></pre></div></td></tr></table></figure><p>所以我们需要提供一个 url. 上面我们准备了百度翻译的 API,现在开始拼接。在脚本中输入：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">url=&quot;$basic_url?q=$query&amp;from=en&amp;to=zh&amp;appid=$appid&amp;salt=$salt&amp;sign=$sign&quot;<br>curl &quot;$url&quot;<br></code></pre></div></td></tr></table></figure><p>或者直接一行</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">curl &quot;$basic_url?q=$query&amp;from=en&amp;to=zh&amp;appid=$appid&amp;salt=$salt&amp;sign=$sign&quot;<br></code></pre></div></td></tr></table></figure><p>如果使用 VIM，那就 <kbd>Esc</kbd>，然后输入<code>:wq</code>，回车退出。在命令行上输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">chmod u+x mt.sh<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251220209.png"alt="给予可执行权限" /></p><p>输入 <code>./mt.sh</code> 执行脚本。可以看到有返回了，结果就在<code>dst</code> 里边。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251255943.png"alt="结果" /></p><p>现在要做的就是取出我们的结果，使用 <code>-e</code> 进行转义输入：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">result=$(curl &quot;$basic_url?q=$query&amp;from=en&amp;to=zh&amp;appid=$appid&amp;salt=$salt&amp;sign=$sign&quot;)<br>echo -e &quot;$result&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者直接一行</span><br>echo -e &quot;$(curl &quot;$basic_url?q=$query&amp;from=en&amp;to=zh&amp;appid=$appid&amp;salt=$salt&amp;sign=$sign&quot;)&quot;<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251258949.png"alt="转义" /></p><h2 id="字符串截断">字符串截断</h2><p>在获取结果之前，我们先说说如何在 Shell中截取字符串。就拿我们上面的字符串做例子。现在我们要做的是把“喜欢”取出来。使用下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">result=&quot;$&#123;result##*dst\&quot;:\&quot;)&quot;<br>echo -e $&#123;result%\&quot;\&#125;\]\&#125;&#125;<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251308513.png"alt="获取结果" /></p><p>解释一下：</p><ol type="1"><li><p>首先，分割字符串使用 <code>#</code> 和 <code>%</code>，前者表示从左往右删除，后者表示从右往左删除。举个例子<code>str='chunshuyumao'</code> 如果我想删掉 <code>chunshu</code>，就用<code>$&#123;str#chunshu&#125;</code>。如果我懒了，不想写那么多个字母，那就写成这样<code>$&#123;str#*shu&#125;</code>，用 <code>*</code> 表示任意字符，这样只要找到了<code>shu</code>，就把 <code>shu</code>和它之前的字符全删掉。同理，<code>%</code> 表示从右边开始算起。那两个<code>#</code> 表示什么？在 Linux中有个习惯，两个东西通常表示极端——例如在 VIM 中，<code>d</code>表示删除，<code>dd</code> 就直接删除一行；<code>y</code>表示复制，<code>yy</code> 就直接复制一行。<code>#</code>表示从左边找的第一个符合条件的字符串，两个 <code>#</code>就是从左边找的最后一个符合条件的字符串。举个例子</p><p><code>str="chunshuyumaoshuzhuang"</code>，如果用<code>$&#123;str#*shu&#125;</code> 就会得到 <code>yumaoshuzhuang</code> ,使用<code>$&#123;str##*shu&#125;</code> 就会得到<code>zhuang</code>。同理，<code>%%</code>表示从右边数最后一个匹配的字符串。</p></li><li><p>因为引号( “ ) 是特殊的字符串，所以我们用 <code>\</code>转义，所以第一行的原本想法是<code>$&#123;result#*dst":"&#125;</code>，加上转义字符之后就是<code>$&#123;result##*dst\":\"&#125;</code>。</p></li><li><p>括号也是特殊字符，所以一并转义</p></li></ol><p>这样就得到结果了。不过大家可能也看到下面的输出了，我们不希望有这个输出。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">  % </span><span class="language-bash">Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br>                                 Dload  Upload   Total   Spent    Left  Speed<br>100    76  100    76    0     0    301      0 --:--:-- --:--:-- --:--:--   301<br></code></pre></div></td></tr></table></figure><p>在脚本使用 cURL 的后面加上 <code>2&gt;/dev/null</code>这个语句是把一些不重要的输出放到 <code>/dev/null</code>这个文件。不用担心，这个文件没啥用。参看下面的结果：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">result=$(curl &quot;$basic_url?q=$query&amp;from=en&amp;to=zh&amp;appid=$appid&amp;salt=$salt&amp;sign=$sign&quot; 2&gt;/dev/null)<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251326986.png"alt="重定向输出" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251329558.png"alt="最后的结果" /></p><p>截至目前，你的脚本看起来是这样的：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">encoding:utf-8</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">翻译 HTTPS 地址</span><br>declare -r basic_url=&quot;https://api.fanyi.baidu.com/api/trans/vip/translate&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">你的 APPID</span><br>declare -r appid=&quot;xxxxxxxxxxxxxxxxxxxx&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">你的密钥</span><br>declare -r token=&quot;xxxxxxxxxxxxxxxxxxxx&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">random code</span> <br>declare salt=$(openssl rand -base64 18|cut -c 1-10)<br><br>declare query=&quot;like&quot;<br><br>sign=$(echo -n &quot;$appid$query$salt$token&quot; | md5sum | cut -c 1-32)<br>result=$(curl &quot;$basic_url?q=$query&amp;from=en&amp;to=zh&amp;appid=$appid&amp;salt=$salt&amp;sign=$sign&quot; 2&gt;/dev/null)<br>result=&quot;$&#123;result##*dst\&quot;:\&quot;&#125;&quot;<br>echo -e $&#123;result%\&quot;\&#125;\]\&#125;&#125;<br></code></pre></div></td></tr></table></figure><p>既然已经成功了，我们开始修改 query 的内容。</p><h2 id="输入">输入</h2><p>第一个要解决的就是 query 的输入问题。我们希望这样使用自己的翻译器<code>./mt.sh "English"</code>. Shell脚本和其他语言一样，可以获取它的命令行参数。听不懂没事，假设我这样调用自己的脚本：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">./mt.sh chun shu yu mao<br></code></pre></div></td></tr></table></figure><p><code>./mt.sh</code>、<code>chun</code>、<code>shu</code>、<code>yu</code>、<code>mao</code>就是命令行参数。脚本中使用 <code>$n</code> 的方式获取参数，其中<code>n</code> 表示阿拉伯数字。我下面输出一下参数</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251338985.png"alt="输出参数" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251338982.png"alt="输出参数" /></p><p>知道这个之后，我们修改一下自己的脚本：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">declare query=&quot;$1&quot;<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251419011.png"alt="桉树输入" /></p><p>单词可以输入了，我们试着输入句子如何？</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251419770.png"alt="句子" /></p><p>失败了，很显然没有结果，我们试着打印 <code>result</code>。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251420484.png"alt="打印结果" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251428364.png"alt="打印" /></p><p>没有任何反馈。其实这是因为我们的句子有问题，看一下文档：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251428097.png"alt="URL encode" /></p><p>我们发送请求的时候需要进行编码。举个例子，上浏览器上搜<code>I'm so handsome</code> 的时候，地址栏显示是<code>I'm+so+handsome</code> .类似这种就是编码——实际并非完全如此，知道大概就行。文档说使用 URLEncoding，直接使用我给的式子就行：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251428869.png"alt="URL encode" /></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">declare query=&quot;$1&quot;<br><br>sign=$(echo -n &quot;$appid$query$salt$token&quot; | md5sum | cut -c 1-32)<br><br>query=$(echo &quot;$query&quot; | tr -d &#x27;\n&#x27; | xxd -plain | sed &#x27;s/\(..\)/%\1/g&#x27;)<br>query=$(echo $query | sed &#x27;s/ //g&#x27; )<br><br>result=$(curl &quot;$basic_url?q=$query&amp;from=en&amp;to=zh&amp;appid=$appid&amp;salt=$salt&amp;sign=$sign&quot; 2&gt;/dev/null)<br>result=&quot;$&#123;result##*dst\&quot;:\&quot;&#125;&quot;<br>echo -e $&#123;result%\&quot;\&#125;\]\&#125;&#125;<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251437661.png"alt="翻译句子" /></p><p>ok,基本完成了。到这里，脚本实现翻译已经完成了。如果你觉得这已经不错了，那就可以结束这篇文章了。如果觉得还想要改进，那就继续阅读。</p><h2 id="扩展">扩展</h2><p>我们用脚本和百度翻译 API完成了自己的第一个翻译脚本。接下来进行多语言拓展。首先我们看一下百度支持的常用翻译：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251441719.png"alt="支持的翻译" /></p><p>翻译的语言信息要放哪里呢？来看看我们之前写的请求地址：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">result=$(curl &quot;$basic_url?q=$query&amp;from=en&amp;to=zh&amp;appid=$appid&amp;salt=$salt&amp;sign=$sign&quot; 2&gt;/dev/null)<br></code></pre></div></td></tr></table></figure><p>上面我们从哪种语言翻译过去，就使用 <code>from=代号</code>,翻译成哪种语言就用<code>to=代号</code>。好的，我们改改，改成翻译为文言文：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">result=$(curl &quot;$basic_url?q=$query&amp;from=en&amp;to=wyw&amp;appid=$appid&amp;salt=$salt&amp;sign=$sign&quot; 2&gt;/dev/null)<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251447688.png"alt="文言文翻译" /></p><p>为了让使用者可以控制翻译的设置，我们可以添加一些参数，例如我已经做好的脚本：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251500470.png"alt="help" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251509696.png"alt="列出支持的语言" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251513256.png"alt="中英翻译" /></p><p>所以接下来，我们就要实现上面这些功能——不过不是现在。</p><h1 id="相关网址">相关网址</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span>https://github.com/soimort/translate-shell/<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>http://www.zhiyunwenxian.cn/<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3"class="footnote-text"><span>https://sourceforge.net/projects/translate-shell.mirror/<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>https://fanyi-api.baidu.com/<a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:5" class="footnote-text"><span>https://www.cygwin.com/<a href="#fnref:5" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>翻译</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器安装 RStudio-Server</title>
    <link href="/2022/03/18/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85RStudio-Server/"/>
    <url>/2022/03/18/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85RStudio-Server/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>RStudio Server 是 RStudio的服务器版。单机版其实也已经够用，可是有些时候我们需要进行迁移或者跨平台使用，重新安装一遍非常麻烦。我的服务器只有2G内存，比不上我的电脑，没理由使用服务器不用自己的电脑。可惜服务器不用也是浪费，而且自己配置也是一种乐趣，所以就花了点时间。其实这也和我不愿意安装各种客户端有关。</p><p>折腾好一天才成功在服务器安装 RStudioServer。这里奉劝天下士，有事没事真别浪费时间在国内找网上的资料，要真的有问题不行了，去相关的技术论坛找问题或者好好跟着官网教程走，不然就是在浪费生命。</p><p>本次安装的平台和软件:</p><ol type="1"><li>Miniconda3 Linux 64-bit。使用 conda 管理多版本 R 语言和Python。</li><li>RStudio Server v2022.02.0+443。RStudio的服务器版本，可以通过浏览器接入。</li><li>ECS 共享型 n4 单核2G内存服务器，Rocky Linux 8.5 版，兼容 CentOS7/8和 RHEL8 及以上版本。</li></ol><p>我会带大家一步一步踩坑，所有按我教程走的时候遇到问题不用紧张——毕竟俺就是这么来的。</p><h1 id="miniconda3">Miniconda3</h1><p>R语言是免费开源的编程语言，被广泛运用到科学计算领域，被称为科学家的编程语言。R语言这年头最为人所知的能力就是画图和数据分析。大数据分析时代，R 与Python 齐驱并进（虽然 Python 是后来者居上）。与 Python 相比，R语言独有的特点是版本不兼容：R语言一般不具有向前向后兼容性，低版本使用得了的<ruby>包<rt>package</rt></ruby>高版本一般使用不了。正因如此，你会看到很多学者的电脑安装各种版本的R 语言。</p><p>在 Linux 上安装 R语言可能直接安装到系统路径，想使用多个版本就容易起冲突。解决这个问题最普遍的思想是通过虚拟环境管理器管理R 语言版本。</p><p>Python 我就不多说了。Python 最著名的包管理器是 PIP.默认情况下只要安装了 Python 就会自带这个东西。PIP提供了简单的包查询、下载、查找和卸载功能，一般不解决依赖问题。正常情况下不会有什么大毛病，一碰到科学计算包就不好看了。举个例子，如果我要安装A 包，A 包里边使用了 B 包，PIP 安装就会出错。好心的话，PIP会提醒你少了某种东西，可惜大多数时候它只会和你一样懵。</p><p>为了更好的解环境包依赖问题，有一群人开始思考某种新的包管理器，conda由此而生。conda 成功解决了依赖问题——你没安装的东西它会帮你安装——并发展成<ruby>包管理系统<rt>package management system</rt></ruby>、<ruby>环境管理系统<rt>environment managementsystem</rt></ruby>，而且还兼管多种语言的版本管理——当然最常用的就是 R 和Python.</p><p>conda 一般不能单独安装，想要使用它需要安装 Anaconda。Anaconda 和Python 同祖同宗，都是大蛇。Anaconda预安装上百个科学包，基本不用愁。可惜大多数我们都用不上。用不上又得安装，动辄几个G 的内存看起来很恶心。鉴于此，Miniconda 横空出世：它也使用 conda解决包依赖问题，但不像 Anaconda什么都安装，它只保留最少的软件包，剩下你需要啥就装啥。对于内存捉襟见肘的小伙伴来说，这简直是福音。因此我打算安装Miniconda3.</p><h2 id="安装-miniconda3">安装 Miniconda3</h2><p>到官网<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://docs.conda.io/en/latest/miniconda.html">[1]</span></a></sup>下载对应系统的版本。我要安装到 Linux服务器，所以选择 <ahref="https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh">Miniconda3Linux 64-bit</a> 。使用你喜欢的下载方式下载，我用 axel.</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">axel <span class="hljs-literal">-n</span> <span class="hljs-number">32</span> https://repo.anaconda.com/miniconda/Miniconda3<span class="hljs-literal">-latest-Linux-x86_64</span>.sh<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181615732.png"alt="选择版本" /></p><p>下载完之后，使用<code>ls</code>查看自己的目录下有没有以下脚本。如果没有需要继续下载。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181628572.png"alt="下载的脚本" /></p><p>给予脚本可执行权限：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">chmod u+x Miniconda3-latest-Linux-x86_64.sh<br></code></pre></div></td></tr></table></figure><p>然后执行</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">./Miniconda3-latest-Linux-x86_64.sh<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181631221.png"alt="执行" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181631078.png"alt="一直 Enter 回车" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181632355.png"alt="选择 yes 确认安装" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181637069.png"alt="选择安装位置" /></p><p>安装位置通常是你的家目录，例如我的家目录是<code>/home/chunshuyumao</code>，所以安装位置是<code>/home/chunshuyumao/miniconda3</code>，你也可以在<code>&gt;&gt;&gt;</code>之后修改自己的路径。建议还是安装到自己的家目录下。</p><p>安装完毕它会问你是否激活 conda 环境，选择 yes会在每次打开控制台时自动激活 conda 的默认环境base。如果不想默认开启就选择 no. 如果无意中选择了 yes, 也可以通过输入<code>conda config --set auto_activate_base false</code>取消激活。一般我选择 yes，然后再输入命令取消。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181736554.png"alt="默认激活" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181740692.png"alt="选择 yes" /></p><p>安装完之后重新登陆控制台可以看到 conda命令可以使用了，或者不用重启登陆，只需输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">source ~/.bashrc<br></code></pre></div></td></tr></table></figure><p>其中 <code>~/.bashrc</code> 是你的 shell 的配置文件，我使用的是 zsh,所以输入的是 <code>source ~/.zshrc</code>。输入 <code>conda -V</code>查看安装是否成功。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181743461.png"alt="查看版本" /></p><h2 id="配置国内源">配置国内源</h2><p>conda 不配置国内源速度会很慢，输入以下代码配置国内源：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free<br>conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r<br>conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main<br>conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda<br>conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge<br></code></pre></div></td></tr></table></figure><p>配置国内源之后安装 mamba —— mamba 可以看作是更快的 conda. 由于 conda没想到自己发展那么快，随着包越来越多，解析依赖的速度越来越慢，对于一些大型的包需要解决的依赖更多——这时候conda 显得力不从心，于是诞生了 mamba这个更快的包管理。不想了解这段历史的话直接安装 mamba就对了。安装之后进行简单的升级，确认一下</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">conda install mamba -y<br>mamba update conda -y<br>conda update mamba -y<br></code></pre></div></td></tr></table></figure><h2 id="安装-r-语言">安装 R 语言</h2><p>conda通过创建多个<ruby>环境<rt>encironment</rt></ruby>管理语言的版本，要安装多版本需要创建环境。后面使用的Seurat 包需要 R 语言的版本高于 4.0 ，所以创建一个高版本的 R语言环境：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">conda create -n r4.1.2 -y<br></code></pre></div></td></tr></table></figure><blockquote><p><code>-n</code> 指定环境的名字，为了方便区分，我直接命名为<code>r4.1.2</code> ，意思是要安装 4.1.2 版本。<code>-y</code> 是 yes,就是直接确认创建，不用再询问。</p></blockquote><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181804758.png"alt="创建 R 语言环境" /></p><p>激活环境，输入<code>conda activate r4.1.2</code>。如下图，右边提示现在是<code>r4.1.2</code> 环境</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181805983.png"alt="激活环境" /></p><p>想使用哪个环境就激活那个环境。</p><blockquote><p>如果想关闭环境，使用 <code>conda deactivate</code></p></blockquote><p>安装 R 语言 4.1.2 版</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">mamba install r-base==4.1.2 -y<br></code></pre></div></td></tr></table></figure><p>安装完毕输入 <code>R</code>回车，查看是否有问题。如果进入以下界面就说明安转成功，输入<code>quit()</code> 退出 R 语言的交互界面。</p><p>同理，想要安装其他版本的 R语言，需要创建一个新环境，然后激活它再安装版本——使用 <code>==</code>指定语言版本，不指定的话默认安装最新版。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181842541.png"alt="检验安装是否成功" /></p><p>退出的时候它会问是否保存工作环境，一般不用保存，输入 <code>n</code>即可</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181843681.png"alt="不保存工作环境" /></p><h2 id="安装-python">安装 Python</h2><p>创建新环境，安装最新版 Python：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">conda create -n py3.10 -y<br>mamba install -n py3.10 python==3.10 -y<br></code></pre></div></td></tr></table></figure><p>这里在 <code>install</code> 的时候没有激活 py3.10 环境，所以需要使用<code>-n</code> 指定安装 Python3.10 的环境。</p><p>安装完之后输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">conda info --envs<br></code></pre></div></td></tr></table></figure><p>查看我们现有的环境</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181849999.png"alt="现有的环境" /></p><p>可以看到，我们现在有三个环境: base, py3.10, r4.1.2。其中激活的是py3.10。</p><blockquote><p>哪个环境是激活的会有一个 <code>*</code> 标注。</p></blockquote><h1 id="安装-rstudio-server">安装 RStudio Server</h1><h2 id="安装">安装</h2><p>接下来到官网<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.rstudio.com/products/rstudio/download-server/">[2]</span></a></sup>安装 RStudio Server. 选择你的系统，我用的是 RHEL系列，点击第一个系统进入安装教程。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181852320.png"alt="选择系统" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181853918.png"alt="安装教程" /></p><p>首先是下载安装包。使用 <code>wget</code> 就按照官网说的下载，使用<code>curl</code> 就用 <code>curl</code> 下载，使用 <code>axel</code>就用 <code>axel</code> 下载，下面三种下载方式选一种：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">wget https://download2.rstudio.org/server/centos7/x86_64/rstudio-server-rhel-2022.02.0-443-x86_64.rpm<br>curl -O https://download2.rstudio.org/server/centos7/x86_64/rstudio-server-rhel-2022.02.0-443-x86_64.rpm<br>axel -n 32 https://download2.rstudio.org/server/centos7/x86_64/rstudio-server-rhel-2022.02.0-443-x86_64.rpm<br></code></pre></div></td></tr></table></figure><p>确认下载成功：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181856163.png"alt="确认下载成功" /></p><p>安装：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo yum install rstudio-server-rhel-2022.02.0-443-x86_64.rpm -y<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181859478.png"alt="安装完毕" /></p><p>允许自启动，并启动它：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo systemctl enable rstudio-server<br>sudo systemctl start rstudio-server<br>sudo systemctl status rstudio-server<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181900768.png"alt="一般会启动失败" /></p><p>不用担心，启动失败很正常。输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo rstudio-server verify-installation</span><br><br>TTY detected. Printing informational message about logging configuration. Logging configuration loaded from &#x27;/etc/rstudio/logging.conf&#x27;. Logging to &#x27;/var/log/rstudio/rstudio-server/rserver.log&#x27;.<br>Path to R not specified, and no module binary specified; Invalid R module ()<br></code></pre></div></td></tr></table></figure><p>上面显示的错误是找不到 R 语言的路径，这个简单，我们配置一下 R语言的路径。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo vim /etc/rstudio/rserver.conf<br></code></pre></div></td></tr></table></figure><p>按 <kbd>Shift</kbd>+<kbd>g</kbd> 转到最后一行，按 <kbd>o</kbd>输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">rsession-which-r=/home/chunshuyumao/miniconda3/envs/r4.1.2/bin/R<br></code></pre></div></td></tr></table></figure><p>其中，<code>/home/chunshuyumao</code>写你的家目录，这里是我的家目录，miniconda3 安装在哪里就使用哪个目录。我创建的 R 语言环境在 miniconda3<ruby>虚拟环境目录<rt>envs</rt></ruby>下的<code>r4.1.2</code>。如果你不确定你的 R 语言在哪里，可以激活环境之后使用<code>which R</code> 查看，例如：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181912027.png"alt="which R" /></p><p>上面图中的 <code>~</code> 代表 <code>/home/chunshuyumao</code>也就是你的家目录。</p><p>配置完之后，按一下 <kbd>Esc</kbd> 键，然后输入 <code>:wq</code>，回车就可以了。再次输入<code>sudo rstudio-server verify-installation</code>，发现仍然有问题。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181914017.png"alt="修改路径" /></p><p>配置库路径</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo vim /etc/rstudio/rserver.conf<br></code></pre></div></td></tr></table></figure><p>按 <kbd>Shift</kbd>+<kbd>g</kbd> 转到最后一行，按 <kbd>o</kbd>输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">rsession-ld-library-path=/home/chunshuyumao/miniconda3/envs/r4.1.2/lib:/home/chunshuyumao/miniconda3/envs/r4.1.2/lib/R/lib<br></code></pre></div></td></tr></table></figure><p>把 <code>/home/chusnhuyumao</code>改成你的家目录，<code>r4.1.2</code>改为你的 R 语言虚拟环境名即可。</p><p>按一下 <kbd>Esc</kbd> 键，然后输入 <code>:wq</code> ，回车退出。</p><p>重启试试:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo systemctl restart rstudio-server<br>sudo rstudio-server verify-installation<br></code></pre></div></td></tr></table></figure><p>出现下面提示说明你已经成功</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">Server is running and must be stopped before running verify-installation<br></code></pre></div></td></tr></table></figure><p>如果提示<code>error while loading shared libraries: libssl.so.10</code>，请跳到<a href="#prob">4</a>。</p><p>RStudio Server 默认监听 8787 端口，可以使用<code>sudo netstat -an4p | grep 8787</code> 查看 rserver 是否启动</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181930508.png"alt="查看端口" /></p><blockquote><p>如果提示没有 <code>netstat</code> 这个命令，请先安装<code>sudo yum install -y net-tools</code></p></blockquote><p>开启防火墙的话，开放一下 8787 端口：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo firewall-cmd --add-port=8787/tcp --permanent<br>sudo firewall-cmd --reload<br></code></pre></div></td></tr></table></figure><h2 id="测试登录">测试登录</h2><p>浏览器输入 <code>IP:8787</code>，这个 IP 是公网 IP。登陆使用的是你服务器的帐号和密码。</p><blockquote><p>如果你在虚拟机上尝试，请使用虚拟机的 IP，使用 <code>ip addr</code>查看， inet 之后就是你的 IP</p></blockquote><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181940261.png"alt="登陆" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181941757.png"alt="登陆成功" /></p><p>Rstudio Server 搭建完毕。</p><h1 id="一些问题"><a name="prob">一些问题</a></h1><p>来到这里的都是因为这条错误：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">/usr/lib/rstudio-server/bin/rsession: error while loading shared libraries: libR.so: cannot open shared object file: No such file or directory<br></code></pre></div></td></tr></table></figure><p>这和 OpenSSL 有关。我在 Rocky Linux 8.5 遇到的问题，使用 CentOS7虚拟机没有碰到。查看库目录存在 libssl的各个版本，创建软链接想要骗过系统发现不行，最后使用 yum search看到了<code>compat-openssl10</code>包，看标签应该是兼容包，安装之后发现没问题，就此记录。</p><p>安装 <code>compat-openssl10.x86_64</code>后再次重启 RStudio Server服务。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo yum install compat-openssl10.x86_64 -y<br>sudo systemctl restart rstudio-server<br>sudo systemctl status rstudio-server<br></code></pre></div></td></tr></table></figure><h1 id="安装-scanpy-和-seurat">安装 Scanpy 和 Seurat</h1><p>Scanpy 和 Seurat 是数据分析使用的，个人安装，可以不用看。</p><h2 id="安装-scanpy">安装 Scanpy</h2><p>到 Scanpy官网<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://scanpy.readthedocs.io/en/stable/installation.html">[3]</span></a></sup>查看下载 Scanpy 教程</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181958423.png"alt="安装 Scanpy" /></p><p>激活 Python 环境安装：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">conda activate py3.10<br>mamba install seaborn scikit-learn statsmodels numba pytables -y <br>mamba install python-igraph leidenalg -y<br>pip install scanpy -i https://pypi.tuna.tsinghua.edu.cn/simple<br></code></pre></div></td></tr></table></figure><blockquote><p>请注意，一定要使用 pip ，不是 pip3 。</p></blockquote><p>安装完毕，输入 <code>python</code>进入交互界面，<code>import scanpy</code> 成功就说明安装好了。</p><h2 id="安装-seurat">安装 Seurat</h2><p>安装Seurat<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://satijalab.org/seurat/">[4]</span></a></sup> 比较简单，激活 R 语言环境:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">conda activate r4.1.2<br>R<br>install.packages(&#x27;Seurat&#x27;)<br>install.packages(&#x27;dplyr&#x27;)<br>install.packages(&#x27;patchwork&#x27;)<br></code></pre></div></td></tr></table></figure><p>提示选择镜像源，可以选择北京——我这里是 17。选完直接回车。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203182010716.png"alt="镜像源" /></p><p>Linux 安装 Seurat 的时候会进行源码编译，用时较长，需要有耐性。如果是Windows 安装就比较快，直接二进制安装。</p><p>编译 Seurat 到一半提示</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">x86_64-conda-linux-gnu-c++: fatal error: Killed signal terminated program cc1plus<br></code></pre></div></td></tr></table></figure><p>这是因为我的服务器只有 2G内存，编译需要大量内存，显然内存不足。查看一下发现，我的服务器内存小就算了，还没有<ruby>交换分区<rt>swap</rt></ruby>，不卡死才怪。生成一个空文件，临时作为<ruby>交换分区文件<rt>swapfile</rt></ruby>：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo dd if=/dev/zero of=/swaptmp bs=4M count=1024<br></code></pre></div></td></tr></table></figure><p>解释一下，<code>swaptmp</code>是<ruby>交换分区<rt>swap</rt></ruby>的名字，随便取。位置在<code>/</code> 根目录下。 <code>bs</code>是<code>blocksize</code>，就是区块大小，不用管。 <code>count</code>是写入的区块个数，我写入 1024 块。</p><p>通过上面的命令，我创造了 4x1024M( 也就是 4G ) 大的文件。 为什么是 4G？因为我的内存为 2G, <ruby>交换分区<rt>swap</rt></ruby>最好不超过内存的2 倍。</p><blockquote><p>内存指的是物理内存，不是硬盘空间，我的配置是 2G 内存 + 40G硬盘空间</p></blockquote><p>完成之后格式化并启用<ruby>交换分区文件<rt>swap file</rt></ruby>：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo mkswap /swaptmp<br>sudo swapon /swaptmp<br></code></pre></div></td></tr></table></figure><p>继续编译 Seurat .</p><p>编译完不想保留<ruby>交换分区文件<rt>swapfile</rt></ruby>可以卸载：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo swapoff /swaptmp<br>sudo rm -rf /swaptmp<br></code></pre></div></td></tr></table></figure><p>不过依我看，如果你的内存不够编译Seurat，索性留着<ruby>交换分区<rt>swap</rt></ruby>也许更好。想要保留<ruby>交换分区文件<rt>swapfile</rt></ruby>，请进行以下配置：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo vim /etc/fstab<br></code></pre></div></td></tr></table></figure><p>按 <kbd>Shift</kbd>+<kbd>g</kbd> 转到最后一行，按 <kbd>o</kbd>输入</p><figure class="highlight avrasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs avrasm">/swaptmp <span class="hljs-keyword">swap</span> <span class="hljs-keyword">swap</span> defaults <span class="hljs-number">0</span> <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><p>按一下 <kbd>Esc</kbd> 键，然后输入 <code>:wq</code> ，回车退出。</p><h1 id="测试">测试</h1><p>登陆你的 RStudio Server. 输入</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">library</span><span class="hljs-params">(Seurat)</span></span><br><span class="hljs-function"><span class="hljs-title">library</span><span class="hljs-params">(dplyr)</span></span><br><span class="hljs-function"><span class="hljs-title">library</span><span class="hljs-params">(patchwork)</span></span><br></code></pre></div></td></tr></table></figure><p>没有报错就说明成功了。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203182028913.png"alt="测试" /></p><p><kbd>Ctrl</kbd>+<kbd>l</kbd>清空交互窗口，新建一个 R文件，输入以下内容：</p><figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">data<span class="hljs-operator">=</span><span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span> <span class="hljs-number">4</span><span class="hljs-punctuation">,</span> <span class="hljs-number">8</span><span class="hljs-punctuation">)</span><br><span class="hljs-built_in">names</span><span class="hljs-operator">=</span><span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-string">&quot;C++&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;C&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;Python&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;R&quot;</span><span class="hljs-punctuation">)</span><br>cols<span class="hljs-operator">=</span><span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-string">&#x27;black&#x27;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&#x27;blue&#x27;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&#x27;red&#x27;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&#x27;green&#x27;</span><span class="hljs-punctuation">)</span><br><br>pie<span class="hljs-punctuation">(</span>data<span class="hljs-punctuation">,</span> labels<span class="hljs-operator">=</span><span class="hljs-built_in">names</span><span class="hljs-punctuation">,</span> col<span class="hljs-operator">=</span>cols<span class="hljs-punctuation">)</span><br></code></pre></div></td></tr></table></figure><p>全选，点击界面右上角的 <ruby>运行<rt>run</rt></ruby>。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203182033434.png"alt="新建文件" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203182035833.png"alt="运行" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203182035471.png"alt="效果" /></p><p>点击 <ruby>工具<rt>Tools</rt></ruby> 选择 <ruby>全局选项<rt>GlobalOptions</rt></ruby> ，选择 <ruby>包<rt>Packages</rt></ruby>，修改<ruby>首要 CRAN 仓库<rt>Primary CRAN repository</rt></ruby>为离你最近的地方。选择 Python修改版本为你喜欢的版本——它会自动检测你服务器的 Python 版本。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203182036919.png"alt="设置" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203182037629.png"alt="修改镜像" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203182039945.png"alt="Python 版本" /></p><p>到这里，我们安装完 RStudio Server 还进行了简单的配置，完美收工。</p><h1 id="后语">后语</h1><p>原本我不想使用 RStudio Server，最开始的想法是安装 R 语言，然后 VSCode远程连接。之前在自己的虚拟机玩过，可以完美运行。因为没有图形界面，运行之后会产生一个PDF 文件，只需要在 VS Code 安装一个 PDF预览插件就可以了。不料今天各种问题：PDF 预览不了，R语言的提示用不了。最后我都要疯了。配置 RStudio Server的时候上不去官网查看教程，于是上网搜。真是倒霉的一天，网上一群人不知所云。最后还是逛国外网站才解决问题。真是有事没事别用国内的搜索引擎——你永远找不到自己想要的答案，我都不想吐槽了。</p><p>VS code 的设置真的反人类——至少反我。我都不知道哪跟哪，最后直接放弃了VS Code. 我还留着 VS Code 仅仅是因为它的智能提示。不过我已经不玩 C/C++了，看来没必要留着这个东西。相比之下，我更愿意 VS Code 使用像 SublimeText 那样的 JSON 配置格式——虽然我知道它也有，只是它的 JSON格式让我感觉在写 C# ，真的不舒服。鬼知道，别人用都没问题就我有问题？</p><p>目前对我来说还有疑惑的是 Server版不能安装包，只能使用控制台安装。我不是很了解，因为之前没有用过RStudio. RStudio Server 的 Python智能提示比较慢，可能和服务器有关吧，需要再鼓捣鼓捣。除此之外应该没啥大问题了。不清楚这个服务器顶不顶得住大规模运算——虽然未必有。我也听过Jupter NoteBook 可惜自己玩不会。</p><p>内存不够用着实让我眼前一黑。当时正编译，远程控制台直接卡崩，其他控制台瞬间动不了。我以为是自动挂起，结果怎么都连不上服务器，赶忙上阿里云控制台，发现有一个严重警告，没看懂。当时以为是安装问题，登陆服务器再试安装Seurat两遍都是强行断连接。最后瞟了一眼才发现是内存不足被系统强行杀掉。一直以为内存不是大事的我才意识到，我的服务器只有2G 内存。当初学的 <code>dd</code> 那点知识终于用上了，看来 swap分区还是有必要的，特别是老旧、内存不大的机子。</p><p>安装 Seurat 的一些经历也奇怪。之前有一阵子安装 miniconda3 ，配置Seurat 的时候一直安装不了 Stringi包，差点没怀疑人生——因为之前安装都没问题。结果第二天又可以安装了。我就不信这个邪，当晚再试——果然又安装不了。最后估摸着发现，晚上安装不了，白天可以？有点意思，可能这个包昼出夜伏。开个玩笑，可能那时候服务器顶不住太多的请求，又或者DNS 污染，反正就这么奇葩。</p><h1 id="相关网址">相关网址</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span>https://docs.conda.io/en/latest/miniconda.html<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>https://www.rstudio.com/products/rstudio/download-server/<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3"class="footnote-text"><span>https://scanpy.readthedocs.io/en/stable/installation.html<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4"class="footnote-text"><span>https://satijalab.org/seurat/<a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RStudio</tag>
      
      <tag>Miniconda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何使用Markdown写论文</title>
    <link href="/2022/03/15/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Markdown%E5%86%99%E8%AE%BA%E6%96%87/"/>
    <url>/2022/03/15/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Markdown%E5%86%99%E8%AE%BA%E6%96%87/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">1. 前言</h1><p>Markdown 作为新兴的写作工具越来越受人的青睐，用 Markdown写成的纯文本文件可以快速移植，省去再排版的烦恼。既然如此，能否使用Markdown 进行论文写作呢？答案是肯定的。Markdown 可以直接使用 <spanclass="math inline">\(L^AT_EX\)</span> 的数学公式排版，同时还可以搭配Mermaid 进行画图。使用 Markdown 写完自己的文章之后，可以通过 Pandoc进行格式转换，轻松导出成各种格式。Markdown 还可以配合 R语言进行专业绘图和排版。</p><p>本次我们将借助 Zettlr 编辑器完成论文的基本排版和写作。如果你会 <spanclass="math inline">\(L^AT_EX\)</span> 的话请往他处。</p><h1 id="工具准备">2. 工具准备</h1><p>要准备的工具主要有以下几种：</p><ol type="1"><li>Zettlr Markdown编辑器<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="https://www.zettlr.com/">[1]</span></a></sup>。</li><li>pandoc-crossref交叉引用软件<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://github.com/lierdakil/pandoc-crossref/release/">[2]</span></a></sup>。</li><li>Zotero文献管理工具<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="https://www.zotero.org/">[3]</span></a></sup>。</li></ol><p>下面我们会逐一介绍这些工具的使用。</p><p>2.1. Zettlr Markdown 编辑器</p><p>Zettlr 是一款专门面向写作者和研究者的 Markdown 编辑器，由德国学者Hendrik Erz创建。理由很简单：他对现在的文字处理软件感到不满，他想要一个可以让他“专注于写作和阅读”的编辑器。秉承着自己动手丰衣足食的理念，这位大佬开始了自己的编程之路，于是Zettlr 这个“二十一世纪的 Markdown编辑器”诞生了。由于是为了学者和写作者而作，Zettlr自带各种强大的属性。这里就不探讨它的强大功能了，有需求请去官网<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="https://www.zettlr.com/">[1]</span></a></sup>。</p><p>现在的 Markdown 编辑器数不胜数，为什么要选择 Zettlr？其实理由很简单：它支持文献引用。写论文的时候，我们需要对一些参考文献进行引用。大多数时候靠Word 可以快速使用各类文献管理器的引用插件，然而我更偏向WPS。去年把自己的文献管理器从 NoteExpress 迁到 Zotero，谁知道 Zotero没有 WPS 的插件。看了看相关开发者的反馈，据说他们找金山公司，希望开发WPS 的 Zotero 插件，结果被告知 WPS 的<ruby>应用程序开发接口<rt>Application Programming Interface</rt></ruby>(API ) 和 Office 的是一样的。也就是说，金山公司认为如果 Zotero的插件可以在 Office 中使用，自然也可以在 WPS中使用。可惜事实并非如此。前一阵我发现国外的大佬们在探讨这件事的时候说，原来WPS有开发者文档，可只有中文没有英文，他们看不懂。太可惜了，我看得懂。</p><p>那一阵子还在使用 Windows，写论文还可以用 WPS 配合NoteExpress。现在使用了 Linux 系统，只能硬着头皮使用 Markdown。</p><p>说了那么多废话，其实就是想说，接下来论文就在 Zettlr编辑器上完成了。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203132034512.png"alt="Zettlr 官网" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203132036443.png"alt="Zettlr 编辑器界面" /></p><p>Zettlr 是 <ruby>WYSIWYM<rt>What You See Is What YouMean</rt></ruby>(所见即所想) 的 Markdown 即时渲染编辑器，有别于 OfficeWord 和 WPS Word 的 <ruby>WYSIWYG<rt>What You See Is What YouGet</rt></ruby>(所见即所得)。唯一的不同是，它保留了 Markdown的原始格式。</p><p>2.2. YAML Front-matter</p><p>我们可以看到 Zettlr 文档的头部有一部分由三条横杠分隔，它叫做<ruby>YAML<rt>Yet Another MarkupLanguage</rt></ruby>Front-matter，中文名不知道，暂且叫做“标头”。这一部分使用的是YAML语法，可以配置文档信息。这一部分可以在官网教程查看。简单说一些配置：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">标题</span><br><span class="hljs-attr">author:</span> <br><span class="hljs-bullet">-</span> <span class="hljs-string">作者1</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">作者2</span><br><span class="hljs-attr">keywords:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">关键字2</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">关键字2</span><br><span class="hljs-attr">abstract:</span> <span class="hljs-string">|</span><br><span class="hljs-string">这里写摘要</span><br><span class="hljs-meta">---</span><br></code></pre></div></td></tr></table></figure><p>注意，YAML语法的特点是，冒号之后的文字与冒号有一个空格，还有缩进：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># 正确操作</span><br><span class="hljs-attr">key:</span> <span class="hljs-string">value</span><br><span class="hljs-attr">keys:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">value1</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">value2</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">value3</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">value4</span><br><br><span class="hljs-comment"># 错误示范</span><br><span class="hljs-string">key:value</span><br><span class="hljs-attr">keys:</span><br><span class="hljs-string">-value1</span><br><span class="hljs-string">-value2</span><br><span class="hljs-string">-value3</span><br>  <span class="hljs-string">-value4</span><br></code></pre></div></td></tr></table></figure><p>后面与 YAML有关的操作，如果你发现自己的配置不起作用，请检查是不是少了一个空格，或者缩进不对。</p><p>2.3. 引用文献</p><p>要引用文献，我们需要打开 Zotero 文献管理器，选择 Better CSL JSON 或者Better BibTex 格式导出文献库：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203132055432.png"alt="导出文献库" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203132056233.png"alt="选择 CSL JSON 或者 BibTex 格式" /></p><p>记住勾选 Keep Updated 保持更新，保存到你喜欢的文件夹。</p><p>回到 Zettlr，选择文件---&gt;<ruby>首选项(偏好)<rt>Preferences</rt></ruby>，或者直接快捷键<kbd>CTRL</kbd>+<kbd>,</kbd> 打开首选项，选择<ruby>引用<rt>Citation</rt></ruby> 模块，在 <ruby>引用库<rt>CitationDatabase</rt></ruby>下选择你刚刚导出的库，下一行填写你的参考文献格式的路径。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203132101687.png"alt="首选项" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203132102458.png"alt="填写引用文献的路径和类型" /></p><p>参考文献格式是我们论文最后写的文献的格式，国内通常使用 GB2005。可以在 Zotero 中下载，然后在 Zotero 安装路径里边找 Styles文件夹，找到你想使用的 <ruby>引用格式(CSL)<rt>Citation StyleLanguage</rt></ruby> ，复制路径到上面需要填写的地方。Zotero的使用可以参考我之前写的文章。</p><blockquote><p>Zotero 使用的文章</p><p><ahref="https://chunshuyumao.github.io/2022/03/15/Zotero%E6%96%87%E7%8C%AE%E7%AE%A1%E7%90%86%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/">Zotero文献管理插件安装</a></p><p>还有一篇安装的文章，原始 Markdown文件不见了，懒得再写，要看只能去公众号：椿树与猫 查看。</p></blockquote><p>到这里，我们的准备就完成了。Zettlr 中引用文献使用<code>[@CiteKey]</code>，其中 <code>CiteKey</code> 就是我们之前在 Zotero安装的 Better BibTex提供的独一无二的标识，包含引用的文献的一些信息，例如文献标题或者作者、年限什么的。看下面，我只是输入了<code>@</code>它就自动弹出了文献库的文献，这时候你只需要再添加一些信息就可以快速查找自己想引用的文献。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203132110871.png"alt="尝试引用" /></p><p>引用完之后， Zettlr的右边会出现一个引用列表，如果没有，也可以点它出现，就像这样：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203132112145.png"alt="引用列表" /></p><p>如果想要修改自己的引用格式，就更改 CSL-Style 的路径。</p><p>这是最基础的使用，我们可以使用 <kbd>CTRL</kbd>+<kbd>E</kbd>导出试试(也可以在 <ruby>文件<rt>File</rt></ruby> 中选择导出)：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203132114242.png"alt="导出" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203132117406.png"alt="导出" /></p><p>导出之后，它自己给我们标号和更改参考文献格式。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203132119048.png"alt="PDF 格式" /></p><p>2.4. 修改 Word 模板</p><p>有些时候，我们需要各种 Word 格式，可以通过修改Pandoc<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="https://pandoc.org/">[4]</span></a></sup> 默认模板完成。首先你的电脑要安装 Pandoc，并配置好环境变量。<kbd>Windows</kbd>+<kbd>R</kbd>输入 CMD ( 不可使用Powershell ) 或者在 Linux 打开终端，输入一下代码</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">pandoc --print-default-data-file=reference.docx &gt; ref.docx<br></code></pre></div></td></tr></table></figure><blockquote><p>Zettlr 内置 Pandoc，但是我们要定义自己的 Word 模板需要下载Pandoc。如果不想安装，可以从 Zettlr 安装目录找找有没有 Pandoc可执行文件。我不知道 Windows系统可不可以找到，无论如何，还是建议直接直接安装 Pandoc——大不了用完再卸载。</p></blockquote><p>正常情况下，你所在的目录会出现一个 ref.docx 的文件，那就是你的 Word模板文件。使用 WPS 或者 Office Word打开，然后修改格式，不是在正文修改，而是类似下面这个模板修改</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203132129394.png"alt="修改格式" /></p><p>修改的具体格式得看你自己了，因为没有万能的论文格式。</p><p>一般而言，三线图是不可以直接修改的：如果真的使用 Markdown写论文，导出成 Word 格式之后还需要手动修改三线图。</p><p>修改完之后，打开 Zettlr 的<ruby>资源管理器<rt>AssetsManager</rt></ruby>，选择<ruby>导出<rt>Export</rt></ruby>中的 Word设置，在末尾添加</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">reference-doc:</span> <span class="hljs-string">/home/chunshuyumao/Zotero/forzettlr/ref.docx</span><br></code></pre></div></td></tr></table></figure><p><code>reference-doc</code>后添加的是你的 ref.docx所在路径，上面写的是我的路径，别抄。</p><p>默认情况下导出的参考文献的标题是英文Reference。如果你想改成中文“参考文献”，可以在标头或者 Word导出设置中添加：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">reference-section-title:</span> <span class="hljs-string">&quot;参考文献&quot;</span><br></code></pre></div></td></tr></table></figure><p>导出设置中的 <code>shift-heading-level-by</code>需要注意一下：它的意思是修改标头的等级。一般来说，一个<code>#</code>表示一级标题，两个表示二级标题。如果你想让一个<code>#</code> 表示三级标题，那就改成<code>shift-heading-level-by: -3</code>；如果想让 <code>#</code>表示一级标题，那就改成<code>shift-heading-level-by: 3</code>。大家可能会奇怪：为什么会有这种神奇的语法？我想用一级标题就用一级标题，想用二级就用二级，为什么还搞得这么花里胡哨？其实不然，我们写Word的时候，通常是从一级标题开始，但是在网页上，一级标题太大了，网页上的最高一级的标题实际上是Word 上的三级标题。所以在写的时候，我们可以使用三级标题，导出为 Word的时候直接修改<ruby>偏移量<rt>shift-heading-level-by</rt></ruby>就免去了大量修改的麻烦。</p><p>2.5. 交叉引用</p><p>我相信，本科生基本没有考虑过什么是交叉引用。很简单，即使是经常写论文的我们专业也很少会碰见大量的图片修改，或者论文存在大量图片。大多数情况下，我们写论文都是手动写索引，例如"图1""图2""图3""表1""表2""表3"。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203160936531.png"alt="手动写图片索引" /></p><p>然而这种手动操作，存在一个很大的弊端：我不想手操。</p><p>好的，懒人兴致勃发，接下来就是如何偷懒：让 Markdown自己给我们标号。先看看原始状态：</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Markdown">![<span class="hljs-string">我大南开</span>](<span class="hljs-link">file:///home/chunshuyumao/Pictures/signture.png</span>)<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203160944232.png"alt="效果如下" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203160945421.png"alt="导出为 Word 之后" /></p><p>我们想让它自动标号，需要下载一个交叉引用的插件，叫做 pandoc-crossref<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://github.com/lierdakil/pandoc-crossref/releases/">[5]</span></a></sup>，老规矩——上不去就去<ruby>码云<rt>Gitee</rt></ruby>找镜像。下载之后把它放到一个安全的地方，以免以后被你误删——建议和Pandoc 可执行文件放一起，这样好找。</p><p>在自己的文件标头写</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Markdown">filters:<br><span class="hljs-bullet">-</span> /usr/bin/pandoc-crossref<br></code></pre></div></td></tr></table></figure><p>其中 <code>/usr/bin/pandoc-crossref</code> 是你的 pandoc-crossref路径 。</p><blockquote><p>注意：Windows 系统使用的分隔符是  ，我现在在 Linux 系统，所以使用 /。希望使用时记得区别。</p></blockquote><p>然后在自己的图片以后这样写</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Markdown">![<span class="hljs-string">我大南开</span>](<span class="hljs-link">file:///home/chunshuyumao/Pictures/signture.png</span>)&#123;#fig:id&#125;<br></code></pre></div></td></tr></table></figure><p>其中 <code>id</code> 是一个<strong>没有空格</strong>的标识，我使用<code>this</code> 作为标识：</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Markdown">![<span class="hljs-string">我大南开</span>](<span class="hljs-link">file:///home/chunshuyumao/Pictures/signture.png</span>)&#123;#fig:this&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>注意，`</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
      <tag>Zettlr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zotero文献管理插件安装</title>
    <link href="/2022/03/15/Zotero%E6%96%87%E7%8C%AE%E7%AE%A1%E7%90%86%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    <url>/2022/03/15/Zotero%E6%96%87%E7%8C%AE%E7%AE%A1%E7%90%86%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">1. 前言</h1><p>前面介绍了Zotero<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="https://www.zotero.org/">[1]</span></a></sup> 等文献管理工具的安装和简单使用。今天讲讲 Zotero插件的使用。早前我有说过，Zotero具有丰富的插件支持。由于当时为了介绍其他的两款文献管理工具，避免篇幅过长，所以没有介绍Zotero 的插件。</p><h1 id="安装插件">2. 安装插件</h1><p>在介绍安装插件之前，我们要知道，Zotero插件通常都可以在官网<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.zotero.org/support/plugins/">[2]</span></a></sup>找到。好的我们继续。</p><p>首先看没有安装任何插件的 Zotero 中文界面:</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152053611.png"alt="原始中文界面" /></p><p>推荐安装浏览器插件 Zotero Connector :</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152055785.png"alt="安装 Connector 插件" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152056245.png"alt="浏览器中的 Connector" /></p><p>我使用火狐浏览器，所以插件推荐的是火狐。安装 Connector插件为的是后面更好地下载论文。安装好之后，你的浏览器右上角应该出现这个标志。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152104923.png"alt="Connector" /></p><p>现在打开任何一个可以查论文的东西——实际上，Zotero不仅仅可以管理论文，还包括所有浏览器能嗅探的东西，例如网页——这里随便查找文献。右上角的图标变成了学者的帽子，点击之后会自动抓取。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152107569.png"alt="自动识别论文" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152109547.png"alt="自动抓取" /></p><p>为了后面的示范。我还抓取了几篇论文。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152111974.png"alt="抓取的论文" /></p><p>Zotero 抓到是抓到了，但是 PDF文件似乎没有进行重命名。我们希望它可以对我们的论文 PDF进行重命名。这里我们需要下载一个插件，叫做Zotfile<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="http://zotfile.com/">[3]</span></a></sup>。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152114431.png"alt="Zotfile 官网网址" /></p><p>下载完之后，打开 Zotero 的 <code>工具--&gt;插件</code>，选择<code>Install Add-on From File</code>，然后进行安装，每次安装之后都需要重启。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152116952.png"alt="选择 install from file" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152117551.png"alt="安装" /></p><p>重新打开之后，选择要修改的文件，<code>右键--&gt;根据父级元素重命名</code>。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152120959.png"alt="重命名" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203160747860.png"alt="重命名" /></p><p>修改完之后，我们看到，标签里的作者名字是分开的，我们不希望姓名分开，所以安装下一个插件：<ruby>茉莉花<rt>Jasminum</rt></ruby><sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://github.com/l0o0/jasminum/releases">[4]</span></a></sup>。这款插件不在官网，却不可或缺。到 GitHub 下载<code>xpi</code> 文件。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152128362.png"alt="下载 xpi 文件" /></p><p>下载之后安装重启。右键小工具，可以修改。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152129563.png"alt="右键小工具" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152130199.png"alt="名字已经正常了" /></p><p>还可以在 <code>首选项</code> 中修改配置</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152132410.png"alt="茉莉花配置" /></p><p>最后下载 BetterBibTex<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://retorque.re/zotero-better-bibtex/">[5]</span></a></sup>。如其名，这个和 <spanclass="math inline">\(L^AT_ET\)</span>有关。不过不用担心，先安装再说。重启配置，选择<code>BBT default citekey format</code>，允许拖拽引用，最后一直<code>next</code> 就行了。安装完之后，就会看到<code>CiteKey</code>，这是你引用的时候查找的关键字。当然也可以更改。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152134383.png"alt="Better BibTex" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152144263.png"alt="重启配置，选择 BBT default citekey" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152145391.png"alt="允许拖拽引用" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152234217.png"alt="安装完成" /></p><p>到 <code>首选项</code> 中选择 <code>重命名链接的文件</code>。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152148519.png"alt="配置" /></p><p>到这里，我们的插件基本安装完了，如果你还有什么想要安装的，可以到官网查找插件或者GitHub 上面查找。</p><p>对我而言，Zotero 还可以用来做文献阅读笔记，所以习惯性添加MarkdownHere<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://github.com/adam-p/markdown-here">[6]</span></a></sup> 插件。如果上不去，可以用Gitee<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://gitee.com/mirrors/markdown-here">[7]</span></a></sup>。同理，上面的插件如果上不了 GitHub ，可以搜索<code>插件名 Gitee</code>，一般都有镜像。进入下载的文件夹或者解压的文件夹中的src ，压缩<code>common</code>、<code>firefox</code>、<code>chrome.manifestr</code>、<code>install.rdf</code>到随便一个文件夹，建议仍然使用<code>MarkdownHere</code>，修改后缀为<code>xpi</code>，然后进行安装。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152221183.png"alt="压缩" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152223699.png"alt="MarkdownHere 插件" /></p><p>安装完之后可以使用 Markdown 做笔记，做完笔记之后全选使用<kbd>CTRL</kbd>+<kbd>ALT</kbd>+<kbd>M</kbd>进行格式转化。选择一篇论文，单击下边的笔记( Notes ) --&gt; 添加 ( add )，做笔记。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152232204.png"alt="全选原始格式" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152232962.png"alt="MarkdownHere渲染的格式" /></p><p>哈哈，果然简单是吧？其实蛮喜欢 Markdown Here的，我的邮箱客户端就安装了它。</p><p>如果想更改你的导出格式，可以到<code>首选项---&gt;引用---&gt;更多样式</code>查找你的参考文献格式。默认国内使用 GB2005 。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152241815.png"alt="添加格式" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152242873.png"alt="国标" /></p><p>Zotero 的引用格式会安装到自己目录的 <code>Styles</code>文件夹，所以别忘了你的 Zotero 安装到哪里——后面我们会用到。</p><h1 id="后语">3. 后语</h1><p>Zotero对与一个经常看文献的人来说确实是一个好东西。我现在还是要感慨，为什么 WPS没有相应的 Zotero 插件？这是逼我使用 Markdown写论文呀——所以下一篇就打算写写如何用 Markdown 写论文。</p><h1 id="相关网址">相关网址</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>https://www.zotero.org/<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>https://www.zotero.org/support/plugins/<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>http://zotfile.com/<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4"class="footnote-text"><span>https://github.com/l0o0/jasminum/releases<a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:5"class="footnote-text"><span>https://retorque.re/zotero-better-bibtex/<a href="#fnref:5" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:6"class="footnote-text"><span>https://github.com/adam-p/markdown-here<a href="#fnref:6" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:7"class="footnote-text"><span>https://gitee.com/mirrors/markdown-here<a href="#fnref:7" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zotero</tag>
      
      <tag>文献管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FTP服务进阶</title>
    <link href="/2022/03/12/FTP%E6%9C%8D%E5%8A%A1%E8%BF%9B%E9%98%B6/"/>
    <url>/2022/03/12/FTP%E6%9C%8D%E5%8A%A1%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">1. 前言</h1><p>上次搭建的 FTP服务满足基本的要求，但是还有一些情况我们没有考虑。这次主要针对两种情况进行优化：</p><ol type="1"><li><ruby>被动模式<rt>passive mode</rt></ruby>(PASV)。</li><li><ruby>虚拟用户<rt>virtual users</rt></ruby>。</li></ol><h1 id="被动模式">2. 被动模式</h1><p>2.1. FTP 服务的两种模式</p><p>FTP服务端和客户端的通信有两种模式，一个是<ruby>主动<rt>PORT</rt></ruby>模式，另一种是<ruby>被动<rt>PASV</rt></ruby>模式。两种模式的主要区别是相对于服务端而言。</p><ol type="1"><li>主动模式。客户端通过随机端口 X 连接到服务器 21端口，告诉服务器：用你的 20 端口连接我的 Y 端口。随后 Y 端口和 20端口进行数据传输。</li><li>被动模式。客户端通过随机端口 X 连接到服务器 21端口，服务器告诉客户端：连接到我的 Z端口。随后客户端通过自己的另一个随机端口 W 连接到服务器的 Z 端口。</li></ol><p>这样看来，被动模式似乎更麻烦，实际确实如此，但这种麻烦是有原因的。大多数人的电脑使用的是Windows 系统，Windows系统的防火墙一般默认开启。防火墙通常会阻止各种端口的接入。主动模式下，服务器用20 端口连接客户端的 Y 端口，如果防火墙开启，就会阻止 20 端口和 Y端口连接。下面演示一下：</p><p>首先关闭我的防火墙，也就是没有防火墙干扰的情况下的连接。下面查看防火墙状态之后发现是<ruby>未激活的<rt>inactive</rt></ruby>。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203121023625.png"alt="没有防火墙" /></p><p>没有防火墙的时候，可以正常使用 ls 命令列出登陆目录下的文件。</p><p>接下来打开防火墙再次进行连接：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203121026609.png"alt="激活防火墙之后连接" /></p><p>这次防火墙处于激活状态，我们可以正常登陆 FTP服务端，但是无法发送指令。因为登陆使用的随机端口 X可以被服务器接收，服务器收到连接 Y 端口的指令并用 20 端口连接到客户端的Y端口的时候被防火墙挡住了。客户端再次发送指令，服务器的所有反馈都没有办法进入客户端。这样，服务器和客户端也就无所谓连接。</p><p>想要继续连接有两个办法：</p><ol type="1"><li>关闭防火墙。</li><li>服务端开启<ruby>被动<rt>PASV</rt></ruby>模式。</li></ol><p>方法一简单粗暴，但是有些人不希望自己的防火墙关闭，为了一劳永逸只能选择开启被动模式。</p><p>服务端开启被动模式。我们查看防火墙一直开着，登陆 FTP使用主动模式的指令还是失败，使用<code>passive</code>进入被动模式，然后输入指令，发现可以正常操作。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203121038954.png"alt="开启被动模式" /></p><p>这样，被动模式就成功在客户端存在防火墙的情况下仍然可以和服务端连接。</p><blockquote><p>默认情况下防火墙只会阻止某些端口的进入，客户端端口可以正常向外访问，所以被动模式的服务器给了客户端一个端口，让客户端去连接服务器，主动模式下则是服务器连接客户端。因此，主动和被动是相对服务器而言的：主动模式下服务器连接，被动模式下客户端连接。</p></blockquote><p>2.2. 开启被动模式</p><p>连接服务器，使用你喜欢的编辑器打开 vsFTPd 配置文件</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo vim /etc/vsftpd/vsftpd.conf<br></code></pre></div></td></tr></table></figure><p>直接转到最后一行，添加以下配置</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">pasv_enable=YES<br>pasv_addr_resolve=YES<br>pasv_address=101.200.84.36<br>pasv_min_port=41001<br>pasv_max_port=42010<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203121049175.png"alt="修改配置文件" /></p><p>解释一下，<code>pasv_enable</code>配置<ruby>被动模式<rt>passive</rt></ruby>（PASV）是否开启。默认情况下被动模式是开启的，但是不起作用。</p><p><code>pasv_addr_resolve</code>配置的是域名解析。虽然不一定用到，但是还是写下吧。</p><p><code>pasv_address</code> 配置返回的 IP 。如果你的 vsFTPd服务器是安装在局域网，例如自己家庭使用、虚拟机练习，那这个 IP就填你的局域网 IP；如果 vsFTPd 部署在自己服务器，那就使用服务器公网 IP。</p><blockquote><p>公网 IP 是你购买服务器后，云服务商手机告诉你的公网IP。如果忘了，可以到服务商提供的控制台查看。</p><p>局域网 IP 简单，就是你使用 <code>ip addr</code> 或者<code>ifconfig</code>看到的 IP 。</p></blockquote><p>如果不填写 <code>pasv_address</code>而且你的服务器是云服务器，即使你的被动模式开启了，其他人也连接不上，会出现这样的提示：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203121100091.png"alt="取消公网 IP" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203121059035.png"alt="没有配置公网 IP" /></p><p>因为被动模式开启但没有配置公网 IP，服务器就使用局域网 IP作为被动模式的 IP，例如我服务器的局域网 IP<code>172.27.163.6</code>。因此使用云服务器一定要改<code>pasv_address</code>。</p><p><code>pasv_min_port</code> 和 <code>pasv_max_port</code>是服务器开放的端口范围，什么意思？就是服务器可能也要开防火墙——总不能让它冒险吧——因此保留这些端口不挡住，可以给客户端在被动模式时连接。范围可大可小——但是注意，由于一个端口一般只能连接一台客户端，如果FTP服务器使用人数比较多可以把端口范围放大，否则可以调小。建议使用高端口，但是也不要超过五位数。</p><p>设置完成之后保存退出，重启 vsFTPd 服务</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo systemctl restart vsftpd<br></code></pre></div></td></tr></table></figure><p>到这里，被动模式已经开启。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203121111379.png"alt="再次测试" /></p><p>一般来说，被动模式和主动模式可以同时开启：以备不时之需。</p><p>Windows 的 FTP客户端一般都会选择被动模式登陆，如果服务端没有开启被动模式，客户端就无法获取服务端的文件。这种时候可以查看客户端的设置，通常可以选择连接模式。如果是Linux，一般都是手动操作。保不准自己进入了被动模式，那怎么退出？大多数的FTP 客户端会提供一些指令，可以使用 <code>help</code> 或者 <code>?</code>进行查询：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203121115309.png"alt="FTP 客户端命令" /></p><p>这么来说，我的客户端退出被动模式就很简单了:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">passive off<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203121117065.png"alt="退出被动模式" /></p><h1 id="虚拟用户">3. 虚拟用户</h1><p>刚搭建的 FTP 服务器开启了匿名模式，即可以使用 ftp作为用户名无密码登陆；还允许本地用户登陆，即允许服务器上的用户登陆。这样有一定风险的：本地用户拥有的权限，登陆后仍然拥有。比如我进行登陆，可以直接看到整个服务器的目录结构：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203121123862.png"alt="服务器目录结构" /></p><p>这就产生了权限漏洞。如果我们即想要分享，又不希望别人对自己的文件进行不必要的干扰，最好的办法就是创建虚拟用户，然后进行权限限制。</p><p>3.1. 添加服务器用户</p><p>首先我们需要在服务器创建一个映射虚拟用户的不可登陆的用户帐号：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo useradd vuser -d /var/ftp -s /sbin/nologin<br></code></pre></div></td></tr></table></figure><p>解释一下，<code>-d</code>是指定虚拟用户的家目录，我们之前已经创建过这个目录作为匿名用户的家目录，现在我们不打算使用匿名帐户，直接把家目录划给虚拟用户。</p><p>虚拟用户只是一个系统权限映射的用户，没有必要让它登陆服务器，所以设置使用<code>-s</code> 指定它不可登陆。</p><blockquote><p><code>-s</code> 一般是创建用户时指定使用的 <code>shell</code>，Linux中通过把 <code>shell</code> 指定到 <code>nologin</code> 实现禁止登陆</p></blockquote><p>创建之后可以使用</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">cat /etc/passwd | grep vuser<br></code></pre></div></td></tr></table></figure><p>查看用户信息</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203121143056.png"alt="查看虚拟用户信息" /></p><p>3.2. 添加虚拟用户</p><p>进入 <code>/etc/vsftpd</code> 添加一个文件，我这里是<code>vuser.cfg</code>，在里边填入虚拟用户的信息。注意，单行是用户名，双行是用户密码：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203121148543.png"alt="添加虚拟用户" /></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">lileilei<br>20220202<br>hanmeimei<br>20220303<br></code></pre></div></td></tr></table></figure><p>保存退出。</p><p><code>cfg</code>文件不能被 vsFTPd 读取，需要转化格式，变成可读的<code>db</code> 格式：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo db_load -T -t hash -f /etc/vsftpd/vuser.cfg /etc/vsftpd/vuser.db<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203121153783.png"alt="转化为 db 格式" /></p><p>把 <code>db</code> 改为只有 root 用户可以读写</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo chmod 600 vuser.db<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203121253782.png"alt="修改权限" /></p><p>让 vsFTPd 读取自己配置的<code>db</code>，需要配置<ruby>可插入认证模块<rt>PluggableAuthentication Modules</rt></ruby>（PAM）文件。</p><p>创建 PAM 文件：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo vim /etc/pam.d/vsftpd.vuser<br></code></pre></div></td></tr></table></figure><p>输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">auth sufficient /lib64/security/pam_userdb.so db=/etc/vsftpd/vuser<br>account sufficient /lib64/security/pam_userdb.so db=/etc/vsftpd/vuser<br></code></pre></div></td></tr></table></figure><p><code>db</code> 之后的配置文件是我们上面写的 vuser.db 文件。</p><p>3.3. 修改 vsFTPd 配置文件</p><p>进入 <code>/etc/vsftpd</code> 目录，如果没有 <code>vuserconfig</code>目录，则创建一个新的目录。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">cd /etc/vsftpd/<br>sudo mkdir vuserconfig<br></code></pre></div></td></tr></table></figure><p>然后进入 vuserconfig目录，目录里边是我们的虚拟用户的权限文件。想要限制谁的权限，就在这个目录创建同名的文件。我配置一个用户的权限：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo vim lileilei<br></code></pre></div></td></tr></table></figure><p>配置权限</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">local_root=/var/ftp<br>write_enable=YES<br>anon_umask=022<br>anon_world_readable_only=NO<br>anon_upload_enable=YES<br>anon_mkdir_write_enable=YES<br>anon_other_write_enable=YES<br>download_enable=YES<br></code></pre></div></td></tr></table></figure><p>修改 /etc/vsftpd/vsftpd.conf 文件：注释掉pam_service_name=vsftpd，这是默认的用户配置文件，我们添加了虚拟用户，所以改成我们自己的vsftpd.vuser，这里的 guest_username=vuser 的 vuser 与我们在服务器建立的vuser 用户名字一样。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">guest_enable=YES<br>guest_username=vuser<br>user_config_dir=/etc/vsftpd/vuserconfig<br>allow_writeable_chroot=YES<br>pam_service_name=vsftpd.vuser<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203121327337.png"alt="修改 vsFTPd 配置文件" /></p><p>最后重启 vsFTPd 服务</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo systemctl restart vsftpd<br></code></pre></div></td></tr></table></figure><p>客户端尝试本地用户登陆，发现失败了；使用虚拟用户 lileilei登陆成功。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203121332066.png"alt="尝试本地用户登陆" /></p><p>虚拟用户，创建完毕！如果要继续添加新用户，可以往 vuser.cfg添加，然后生成 <code>db</code> 文件就可以了。</p><h1 id="后语">4. 后语</h1><p>上面就是我们 FTP 的进阶配置。可以看到，虽然 FTP显得很古老，但是仍然具有很强大的功能。通过一些配置可以实现虚拟用户登陆、配置登陆用户的权限等等，所以FTP 仍然可以在现在这个互联网时代保持其优异的分享功能。</p><p>实际上，如果是在家庭中，我们可以自己搭建一个局域网内的 FTP服务器，让自己的家庭成员可以分享自己的文件，这比使用公有云更安全，对隐私的保护更出色。</p><p>FTP 可探索的配置还是很多的，所以好好探索吧！</p>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Manjaro 双系统引导修复</title>
    <link href="/2022/03/05/manjaro%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC%E4%BF%AE%E5%A4%8D/"/>
    <url>/2022/03/05/manjaro%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC%E4%BF%AE%E5%A4%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>人在江湖飘，哪有不挨刀。我装双系统之前，电脑只安装了 Manjaro，后来以防万一装了 windows 。因为引导 Windows11 一直失败，所以我先安装了Windows10 。后来把所有的问题都搞定之后，我就给我的 Windows10 升级。升到Windows11 本来是好事，结果启动 Manjaro 的时候，直接进入了 grub rescue模式。</p><p>在此之前，我完全不相信双系统会出现这种问题。毕竟我给我的硬盘分好了区，两个系统井水不犯河水。当时觉得别人出现问题是因为他们没有正确处理这些问题。当我的linux 系统的 grub 被 Windows 弄坏的时候，我知道我也中招了。</p><p>这种问题按理来说不是难事，可是当我跑到网上去查的时候，发现能查出来的都是不知所云的。果然百度不能信。求天求地不如求己，因此又有了这篇引导修复的文章。</p><hr /><h1 id="引导修复">引导修复</h1><p>我的 Manjaro 系统出现故障的时候，只要一选择 Manjaro 启动就会跑到 grubrescue界面，所以如果你可以进入正常的引导界面，只是启动后黑屏的话，多半是驱动问题，这篇文章自然就不用看了。</p><p>引导修复有两种办法：</p><ol type="1"><li>Live CD修复</li><li>手动修复</li></ol><p>第一种方法对于 Windows 玩机大家来说很简单了，就是各类的 PE机做的事。不过我还是说说。</p><h2 id="live-cd修复">Live CD修复</h2><p>这种方式要求你有一个 Manjaro启动盘或者和你系统一样的启动盘。为什么使用 Manjaro Live CD ？因为Manjaro 本身支持 LiveCD 。启动盘不难制作，按我之前说，直接用 Ventoy<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="https://ventoy.net/">[1]</span></a></sup>制作即可。</p><p>启动电脑进入 BIOS 或者 UEFI 界面，选择U盘启动，就像安装 Manjaro一样直到进入图形界面。</p><p>进入图形界面之后，打开控制台，输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo fdisk -l<br></code></pre></div></td></tr></table></figure><p>查看你的硬盘分区，通常你是可以知道自己的硬盘分区的。例如分区如下，我的Manjaro 安装在 Windows 之后，所以倒数一二块分区应该就是我的 Manjaro 的EFI 和 根(root) 分区:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">Disk /dev/nvme0n1: 476.94 GiB, 512110190592 bytes, 1000215216 sectors<br>Disk model: INTEL SSDPEKNW512G8                     <br>Units: sectors of 1 * 512 = 512 bytes<br>Sector size (logical/physical): 512 bytes / 512 bytes<br>I/O size (minimum/optimal): 512 bytes / 512 bytes<br>Disklabel type: gpt<br>Disk identifier: 2CBB82D2-DA15-824E-A9B0-AF96C6143278<br><br>Device             Start        End   Sectors   Size Type<br>/dev/nvme0n1p1      2048     616447    614400   300M EFI System<br>/dev/nvme0n1p2    616448     649215     32768    16M Microsoft reserved<br>/dev/nvme0n1p3    649216  159879167 159229952  75.9G Microsoft basic data<br>/dev/nvme0n1p4 159879168  161349631   1470464   718M Windows recovery environmen<br>/dev/nvme0n1p5 161351680  161966079    614400   300M EFI System<br>/dev/nvme0n1p6 161966080 1000215182 838249103 399.7G Linux filesystem<br></code></pre></div></td></tr></table></figure><p>接下来是挂载我的 Manjaro 两个分区，同时转换到挂载的目录：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo mount /dev/nvme0n1p6 /mnt<br>sudo mount /dev/nvme0n1p5 /mnt/boot/efi<br>manjaro-chroot /mnt<br></code></pre></div></td></tr></table></figure><p>转换之后，命令提示符应该从原本的 Manjaro格式变成其他格式，我的变成了这样</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sh-5.1#<br></code></pre></div></td></tr></table></figure><p>这时候，我们需要更新我们的 grub ，然后再次安装它：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">update-grub<br>grub-install /dev/nvme0n1p5<br></code></pre></div></td></tr></table></figure><p>当然，你要是不放心，还可以再次生成 grub ：</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">grub-mkconfig -o <span class="hljs-regexp">/boot/g</span>rub/grub.cfg<br></code></pre></div></td></tr></table></figure><p>然后退出，卸载，然后重启</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">exit<br>sudo umount -R /mnt<br>reboot<br></code></pre></div></td></tr></table></figure><p>正常情况下，你的系统应该可以启动了。</p><h2 id="手动修复">手动修复</h2><p>这种情况是你手中没有 Live CD ，或者没有合适的 Live CD。这种就很难受了。</p><p>首先你会看到这个提示</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">eorror: unkown filesystem<br>Entering rescue mode...<br>grub rescue &gt; <br></code></pre></div></td></tr></table></figure><p>如果没有这个提示，很好，你的问题我不能解决，你可以另往它处了。</p><p>第一步，我们先看一下自己的 Manjaro系统在哪里，使用<code>ls</code>。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">ls<br></code></pre></div></td></tr></table></figure><p>我的提示如下</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">(hd0) (hd1) (hd1,gpt4) (hd1,gpt3) (hd1,gpt2) (hd1,gpt1) (hd2,gpt6) (hd2,gpt5) (hd2,gpt4) (hd2,gpt3) (hd2,gpt2) (hd2,gpt1) <br></code></pre></div></td></tr></table></figure><p>你的分区可能不会这么多，所以不用担心。</p><p>接下来就是烦人的操作了，使用<code>ls</code>一个个查看这些分区，例如</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">ls (hd0)/<br>ls (hd1,gpt4)/<br>...<br></code></pre></div></td></tr></table></figure><p>注意，hd1和gpt4之间除了逗号，什么也没有，括号之后还需要加上<code>/</code>，除此之外不要添加别的东西。</p><p>一个一个地试，你可以会得到这类消息</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">error: unkown filesystem<br></code></pre></div></td></tr></table></figure><p>恭喜你，你成功排除了一个选项，请继续排除。</p><p>等到你找到类似下面这个</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">ls (hd2,gpt6)<br>./ ../ lost+found/ boot/ dev/ home/ opt/ proc/ run/ sys/<br></code></pre></div></td></tr></table></figure><p>的提示的时候，这说明你找对了，只要看到<code>boot/</code>就说明已经正确了。记住你的卷标，我的是<code>(hd2,gpt6)</code></p><p>接下來输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">set root=(hd2,gpt6)<br>set prefix=(hd2,gpt6)/boot/grub<br>insmod normal<br>normal<br></code></pre></div></td></tr></table></figure><p>至此，你的引导系统算是正确了。它会自己重启。</p><p>不急，等你进入系统之后打开控制台(终端),输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">fdisk -l<br></code></pre></div></td></tr></table></figure><p>查找你的 Manjaro 的 EFI在哪里，我的是<code>/dev/nvme0n1p5</code>，我知道，上面我就试过了。然后输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo update-grub<br>sudo grub-install /dev/nvme0n1p5<br></code></pre></div></td></tr></table></figure><p>重启一下，你的系统又变好！！</p><hr /><h1 id="后语">后语</h1><p>只要不乱搞，你的系统是不会有问题的。所以当你的系统有问题的时候，别急着责怪电脑，毕竟你比电脑还不负责。</p><hr /><h1 id="相关网址">相关网址</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>https://ventoy.net/<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>引导修复</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Manjaro 安装常用软件</title>
    <link href="/2022/03/05/manjaro%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/"/>
    <url>/2022/03/05/manjaro%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>前面我们已经安装好 Manjaro系统了，现在就是安装一些常用的软件。此外，自己并非工科生，使用的 Windows专有软件不多。</p><hr /><h1 id="配置国内源以及更新系统">配置国内源以及更新系统</h1><p>Manjaro 是国外的系统，服务器往往在国外。想要使用 Manjaro官方软件包需要配置。以前使用 Arch 需要手动配置国内源，然而 Manjaro更加简单：它把世界各地的软件源镜像组合到官方的文件源系统，可以使用简单的工具自动为你筛选速度最快的软件源。</p><p>首先打开你的终端，输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo pacman-mirrors -c China -m rank<br></code></pre></div></td></tr></table></figure><p>其中，<code>sudo</code>允许你行使管理员的命令，<code>pacman-mirrors</code>是选择最快源的命令；<code>-c</code>是指定地区，这是使用中国；<code>-m</code>是方法，我们选择<code>rank</code>，就是把速度最快的挪到前面。它会要求你输入你的密码，注意，输入密码的时候你是看不到反馈的——也就是说，你看不到自己输入的密码，那里黑漆漆的一片。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051124391.png"alt="配置国内源" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051126408.png"alt="配置完成" /></p><p>好的，现在你已经有了对你来说最快的软件源。接下来我们先更新系统：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo pacman -Syyu<br></code></pre></div></td></tr></table></figure><p>当它询问是否安装的时候，我们选择 是 。等它继续更新系统，再次选择 是。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051127397.png"alt="更新系统，选择y" /></p><p>在它安装这个阶段，我先介绍一下我们的指令是什么意思。</p><p>Manjaro 使用的是 pacman 包管理器，记住 pacman 的一些指令即可：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">这是安装一个包</span><br>sudo pacman -S 包名<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这是查询一个包</span><br>pacman -Ss 包名<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这是删除一个包</span><br>sudo pacman -R 包名<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这是删除一个包和它的依赖包</span><br>sudo pacman -Rs 包名<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这是删除系统不使用的、多余的包</span><br>sudo pacman -Rs $(pacman -Qtdq)<br></code></pre></div></td></tr></table></figure><p>如果你还想知道<code>pacman</code>的更过用法，你可以使用：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">man pacman<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者</span><br>pacman --help<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者</span><br>pacman -h<br></code></pre></div></td></tr></table></figure><p>好的，我这边的安装已经完成了。</p><hr /><h1 id="安装软件">安装软件</h1><h2 id="安装官方应用">安装官方应用</h2><h3 id="安装截图软件-flameshot">安装截图软件 Flameshot</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo pacman -S  Flameshot<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051234925.png"alt="Flameshot效果" /></p><p>Flameshot 功能非常强大，可惜我的电脑一直运行不了。</p><p>Flameshot 没有全局快捷键，可以去 设置里设置快捷键。这些教程可以到网上查。</p><h3 id="安装多线程下载器">安装多线程下载器</h3><p>axel 是优秀的多线程下载工具——命令行。如果你习惯使用命令行下载， axel绝不能被错过；如果你不想使用命令行，那就下载 XDM ：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo pacman -S axel<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者</span><br>sudo pacman -S xdm<br></code></pre></div></td></tr></table></figure><p>axel 的使用：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">axel -n 15 address<br></code></pre></div></td></tr></table></figure><p>其中<code>-n</code>后面紧跟的是连接数，理论上连接数越多越好，但是不建议太高。<code>addrss</code>是下载地址。</p><p>XDM 的使用：</p><p>XDM 和 NDM 、 IDM一样，都可以嵌入浏览器，然后自己嗅探下载的东西。</p><h3id="安装邮件客户端雷鸟thunderbird">安装邮件客户端雷鸟(Thunderbird)</h3><p>如果使用邮件客户端，建议使用雷鸟，毕竟它还是很优秀的。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo pacman -S thunderbird<br></code></pre></div></td></tr></table></figure><p>安装完雷鸟之后，还可以在它的插件中安装 Markdown Here 插件，实现Markdown 写邮件。</p><h3 id="安装virtualbox虚拟机">安装virtualBox虚拟机</h3><p>首先查看你的内核版本：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">uname -r<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051257678.png"alt="内核版本" /></p><p>然后选取和自己内核版本一样的虚拟机，我这里的内核是 15，所以选择<code>6</code>。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051258261.png"alt="安装指定版本虚拟机" /></p><h3 id="安装视频播放器vlc">安装视频播放器VLC</h3><p>VLC 就像 Windows 下的 PotPlayer ，所以建议安装。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo pacman -S vlc<br></code></pre></div></td></tr></table></figure><h3 id="安装-markdown-编辑器选择性">安装 Markdown 编辑器(选择性)</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo pacman -S zettlr<br></code></pre></div></td></tr></table></figure><h3 id="安装vim选择性">安装vim(选择性)</h3><p>Linux 下，谁人不知 VIM 编辑器？</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo pacman -S vim<br></code></pre></div></td></tr></table></figure><h3 id="安装中文输入法">安装中文输入法</h3><p>输入以下命令后，直接回车，默认选中所有的输入设置。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo pacman -S fcitx5-im fcitx5-chinese-addons<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051336705.png"alt="安装中文输入法" /></p><p>安装完毕，开始配置中文输入法。输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo vim /etc/environment<br></code></pre></div></td></tr></table></figure><p>回车，按住<kbd>Shift</kbd>+<kbd>g</kbd>跳到文件末尾。按下<kbd>o</kbd>在末尾添加以下配置</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">INPUT_METHOD=&quot;fcitx&quot;<br>GTK_IM_MODULE=&quot;fcitx&quot;<br>QT_IM_MODULE=&quot;fcitx&quot;<br>XMODIFIERS=&quot;@im=fcitx&quot;<br></code></pre></div></td></tr></table></figure><p>然后按<kbd>Esc</kbd>键，输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">:wq<br></code></pre></div></td></tr></table></figure><p>回车，保存退出VIM。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203162212673.png"alt="保存退出VIM" /></p><p>输入<code>reboot</code>重启系统。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051318337.png"alt="重启" /></p><p>重启之后，我们可以看到右上角多出一个输入法配置。点击它进行配置。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051339358.png"alt="输入法" /></p><p>切换中文和英文输入法的快捷键是<kbd>Shift</kbd>或者<kbd>ctrl</kbd>+<kbd>space</kbd>。当然也可以改。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051340640.png"alt="尝试使用中文输入法" /></p><h3 id="安装其他应用">安装其他应用</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Steam</span><br>sudo pacman -S steam<br><span class="hljs-meta prompt_"># </span><span class="language-bash">peek GIF制作</span><br>sudo pacman -S peek<br></code></pre></div></td></tr></table></figure><h2 id="安装aur应用">安装AUR应用</h2><h3 id="安装yay">安装yay</h3><p>yay 是 Manjaro 一个非官方的包管理器，使用方法和 pacman一样，它们的区别是 pacman 是官方的产品。前面提到了， Manjaro拥有强大的社区支持。官方的软件虽然安全，但是毕竟能力有限。社区就发展出一个自己的软件源AUR(Arch User Repository，Arch用户仓库)<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="https://aur.archlinux.org/">[1]</span></a></sup>。 yay 就是从 AUR 安装软件的工具。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo pacman -S yay base-devel<br></code></pre></div></td></tr></table></figure><p>安装完 yay 之后，由于我们下载的软件可能会在 GitGub 上(例如后面的 WPS的配件)，所以配置一下 GitGub 的 DNS ，毕竟国内上网不容易。</p><p>输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo vim /etc/hosts<br></code></pre></div></td></tr></table></figure><p>回车，按住<kbd>Shift</kbd>+<kbd>g</kbd>跳到文件末尾。按下<kbd>o</kbd>在末尾添加以下配置</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">140.82.114.4 github.com<br>199.232.69.194 github.global.ssl.fastly.net<br></code></pre></div></td></tr></table></figure><p>然后按<kbd>Esc</kbd>键，输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">:wq<br></code></pre></div></td></tr></table></figure><p>回车，保存退出VIM。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051354253.png"alt="设置DNS" /></p><h3 id="安装qq">安装QQ</h3><p>QQ 原生的 Linux版太古老，看起来像是上古时期的东西，所以我们安装国产系统 Deepin 基于WINE 的 TIM ，安装的时候可以选择仓库或者直接回车：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">yay -S deepin-wine-qq<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者</span><br>yay -S deepin-wine-tim<br></code></pre></div></td></tr></table></figure><p>遇到对比，可以直接选择不显示( N ):</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051230824.png"alt="选择N" /></p><p>下载完成之后启动并配置：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051240756.png"alt="TIM安装" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051241358.png"alt="TIM登陆" /></p><h3 id="安装微信">安装微信</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">yay -S deepin-wine-wechat<br></code></pre></div></td></tr></table></figure><p>安装微信和 TIM 差不多。由于基于 WINE ，这些应用的体验和在 Windows上没多大区别。</p><h3 id="安装wps">安装WPS</h3><p>办公软件我还是习惯 WPS 。 WPS for Linux 还没有广告。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">yay -S wps-office wps-office-mui-zh-cn ttf-wps-fonts<br></code></pre></div></td></tr></table></figure><h3 id="安装typora">安装typora</h3><p>正常情况下，使用 yay 是没有办法安装 Typora的。如果你安装成功了，那就跳过这步；否则，请继续往下阅读。</p><p>请确保你已经安装了 debtap 。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">debtap格式软件转换器</span><br>yay -S debtap<br></code></pre></div></td></tr></table></figure><p>下载 Typora<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.123pan.com/s/gqA9-X7YB">[5]</span></a></sup>。</p><p>下载完成之后，我们使用<code>ls</code>查看当下目录的软件：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051422846.png"alt="查看typora" /></p><p>输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo debtap -u<br>sudo debtap -q *.deb<br></code></pre></div></td></tr></table></figure><p>这里我们使用匹配模式，使用<code>*</code>代替了<code>typora</code>。<code>-u</code>是更新debtap，<code>-q</code>是静默模式。如果不出意外，你的目录下会出现一个压缩包：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051432479.png"alt="重建之后的压缩包" /></p><p>输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo pacman -U *zst<br></code></pre></div></td></tr></table></figure><p>安装 typora 。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051434525.png"alt="安装完成" /></p><h3 id="安装坚果云">安装坚果云</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">yay -S nautilus-nutstore<br></code></pre></div></td></tr></table></figure><p>其中选择<code>nutstore-experimental</code></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051445504.png"alt="坚果云" /></p><h3 id="安装其他软件">安装其他软件</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">网易云音乐</span><br>yay -S netease-cloud-music<br><span class="hljs-meta prompt_"># </span><span class="language-bash">vscode 文本编辑器，编程使用，选择性</span><br>yay -S visual-studio-code-bin<br><span class="hljs-meta prompt_"># </span><span class="language-bash">谷歌浏览器，随意</span><br>yay -S google-chrome<br><span class="hljs-meta prompt_"># </span><span class="language-bash">zotero文献管理器</span><br>yay -S zotero<br><span class="hljs-meta prompt_"># </span><span class="language-bash">百度网盘 安装百度网盘之前先使用 sudo pacman -S patch</span><br>yay -S baidunetdisk-bin<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装picgo</span><br>yay -S picgo-appimage<br><span class="hljs-meta prompt_"># </span><span class="language-bash">腾讯会议，如果下载不了，建议按照Typora的方式，到官网下载deb格式之后转化安装</span><br>yay -S wemeet<br></code></pre></div></td></tr></table></figure><p>至此，我们所有的需要的软件都安装完了。</p><hr /><h1 id="美化桌面">美化桌面</h1><p>先看一下我的主题</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051526958.png"alt="亮色" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051525247.png"alt="暗色" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051526518.png"alt="图标" /></p><p>首先，在自己家目录下创建文件夹<code>.themes</code>和<code>.icons</code></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">mkdir .themes<br>mkdir .icons<br></code></pre></div></td></tr></table></figure><p>安装主题有两种方法</p><p>方法一、自己下载</p><ol type="1"><li>首先下载 WhiteSur Gtk Theme<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.gnome-look.org/p/1403328">[2]</span></a></sup>主题， McMojave-circle<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.pling.com/s/Gnome/p/1305429">[3]</span></a></sup>图标， macOS Big Sur<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://github.com/ful1e5/apple_cursor">[4]</span></a></sup>光标</li><li>把主题挪到<code>.themes</code>，图标和光标挪到<code>.icons</code></li></ol><p>方法二、使用我提供的压缩文件</p><ol type="1"><li><p>登陆 ftp</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">ftp 101.200.84.36<br></code></pre></div></td></tr></table></figure></li><li><p>用户名是<code>ftp</code>，没有密码直接回车。然后下载我提供的压缩包：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">get themes.tar.gz<br>get icons.tar.gz<br></code></pre></div></td></tr></table></figure></li><li><p>解压缩</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">tar zxf themes.tar.gz -C ~/.themes<br>tar zxf icons.tar.gz -C ~/.icons<br></code></pre></div></td></tr></table></figure></li></ol><p>然后结束准备，开始安装。</p><p>查看自己的 Manjaro 是否有 gome-tweaks (图标显示为 tweaks 或者 优化)，如果没有就下载：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo pacman -S gnome-tweaks<br></code></pre></div></td></tr></table></figure><p>打开软件，按下面配置：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051614226.png"alt="tweaks配置" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051615629.png"alt="tweaks配置" /></p><p>如果使用 firefox 浏览器，安装 firefox 主题</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">cd ~/.themes/WhiteSur-gtk-theme/<br>./tweaks.sh -f<br></code></pre></div></td></tr></table></figure><p>完结！！</p><hr /><h2 id="后语">后语</h2><p>Manjaro 作为我的主力系统已经有一段时间了，感觉并非得使用 Windows。通过一些烈的美化之后，其实 Manjaro Gnome 还是很好看的。虽然与 ManjaroKDE 的高度定制性相比有点小巫见大巫，但是我喜欢的本来就是它的简洁。</p><p>使用这些软件也并非一帆风顺，例如我的电脑及使用不了 Flameshot，可能因为分辨率太高导致字体怎么调都怪怪的等等，但是最终都克服了这些问题。我的电脑没有安装QQ或者微信，因为我感觉自己用不上它们。</p><p>腾讯会议不能使用 聊天 ，也看不到 弹幕 。</p><hr /><h1 id="相关网站">相关网站</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>https://aur.archlinux.org/<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>https://www.gnome-look.org/p/1403328<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3"class="footnote-text"><span>https://www.pling.com/s/Gnome/p/1305429<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4"class="footnote-text"><span>https://github.com/ful1e5/apple_cursor<a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:5"class="footnote-text"><span>https://www.123pan.com/s/gqA9-X7YB<a href="#fnref:5" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>应用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Manjaro + Windows11双系统安装</title>
    <link href="/2022/03/04/manjaro-windows11%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"/>
    <url>/2022/03/04/manjaro-windows11%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么要用-linux-系统">为什么要用 Linux 系统</h1><p>实际上，使用哪一个系统是没有理由的，个人电脑上基本没有能和 Windows过招的系统。然而对我来说， Windows 太麻烦了：8G 内存跑 Windows还只是勉强流畅，特别是当我微信和QQ一起打开的时候，内存占用到我都怀疑人生了。我确实尝试过重装系统，但是对我来说怎么重装，最后还是会走到讨厌它的那一步。</p><p>Windows11 出来之后， Windows系统给我的印象就好了很多，特别是它的搜索功能，虽然它早就存在了，毕竟我不喜欢在桌面上放图标。使用它一阵子之后，我还是萌生了换系统的想法。可能这种想法一直存在脑海里，我才不喜欢Windows 系统。</p><p>既然要换系统，那我得找到一个令我满意的系统。我把目光放到了 Linux，毕竟 MacOS 可望不可及。然而问题是，开源而且免费的 Linux系统还是有很多分支，多到一只手根本数不过来。此外，这些系统虽然都叫做Linux ，但是彼此之间差别还是不小。</p><p>我最开始接触的 Linux 是 CentOS 。所以当时打算换到 CentOS8，虽然它似乎更合适做服务器。然而天有不测风云，谁知道 CentOS Linux不再更新了。虽然 CentOS Stream 仍然被维护，但是我觉得 CentOS已经等于被宣判了死刑，因此只能再找出路。</p><p>在虚拟机里安装了各种版本的 Linux 之后，我对 Manjaro Linux 和 ArchLinux 有非常大的好感。 Arch Linux 自由度非常高，可定制性强，官方 wiki也很丰富，是探索 Linux 极好的选择。我花了好一阵子重温命令行安装 Linux的知识，还给它安装了各种桌面。然而 Arch总给我一种怪怪的感觉，可能对我来说，它吸引人的方面是拿来把玩，而不是作为主力系统。</p><p>但是我很喜欢 Arch ，于是各种搜罗有关 Arch 系统的信息，最后发现了Manjaro 。 Manjaro 是 Arch 的衍生版，但是和 Arch又有一定的区别。例如同样作为滚动发行的 Linux ， Manjaro官方包 相比而言比Arch 更安全一点——因为它不是直接发布的，而是要经过一定的测试。 Manjaro的另一特点是基本做到开箱即用，而 Arch本身需要的配置很繁琐——这也是它吸引人的地方。</p><p>Manjaro 满足了我懒得折腾的心愿，同时作为 Arch 的衍生品，它与 Arch共享很多的包。众所周知， Arch 拥有非常强大的社区支持。</p><p>Manjaro 官网<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="https://manjaro.org/">[1]</span></a></sup> 提供了三种版本的 Manjaro 桌面：</p><ol type="1"><li>XFCE ，轻量级桌面。</li><li>KDE ，重量级桌面，实际上现在和 GNOME也差不多，可定制性高，桌面漂亮。</li><li>GNOME ，中量级桌面，简约高效。</li></ol><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042022699.gif"alt="Manjaro官网" /></p><p>我选择了 GNOME ，因为它给我的感觉正像 Arch，非常简单，没有多余的软件，没有负担。实际上 KDE也为人称道，特别是它的高定制性，几乎可以定制所有的细节。然而我还是选择GNOME，我要的就是简单。既然要简单，自然选择<ruby>最小安装<rt>Minimal</rt></ruby>，LTS 是长期支持版，我没有选择。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042028792.png"alt="最小安装" /></p><hr /><h1 id="制作启动盘">制作启动盘</h1><p>下载 Manjaro 镜像之后，我们需要制作启动盘，这里推荐使用国人的 Ventoy<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="https://www.ventoy.net">[2]</span></a></sup>。这个小工具看起来小，但是可以引导多个系统。只需要把镜像放到它制作的启动盘里就可以引导多个系统。这有什么好处？通常情况下，我们制作启动盘的方式是格式化U盘，然后使用启动盘制作软件制作启动盘(格式化是必须的，有时是自己手动，有时是启动盘软件格式化)。这样，一个U盘无论多大，一次只能引导一个系统，要引导新系统时都需要格式化。一来麻烦，二来对U盘的使用寿命也不好。当然，最重要的是，Ventoy 引导多个系统的能力听起来就很厉害。</p><p>有一个教训是我直接给自己的电脑装了 Manjaro 之后，由于某些需要想要装回Windows，此时所有的启动盘制作软件制作的启动盘都没有用。制作启动盘之前必须格式化U盘，所以当我把系统搞坏之后连原本的Linux系统也装不了。最后只能手动制作启动盘，纯手工给U盘分区，因为我要安装的系统超过了fat32 文件系统的最大上限。</p><p>因此使用 Ventoy是一项保险的举措，至少等你后悔的时候，它不会让你失望。</p><h2 id="下载ventoy">下载Ventoy</h2><p>我们可以到官网下载 Ventoy 。如果不想安装，可以下载 便携版，开箱即用。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042039980.png"alt="Ventoy官网" /></p><h2 id="开始制作">开始制作</h2><p>制作启动盘很简单，打开 Ventoy ，然后选择U盘即可。通常情况下， Ventoy会自动识别你的U盘。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042050020.png"alt="启动Ventoy" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042051376.png"alt="制作启动盘" /></p><p>安装完之后，把你的 ISO 镜像复制到 U盘。你会发现 U盘仍旧是空的，实际上只是你看不见其他文件而已。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042057885.png"alt="复制ISO镜像" /></p><hr /><h1 id="电脑分区">电脑分区</h1><p>对我来说， Linux 够用了，但是谁也不知道可能又需要 Windows专有的软件。既然要安装双系统，而且是 Linux 作为主系统，那只需要给Windows 保留一小部分的空间。</p><p>Windows分区比较简单，系统就自带了。我们只需要搜索“分区”就会弹出需要的软件，选择就好了。搜索使用<kbd> Windows</kbd>+ <kbd>s</kbd>。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042058958.png"alt="搜索分区软件" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042059442.png"alt="查看硬盘" /></p><p>分区的时候，固态硬盘(C盘)分出一部分，待会安装 Manjaro；机械硬盘也要分，主要作为存储区。我是在已经安装完毕的电脑演示的，所以可以看到，实际上我的电脑已经分成了很多的区。</p><p>要分区，先压缩一定的空间，通常是你想要分配多少就要所多少。记住，1G=1024M 。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042102453.png"alt="演示分机械硬盘" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042104626.png"alt="压缩" /></p><p>压缩完之后新建 卷 。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042104738.png"alt="压缩完之后" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042106771.png"alt="继续选择" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042106229.png"alt="分配驱动号" /></p><p>新建卷标，最好是有意义的卷标。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042107720.png"alt="设置卷标，建议设成有意义的卷标" /></p><p>分区完成。按照这个方式给固态硬盘分区。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042108967.png"alt="分区完成" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042109229.png"alt="成果" /></p><p>至此，我们已经分区完成了。注意，后面我们要做的就是把 Linux安装到我们分出來的 新盘 。</p><hr /><h1 id="进入bios或者uefi引导界面">进入BIOS或者UEFI引导界面</h1><p>BIOS 和 UEFI是系统安装的引导界面，也就是我们给老电脑开机的时候，看到的黑乎乎的界面。每个厂商的引导界面的快捷键都不一样，最常见的是<kbd>F2</kbd> 和 <kbd>F12</kbd>。例如我的是华硕电脑，使用<kbd>F2</kbd>。通常这些东西都是可以在网上查到的。</p><p>那什么时候按呢？简单，就是重启电脑的，等到刚刚出现厂商标志的时候，以迅雷不及掩耳之势按住你电脑的按键。当然，最傻的方式是电脑重启黑屏之后就一直按你的快捷键。</p><p>进入 BIOS 或者 UEFI 之后，先去高级模式( Advance Mode )把 Boot 的Security 改成 disable(关闭) 。然后选择 Boot Mode中的U盘启动。当然，如果你的界面和我的一样，你也可以选择调整右手边的 BootPriority ，把U盘调到最前面。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042120262.jpg"alt="选择BootMode" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042125263.jpg"alt="选择U盘启动" /></p><p>选择想要安装的系统。我这里有两个系统，一个 Arch ,一个 Manjaro ，选择Manjaro ，回车。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042126910.jpg"alt="Ventoy引导界面" /></p><p>这里可以进行简单的配置。然后选择 open source drivers 。 open source是开源，通常等于使用 Intel 显卡； proprietary drivers 就是闭源，自然就是Nvidia了。我的电脑是双显卡，所以使用哪一个都差不多。不过说实话，我使用闭源的Nvidia的时候出现了比较大的问题：开机容易卡在黑黢黢的界面。修改之后直接回车。实际上也不用修改，后面还是可改的。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042132829.png"alt="这里简单配置一下" /></p><p>如果你的电脑出现一堆的文字，那是正常现象，不用担心。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042137953.png"alt="启动" /></p><p>等到进入这个界面就说明没问题了。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042139339.png"alt="Live 界面" /></p><p>这里可以体验一下 Manjaro ，因为所做的修改都不会保留下来。</p><hr /><h1 id="安装">安装</h1><p>记得连接网络，点击 右上角 ，连接网络。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042141928.png"alt="记得连接WIFI" /></p><p>连接网络之后开始安装，点击 右下角的安装软件——最右下角，开始安装。</p><p>选择语言等基本配置。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042145530.png"alt="开始安装" /></p><p>一直回车到分区界面，选择 手动分区 (manual partitioning)。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042146756.jpg"alt="选择手动分区" /></p><p>选择磁盘，找到我们之前的分区，通过 标签(卷标)可以查看我们的分区——所以分区的时候一定要给一个有意义的卷标。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042150337.jpg"alt="(选择我们的分区)" /></p><p>点击我们分出的区域——注意，一定要选择我们的分区，例如我的分区 Linux，然后选择 创建(Create) ，给大小 300M 就可以了， 文件系统 (filesystem)是 fat32，挂载点是<code>/boot/efi</code>，给一个卷标，标识为<code>boot</code>，选择<code>OK</code>。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042157081.png"alt="分区" /></p><p>选择 空闲空间 (free space)，继续新建。这里有两种情况：</p><h2id="你有两块硬盘一块固态硬盘一块机械硬盘并且分别分出了两个分区给linux">你有两块硬盘，一块固态硬盘，一块机械硬盘，并且分别分出了两个分区给Linux</h2><p>分区布局：</p><ol type="1"><li>EFI 分区，固态硬盘，300M足矣。</li><li>/分区(root)，固态硬盘，剩余的空间。</li><li>swap 分区，机械硬盘，和自己的内存一样大。</li><li>/home 分区，机械硬盘剩下的三分之二以上。</li><li>/opt 分区，机械硬盘最多三分之一。</li></ol><p>固态硬盘剩余的所有空间新建一个分区，作为 根(root)挂载点，文件系统是<code>ext4</code>。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042203158.png"alt="根分区" /></p><p>然后点击顶部的存储器，选择机械硬盘。同理选择自己分出來的那一部分——说过了，看自己的卷标识别，千万不要在固态硬盘和机械硬盘上使用Windows系统的分区，不然没人救得了你。</p><p>分出一部分的空间，新建一个 swap 分区， swap大小是你的内存大小。我的是 8G 内存，所以选择 8G。文件系统选择<code>linuxswap</code>，标记<code>swap</code>，卷标自定义，最好有意义。不用选择挂载点。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042211258.png"alt="swap分区" /></p><p>最后，把你机械硬盘的剩余空间分成两部分——四六或者三七分，少的部分作为<code>/opt</code>挂载点，文件系统选择<code>ext4</code>，没有标记：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042215243.png"alt="opt分区" /></p><p>最后剩余的空间放到<code>/home</code>分区，文件系统还是<code>ext4</code>，无标签，卷标可以给个名字</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042217101.png"alt="home分区" /></p><p>至此，你的分区差不多了。最后你的分区看起来像这样(注意，原本还有windrows系统的分区，这里演示不了。下面是固态硬盘分区和机械硬盘的分区)：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042220498.png"alt="固态分区" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042222826.png"alt="机械硬盘分区" /></p><h2 id="你只有一块分区">你只有一块分区</h2><p>参照两块硬盘的分区，只不过不用分出<code>/opt</code>和<code>/home</code>分区而已。</p><p>分区布局：</p><ol type="1"><li>EFI 分区，同上。</li><li>swap 分区，同上。</li><li>/分区(root)，剩余的所有空间。</li></ol><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042229457.png"alt="分区如下" /></p><p>分区一直是一个见仁见智的话题，如果你有自己的想法，可以不参照我的方案。</p><hr /><h1 id="安装-1">安装</h1><p>最后填写一些信息，然后就安装，重启。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042226386.png"alt="配置" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042227959.png"alt="安装" /></p><p>至此， Manjaro 安装完毕。</p><hr /><h1 id="后语">后语</h1><p>安装完毕之后，我们还需要安装一些常用的软件、使用中文拼音等，但是一篇写不完，所以后面我会再详细介绍怎么安装常用软件以及美化自己的系统。</p><hr /><h1 id="相关网址">相关网址</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>https://manjaro.org/<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>https://www.ventoy.net<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里云服务器搭建 FTP 服务</title>
    <link href="/2022/03/04/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAftp%E6%9C%8D%E5%8A%A1/"/>
    <url>/2022/03/04/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAftp%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="ftp协议">FTP协议</h1><p>FTP 协议，全称 文件传输协议(File Transfer Protocol)，是简单、高速的网络文件传输协议，支持 TCP/IP。早期的网络共享通常都是使用这个协议，现在也仍然有。当然，在其他的系统上有更好的选择，例如samba 等，但是在实操方面我只接触过 FTP 。</p><p>FTP可以搭建家庭内部的文件共享(局域网)和互联网文件共享(公网)。因为自己有了一台云服务器，所以打算在部署自己的FTP 服务器。如果有想法，可以以后搭建一个家庭的 FTP 它不香吗？</p><hr /><h2 id="准备">准备</h2><p>在开始之前，我们先准备需要的东西：</p><ol type="1"><li>一台云服务器。</li><li>SSH 客户端。</li><li>FTP 服务端，我使用 vsFTPd ； FTP 客户端，我选择 FTP 。</li></ol><h3 id="服务器">服务器</h3><p>我用的是阿里云 ECS共享型4n ， RockyLinux<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="https://rockylinux.org">[1]</span></a></sup> 系统，兼容 CentOS7/8 和 RHEL 。由于 CentOS6我没用过，所以不知道区别如何。配置什么的不重要。</p><p>如果不使用云服务器而是使用虚拟机的话，那就什么都不重要了。</p><h3 id="ssh-客户端">SSH 客户端</h3><p>使用 SSH 是为了连接服务器，当然，也可以使用服务器官方提供的 VPC。如果没有这些概念，那就使用 SSH 。 对于虚拟机用户，我还是建议使用 SSH，因为 VMware 和 Virtual Box的剪贴板共享功能不大好使，特别是不同操作系统之间互通。</p><hr /><h1 id="连接服务器">连接服务器</h1><h2 id="配置安全组规则">配置安全组规则</h2><p>在获得自己的服务器之后，到阿里云帐号的控制台-&gt;云服务器ECS-&gt;实例-&gt;管理-&gt;安装组。如果之前配置过自己的安全组，就在安全组的 配置规则 中选择 快速添加，然后设置选择全部， 添加 。这一步很重要，因为我之前在修改 SSH端口和配置 FTP时忘了这一步，导致一直在和防火墙进行斗争，最后发现是这里的端口没开放。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203040956159.png"alt="添加规则" /></p><h2 id="ssh连接">SSH连接</h2><p>默认情况下，服务器的 SSH 服务端( SSHd)是开放的，如果想查看是否开放，可以使用<code>sudo systemctl status sshd</code>查看。老版本使用init.d 我不熟悉，所以使用 systemctl 。如果你使用的是 CentOS6，那只能网上查资料了。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo systemctl status sshd<br></code></pre></div></td></tr></table></figure><p>如果打开了，就会出现 active 的提示：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203041006651.png"alt="sshd服务端已打开" /></p><p>如果是 inactive ，那就打开 SSHd，先使用<code>sudo systemctl enable sshd</code>设置开机自启动，然后再<code>start</code>：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">enable</span>设置自启动，start启动</span><br>sudo systemctl enable sshd <br>sudo systemctl start sshd<br></code></pre></div></td></tr></table></figure><p>客户端连接使用<code>ssh username@ip -p portnumber</code>。其中，如果你修改了SSH端口，就加上<code>-p 端口</code>，正常情况下可以省略这个参数。<code>username</code>是你的服务器用户名，不建议使用root 登陆，<code>ip</code>是你的服务器 公网IP ，注意不是 局域网IP，通过<code>ifconfig</code>和<code>ip addr</code>查到的是 局域网IP ，公网IP可以在阿里云控制台查找，通常服务器开通之后也会有手机短信告知你的服务器地址。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">ssh chunshuyumao@192.168.0.10 -p 1234<br></code></pre></div></td></tr></table></figure><p>连接上之后，输入密码就行了。如果想使用无密码登陆，可以在客户端使用<code>ssh-keygen</code>生成公私钥。<code>-t</code>是加密的类型，<code>-C</code>是注释，也可以不使用<code>-C</code>和之后的参数。回车三下，然后到自己的的家目录下就找到<code>.ssh</code>文件夹，里面有生成的公私钥。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203041022580.png"alt="生成公私钥" /></p><p>然后通过<code>ssh-copy-id username@ip</code>传输自己的公钥，不断确定即可。如果有多个公钥，可以使用参数<code>-i file.pub</code>指定使用哪一个。这里不过多描述。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">ssh-copy-id -i ~/.ssh/id_rsa.pub chunshuyumao@192.168.0.10<br></code></pre></div></td></tr></table></figure><p>登陆成功的提示。如果觉得记住自己的 公网IP困难，可以写一个脚本自动登陆。例如我下边就是写了一个叫做<code>swc</code>(switch)的函数，快速切换服务器——如果你使用的是其他SSH客户端 ，那算我没说。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203041031461.png"alt="登陆成功" /></p><hr /><h2 id="开始配置-ftp">开始配置 FTP</h2><p>我们花了太多时间在 SSH 的连接上了。</p><h2 id="下载-ftp-客户端和服务端">下载 FTP 客户端和服务端</h2><p>服务端和客户端我使用的是<code>vsftpd</code>、<code>ftp</code>，在服务器中可以两个都下载，用于调试：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo yum install -y vsftpd ftp<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203041043259.png"alt="安装FTP客户端和服务端" /></p><p>当然，你也可以只在自己的电脑下载<code>ftp</code>，服务器只下载<code>vsftpd</code>。其他系统下载可以网上查教程，或者先用自己的系统查找。例如我的Manjaro系统，但是它没有<code>ftp</code>这个单独的软件包，而是自带了。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">pacman -Ss vftpd<br>pacman -Ss ftp<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203041040266.png"alt="查找ftp服务端和客户端软件包示例" /></p><h2 id="配置服务端">配置服务端</h2><p>输入<code>sudo vim /etc/vsftpd/vsftpd.conf</code>，编辑配置，可以参考官网的介绍<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="http://vsftpd.beasts.org/vsftpd_conf.html">[2]</span></a></sup>。当然，<code>vim</code>可以修改成你喜欢的任何编辑器——重点是你的服务器得下载了，例如<code>nano</code>。一定要用<code>sudo</code>不然你无法修改配置。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo vim /etc/vsftpd/vsftpd.conf<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203041045484.png"alt="编辑配置" /></p><p>修改<code>anonymous_enable=YES</code>,这个配置是允许匿名登陆，匿名登陆表示任何人只要知道你的服务器公网IP 就可以登陆，默认的文件夹保存在<code>/var/ftp</code>中。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203041048745.png"alt="image-20220304104811696" /></p><h2 id="开启ftp服务">开启FTP服务</h2><p>首先，查看你的防火墙是否打开。<code>firewalld</code>通常是 RedHat高版本系统( CentOS7/8、RockyLinux )的默认防火墙，<code>iptables</code>是Debian 系列( Ubuntu 等)默认的防火墙。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo systemctl status firewalld<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者</span><br>sudo systemctl status iptables<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203041051462.png"alt="防火墙" /></p><p>如果是开启( active )的，解决办法有两个： 关闭 和 开放指定端口和服务。</p><ol type="1"><li><p>关闭防火墙。输入命令<code>sudo systemctl stop firewalld</code>。关闭自启输入命令<code>sudo systemctl disable firewalld</code>。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo systemctl stop firewalld<br></code></pre></div></td></tr></table></figure></li><li><p>开放指定服务和端口。输入<code>sudo firewall-cmd --add-port=21/tcp --permanent</code>和<code>sudo firewall-cmd --add-service=ftp --permanent</code>。如果想让服务器保持开放这个端口，可以加<code>--permanent</code>，否则不用加。然后重新启动防火墙。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo firewall-cmd --add-port=21/tcp --permanent<br>sudo firewall-cmd --add-service=ftp --permanent<br>sudo firewall-cmd --reload<br></code></pre></div></td></tr></table></figure><p>查看防火墙规则:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo firewall-cmd --list-all<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203041104495.png"alt="规则" /></p></li></ol><p>开启 vsFTPd 服务和自启动:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo systemctl enable vsftpd<br>sudo systemctl start vsftpd<br></code></pre></div></td></tr></table></figure><p>检查 vsftpd 服务是否打开：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203041110173.png"alt="检查是否打开" /></p><h2 id="客户端连接">客户端连接</h2><p>在服务器登陆 FTP服务，由于是服务器登陆，所以可以使用<code>localhost</code>作为 IP 。登陆匿名用户 ，帐号是<code>ftp</code>，密码直接回车。然后就可以使用 FTP服务了。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">ftp localhost<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203041114988.png"alt="服务器客户端登陆" /></p><p>本地客户端登陆，使用<code>ftp 公网IP</code>,一样进行登陆。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">ftp 101.200.84.36<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203041117349.png"alt="本地客户端登陆" /></p><p>至此， FTP 服务搭建完成。下载一个文件试试:</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203041120475.png"alt="下载文件" /></p><p>看到，由于我们使用的是 FTP主动模式，所以从服务器下载的时候，服务器也建议使用 被动模式 。不过目前的 主动 和被动 对我而言没有区别，所以没有开启被动模式。如果不希望别人登陆自己的FTP ，可以在配置文件中( /etc/vsftpd/vsftpd.conf)把<code>anonymous_enable</code>改成<code>NO</code>。</p><hr /><h1 id="总结">总结</h1><p>本来搭建 FTP是很简单的，但是自己的安全组规则没配好，导致一直有问题。我不是很清楚安全组规则和防火墙的区别——所以也许在一些人的操作中，不用控制防火墙也能够使用FTP 。懒了，所以不想去探究，也许有时间的话我会试试，不过不是现在。</p><p>配置 SSH端口的时候也出现了无法使用指定端口的问题。网上查了一堆博客，发现大家基本是在调试SELinux 和 防火墙。一个也解决不了问题，最后还是通过阿里云控制台修改了安全组规则，所以这个也很迷。我的服务器SELinux 默认是关闭的，实际上开启的话，配置 SSH端口更麻烦，但是自然也更安全。</p><hr /><p>##相关网址</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>https://rockylinux.org<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>http://vsftpd.beasts.org/vsftpd_conf.html<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建博客</title>
    <link href="/2022/01/03/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2022/01/03/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>开始阅读之前我希望你已经看过我写的前两篇文章，因为它们具有一定的连贯性。</p><p><ahref="https://chunshuyumao.GitHub.io/2022/01/03/Markdown与Typora/">Markdown与Typora</a></p><p><ahref="https://chunshuyumao.GitHub.io/2022/01/03/Typora-picgo写作平台的搭建/">Typora+picgo写作平台的搭建</a></p></blockquote><hr /><h1 id="前言">前言</h1><p>搭建个人博客是一件细活，得有自己的服务器、域名，甚至一点前端基础，因此很多搭建个人博客的都是程序员。然而今天我要做的就是借助Hexo<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="https://hexo.io/">[1]</span></a></sup> 和GitHub<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="https://GitHub.com/">[2]</span></a></sup> 搭建免费的个人博客。下面是我们用到的工具：</p><ul><li>Git<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="https://Git-scm.com/">[3]</span></a></sup></li><li>GitHub 账号</li><li>文本编辑器(最好是 Markdown 编辑器，例如 Typora)</li><li>Fluid<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="https://hexo.fluid-dev.com/">[4]</span></a></sup> 主题</li><li>PicGo</li><li>一台电脑</li></ul><p>先展示自己的博客封面和文章内部。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/image-20220103223925111.png"title="我的博客封面(白昼模式), 主题改自fluid"alt="我的博客封面(白昼模式), 主题改自fluid" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201041457314.png"alt="文章内容(暗夜模式)" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201041541080.jpg"alt="手机展示" /></p><hr /><h1 id="准备">准备</h1><p>在真正搭建自己的博客之前，我们需要 GitHub 账号和 Git。</p><blockquote><p>Git 是著名的分布式版本管理器。简而言之，Git可以为自己写的文本(文章、代码等)管理历史版本。Git可以对文本文件进行版本控制，使用 Markdown 可以配合Git进行管理。</p><p>GitHub 是世界上最大的开源代码管理平台，通过 Git进行版本控制，只需要一个邮箱即可申请注册。GitHub通过一个个仓库(repository)管理代码，免费用户的总仓库空间是500M。这个空间看起来太小了，但是对于写博客和代码来说够了——大不了再审请一个。虽然国内也有码云(Gitee)平台，并且提供2G 空间，但是用来搭建的 Pages 需要实名认证。</p></blockquote><p>国内访问 GitHub 时常出现连不上或者访问速度慢，所以要有耐心。</p><h2 id="github账号及仓库准备">GitHub账号及仓库准备</h2><p>通过后面提供的链接进入GitHub<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="https://GitHub.com/">[2]</span></a></sup>申请一个新的账号。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051555670.png"alt="注册" /></p><p>像 Gitee一样新建一个仓库，仓库名字一定是<code>&#123;你的id&#125;.github.io</code>。</p><blockquote><p>注意：</p><p>如果你的 id 是 <code>wangxiaoming</code>，那仓库名字必须是<code>wangxiaoming.github.io</code>，这样就可以通过<code>wangxiaoming.GitHub.io</code>访问你的博客了。如果你选择了中文名，那就注意了，你需要在浏览器的地址栏中找出你的名字的英文名是啥，所以推荐直接使用拉丁字母。</p><p>关于Gitee建立仓库，可以查看另一篇文章 <ahref="https://chunshuyumao.GitHub.io/2022/01/03/Typora-picgo写作平台的搭建/">Typora+picgo写作平台的搭建</a></p></blockquote><p>Public 是公开你的仓库，实际上就是公开自己的博客。添加一个 readme文件为的是简单——它会自己帮你建立一个 <code>main</code> 分支。这个分支<code>main</code> 以前叫作 <code>master</code>，但是现在<code>master</code>成了<code>亚美利加</code>政治不正确的代名词，所以——你懂的。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051623158.png"alt="建立pages" /></p><p>接下来选择<code>settings-&gt;Pages</code>，查看是否建立了自己的网站。你甚至可以打开看看：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051634474.png"title="查看是否建立成功" alt="查看是否建立成功" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051635946.png"title="打开后自己的网站，这里显示的是readme.md中的文字"alt="打开后自己的网站，这里显示的是readme.md中的文字" /></p><p>接下来是准备Git<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="https://Git-scm.com/">[3]</span></a></sup> 和hexo<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="https://hexo.io/">[1]</span></a></sup>。</p><h2 id="git准备">Git准备</h2><p>首先去Git<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="https://Git-scm.com/">[3]</span></a></sup> 官网下载：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051643214.gif"alt="Git下载" /></p><p>下载完成之后就可以安装了。安装的时候，一键确定到头即可。</p><p>连接 Git 和 GitHub</p><p>任意位置鼠标右键，打开<code>git bash</code>。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051720620.gif"alt="打开Git bash" /></p><p>分别键入</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;你的GitHub ID&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;你的GitHub注册邮箱&quot;</span><br>ssh-keygen -t rsa<br></code></pre></div></td></tr></table></figure><p>最后一段代码 <code>ssh-keygen -t rsa</code>用于生成公<ruby>钥<rt>yuè</rt></ruby>和私<ruby>钥<rt>yuè</rt></ruby>。公钥和私钥使用<code>rsa</code>方式生成。这是一种保密方式——公钥你可以公开，但是拿不到你的私钥是没法破译你的信息的。</p><p>配置公、私钥的时候，连续回车 <kbd>Enter</kbd> 三下，记住保存路径</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051911093.png"alt="配置信息和生成公钥和私钥" /></p><p>打开保存路径，复制公钥文件内容：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051907768.png"alt="打开路径，复制公钥" /></p><p>打开浏览器进入 GitHub ，登陆自己的账号，点击头像进入<code>settings-&gt;ssh and GPG keys</code>。选择<code>New SSH</code></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051938150.png"alt="ssh and GPG keys" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051940072.png"alt="配置公钥" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051940453.png"alt="输入密码确认" /></p><p>至此，Git 准备完成。休息一下就可以开启下一章了。</p><h2 id="配置-hexo">配置 Hexo</h2><p>在自己的文件管理器里准备一个文件夹，放置自己的博客文件。我建立一个Notes 文件夹，准备在里边放置自己的文件。</p><p>进入该文件夹，鼠标右键，打开<code>git bash</code>。注意，此时默认你已经安装过 PicGo，并且安装了<code>node.js</code>。如果没有，请先按照 <ahref="https://chunshuyumao.GitHub.io/2022/01/03/Typora-picgo写作平台的搭建/">Typora+picgo写作平台的搭建</a>安装好 Typora 和 PicGo ——或者简单安装 Node.js也可以。Node.js安装包也在后面给出了。</p><p>安装<code>hexo-cli</code>，键入</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npm install hexo-cli -g<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051757071.png"alt="安装hexo-cli" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051758857.png"alt="安装成功" /></p><p>初始化这个文件夹，键入</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">hexo init<br></code></pre></div></td></tr></table></figure><blockquote><p>如果你的文件在C盘(系统盘), 建议挪到非系统盘,</p></blockquote><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051759674.png"alt="初始化" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051801892.png"alt="等待安装" /></p><p>安装完毕。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051809431.png"alt="完毕" /></p><p>可以看到，安装完成之后，Notes里边出现了很多文件夹。后面我再解释这些文件夹是什么。</p><p>键入<code>hexo generate</code>或者<code>hexo g</code>，产生<code>public</code>文件夹，这就是你博客公布的文件夹。<code>generate</code>是<code>生成</code>。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">hexo generate<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051811903.png"alt="image-20220105181126819" /></p><p>键入<code>hexo server</code>或者<code>hexo s</code>，打开服务器，然后点击按住<kbd>ctrl</kbd>+<kbd>鼠标右键</kbd>点击给出的网址<code>https://localhost:4000</code>，或者直接在浏览器中输入也行：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051838511.png"alt="打开服务器" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051840878.png"alt="浏览博客" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051841974.png"alt="你的博客" /></p><p>本节终。</p><hr /><h2 id="部署博客到github-page">部署博客到GitHub Page</h2><p>如上，我们已经在本地配置好自己的博客。然而，我们的博客只能在自己的电脑查看，现在要做的是让它在任何网络下都可以查看。</p><p>用文本编辑器(记事本、Sublime Text、Notepad++、VS Code等)打开你的本地文件根目录的<code>_config.yml</code>配置文件。修改配置，英文都看得懂，主要看<code>url</code>一栏，填入你的GitHub Pages 地址，就是<code>https://&#123;你的ID&#125;.github.io</code>。</p><blockquote><p>_config.yml 称为“博客配置文件”</p><p>_config.landscape.yml 称为“博客主题配置文件”，简称“主题配置文件”</p></blockquote><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051918393.png"alt="本地文件根目录" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051932467.png"alt="修改配置" /></p><p>复制要部署的位置，一般为<code>https://github.com/&#123;你的id&#125;/&#123;你的id&#125;.github.io.git</code>，从仓库主页的<code>code</code> 中选 <code>http</code> 或者 <code>ssh</code>复制粘贴到博客配置文件最后一行，保存退出。</p><blockquote><p>注意：2022 年之后，repo 选项只能填写 SSH 的内容，也就是git@github.com:{你的id}/{你的id}.github.io.git</p><p>否则无法进行部署。</p></blockquote><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201082037858.png"alt="复制要部署的地址" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051957072.png"alt="粘贴" /></p><p>如果刚刚的<code>git bash</code>没关，那键入<code>clear</code>清屏。如果关了，那就重新在你的本地文件根目录打开，键入<code>npm install hexo-deployer-git --save</code>，安装部署软件：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npm install hexo-deployer-Git --save<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201052007899.png"alt="安装部署" /></p><p>键入<code>hexo deploy</code>或者<code>hexo d</code>进行部署。接下去控制台会打印很多文件，不用在意。由于GitHub 访问速度很慢，部署的时候可能会失败，不要放弃——多试几遍就行。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">hexo deploy<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201052008492.png"alt="部署" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201052012619.png"alt="失败了再试" /></p><p>如果对一次次地失败感到不耐烦的话，可以使用 Gitee 作为 Pages部署，但是 Gitee 需要实名认证，三思。</p><p>坐等部署的时候，先去要一个私人令牌，待会有用。<code>主页头像-&gt;settings-&gt;development settings</code></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201052029387.png"alt="获取私人令牌" /></p><p>生成一个Token，一样这东西复制一遍之后就会消失，所以最好记下，不然就得重新申请了。<code>expiration</code>可以选择过期时间。建议如果不保存Token 的话设置时间短一点。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201052034012.png"alt="选填" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201052035981.png"alt="生成" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201052036129.png"alt="复制token保存" /></p><p>ok，部署弹出登录框了。我们选择 Token登录，因为其他方式加载实在太慢了，直接使用 Token它不香吗？要细心，因为我刚刚就写错了自己的网址，多了一个<code>a</code>，谁知道在哪张图出现的？</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201052038375.png"alt="选择token登录" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201052055903.png"alt="成功！！" /></p><p>部署成功，手机查看试试：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201052100233.jpg"alt="手机展示" /></p><p>至此，我们的博客已经做完了！！</p><hr /><h2 id="优化主题">优化主题</h2><p>Hexo也有自己的主题网站，大家可以去逛。不过我这里就推荐我使用的fluid主题就行。照常，本地文件夹根目录打开<code>git bash</code>，键入</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npm install hexo-theme-fluid --save<br></code></pre></div></td></tr></table></figure><p>下载主题。下载完成之后，去<code>node_modules</code>中复制一份到<code>themes</code>文件夹，重命名为<code>fluid</code>。把Fuild主题配置文件(_config.yml)复制一份，重命名为<code>_config.fluid.yml</code>，移动到本地文件根目录。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201052050860.png"alt="下载重命名移动" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201052054624.png"alt="重命名" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201052059610.png"title="复制" alt="复制" /></p><p>打开本地文件根目录下的博客配置文件，修改主题为我们下载的 Fluid。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201052105142.png"alt="修改主题" /></p><p>重新部署</p><p>由于我们修改了主题，所以打开<code>git bash</code>，分别键入<code>hexo clean; hexo d -g</code>(这是缩写，下面是一次写一个命令)。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">hexo clean<br>hexo generate<br>hexo deploy<br></code></pre></div></td></tr></table></figure><p>部署成功之后，浏览器查看自己的主题是否成功应用。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201052113427.png"alt="重新部署" /></p><p>Fluid<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="https://hexo.fluid-dev.com/">[4]</span></a></sup>主题的文档非常丰富，大家想要让自己的主题更个性化可以查阅文档。</p><hr /><h2 id="写博客">写博客</h2><p>接下来就是写博客了。使用 Markdown 写博客，因此我们先生成一个 MD文件。在本地文件根目录打开<code>git bash</code>，键入</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">hexo new post 文章名字<br></code></pre></div></td></tr></table></figure><p>然后到本地文件根目录下的<code>source</code>文件夹下的<code>_post</code>查看md文件</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201052118645.png"alt="新文档" /></p><p>然后就开始使用Typora等Markdown编辑器编辑了。</p><p>写完要发布的话，键入</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">hexo clean<br></code></pre></div></td></tr></table></figure><p>清除旧文件(选择性，也可以不清除)。然后键入<code>hexo server -generate</code>或者<code>hexo s -g</code>生成，<code>s</code>可以在本地预览，就是点击<code>https://localhost:4000</code>进行预览。如果觉得可以了，就用<code>hexo deploy</code>或者<code>hexo d</code>进行部署。也可以直接写完后键入<code>hexo deploy -generate</code>或者<code>hexo d -g</code>生成与部署。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">hexo s -g<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">hexo d<br></code></pre></div></td></tr></table></figure><p>然后你的文章就可以分享给其他人了！虽然如此，但是博客往往是一个人的快乐，分不分享倒无所谓。</p><blockquote><p>注意：</p><p>生成md文件不一定要使用 hexo newpost，也可以直接修改扩展名，使用hexo命令只是为了按照模板生成文件而已，模板在本地文件根目录scaffold 文件夹中，可以自己修改模板，具体可以参照Hexo<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="https://hexo.io/">[1]</span></a></sup> 官网和Fluid<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="https://hexo.fluid-dev.com/">[4]</span></a></sup> 官网。</p></blockquote><hr /><h1 id="后语">后语</h1><p>搭个人博客是一件快乐的事情，现在的社交软件很发达，博客已经成了过去式。现在还在写博客的是有两种人：</p><ul><li>大佬，日浏览成百上千，把知识反哺社会。</li><li>菜鸡，日浏览只有自己，把记不住的堆放。</li></ul><p>很多人都是后者，例如我。然而奇葩的是，程序员也写博客，而且频率远高于其他职业。为什么呢？</p><p>程序员工作中会碰到各种各样的问题，如果只是百度是解决不了问题的。百度上面没几个人能回答技术性问题，所以程序员搭建个人博客：碰到问题，如果解决了就记下，以后忘了可以再来看。日积月累也就成了一个知识库。</p><p>这，这不就是学习吗？我们很多时候都会有问题，所谓<code>人非生而知之者，孰能无惑</code>，也许查一下<code>wiki</code>、<code>百度</code>就解决了，但是问题来得快忘得也快。那为什么不记下来，以便以后复习呢？</p><p>在我们的刻板印象里，程序员是不食人间烟火的技术大佬，除了<code>0101010</code>什么都不知道，但是他们却做着最文艺的事——用文字记录生活点滴。反过来看，我们才除了能生成刻板印象什么都不知道。</p><p>所以，为什么不记录自己的生活呢？</p><blockquote><p>Node.js</p><p>链接: https://www.123pan.com/s/gqA9-blYB</p></blockquote><hr /><h1 id="相关网址">相关网址</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>https://hexo.io/<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>https://GitHub.com/<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>https://Git-scm.com/<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>https://hexo.fluid-dev.com/<a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fluid</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typora+PicGo写作平台的搭建</title>
    <link href="/2022/01/03/typora%E4%B8%8Epicgo%E5%86%99%E4%BD%9C%E5%B9%B3%E5%8F%B0%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <url>/2022/01/03/typora%E4%B8%8Epicgo%E5%86%99%E4%BD%9C%E5%B9%B3%E5%8F%B0%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<blockquote><p>前前言：</p><p>2022 年 03 月 24 日</p><p>这天我的 Gitee 图床被屏蔽了，所以后面的这些教程，把它看作 GitHub就行了。如果真个想使用 Gitee，建议自己的图片做个备份，经常换仓库。不然要死直接全死。这里也要说明一下，写了封邮件之后，16个小时左右仓库就解封了。不过解封归解封， Gitee 再见！</p><p>子曰：资本家的羊毛不可薅。</p></blockquote><h1 id="前言">前言</h1><p>Typora是优秀的本地写作软件，但是我们的文章可能不仅仅是保留在本地。有些时候我们会进行数据迁移，例如换一台电脑，或者发表到网上，我们会希望自己的图片只有一份，因为这样迁移的麻烦少了一个。图床是解决图片问题的最好方式。</p><blockquote><p>所谓 图床，就是把你的图片放到一个固定的地方(常指网络)，然后通过连接访问，这样要使用图片的时候，只需要知道图片的链接就行，不需要再保留一份。在Markdown写作中我们知道，使用图片的方式是<code>[图注](链接)</code>。因此，当用Markdown进行写作的时候，我建议配合图床使用——把图片保留在网络上而不是本地。</p></blockquote><p>现在可选的的图床很多，免费的、不免费的、国内的、国外的，但稳定的、普适的图床却很少。我用过的有sm.ms 图床和 Gitee。鉴于例如公众号这类平台有屏蔽外链的风险，我选择长期使用 Gitee作为图床。 Gitee 是国内最大的代码托管平台，内部提供仓库 2g(2021年)。这存储空间够用了。当然， GitHub也可以作为选择，但是访问可能慢一点，而且空间也少一点。</p><p>闲话少叙，准备好工具：</p><ul><li>Gitee<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="https://Gitee.com/">[1]</span></a></sup>账号</li><li>Typora<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="https://Typora.io/">[2]</span></a></sup>编辑器，Markdown 写作</li><li>GicGo<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://PicGo.GitHub.io/PicGo-Doc/zh/">[3]</span></a></sup>图床配置工具</li></ul><p>以上所需的工具都是免费的。</p><hr /><h1 id="picgo准备">PicGo准备</h1><p>PicGo是开源免费的图床配置工具，我一直在用。官网的介绍很清楚，如果有不清楚的可以看官网的文档。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051328651.png"alt="下载PicGo" /></p><p>点击下载之后一直往下拉，找到最新版的下载软件，</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051335431.png"alt="找到最新版(就是最上面的一版)" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051337609.png"alt="下载指定版本" /></p><p>下载之后就是简单的安装，安装完之后打开。</p><blockquote><p>注意：</p><p>PicGo 打开的时候只在任务栏出现，所以去任务栏点击打开。</p></blockquote><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051338760.png"alt="打开PicGo" /></p><p>因为 PicGo 没有内置 Gitee ，所以去插件设置查找 Gitee的插件安装。这三种都差不多，选择第一个就像我这样。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051339134.png"alt="查找插件并下载" /></p><p>插件安装的时候，系统会提示你安装 Node.js，同意安装就行了。安装之后效果如下：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051756804.gif"alt="安装" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051755069.png"alt="安装node.js" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051344742.png"alt="安装插件效果" /></p><p>好了， PicGo 准备好了，接下来准备白嫖 Gitee 的 2G 空间。</p><hr /><h1 id="gitee账号">Gitee账号</h1><p>以下为申请 Gitee 账号，如已有，请跳至 仓库配置 。</p><h2 id="申请账号">申请账号</h2><p>首先去 Gitee官方网站，点击注册。注册使用的是邮箱，可以临时申请一个邮箱——但是必须可以接受消息，因为后面需要验证。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051319152.png"alt="官网注册" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051350833.png"alt="注册" /></p><p>注册时需要用邮箱接收验证码，完成之后，登录进入主界面，创建新仓库：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051352300.png"alt="创建仓库" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051354452.png"alt="创建仓库" /></p><p>创建完成。</p><hr /><h2 id="仓库配置">仓库配置</h2><p>为了让 PicGo 行使生杀大权，我们需要给它一个令牌( token)，大概类似于一种权限。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051359935.png"alt="打开设置" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051401471.png"alt="私人令牌" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051401541.png"alt="生成新的令牌" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051402140.png"alt="描述可以写上一些信息" /></p><p>注意，令牌生成的时候复制下来保管好，因为它只生成一次，忘了就得重新申请。这里我就不重新申请了。把令牌粘贴到PicGo 的 Gitee 图床的 token 框。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051405605.png"alt="粘贴令牌" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051410924.png"alt="看图写话" /></p><p>然后设置为默认图床，确定，万事大吉！！</p><hr /><h3 id="配置typora">配置Typora</h3><p>默认已经安装了 Typora 了。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051415186.png"alt="配置Typora" /></p><p>至此，你完成了所有的配置。点击 验证图片上传选项验证是否成功。如果出现问题，最好检查你的 PicGo 中的 repo 写对没有。</p><h1 id="验证写作">验证写作</h1><p>我们验证一下效果：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201031746951.gif"title="上传图片" alt="上传图片" /></p><p>完成！</p><hr /><h1 id="后记">后记</h1><p>借助图床， Markdown式的写作更加轻松，也节约了图片管理的时间。然而需要注意的是， PicGo上传的图片大小最好不要超过 1M，因为这会影响加载的速度。而且有些时候，你的图片可能会被 Gitee吞掉，原因不明，也许是版权问题。</p><blockquote><p>PicGo 和 Typora 的安装包提供(无需登录，直接复制链接输入提取码即可):链接: https://www.123pan.com/s/gqA9-llYB 提取码:csym</p></blockquote><h1 id="相关网址">相关网址</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>https://Gitee.com/<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>https://Typora.io/<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3"class="footnote-text"><span>https://PicGo.GitHub.io/PicGo-Doc/zh/<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图床</tag>
      
      <tag>Makrdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown与Typora</title>
    <link href="/2022/01/03/Markdown%E4%B8%8ETypora/"/>
    <url>/2022/01/03/Markdown%E4%B8%8ETypora/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><h2 id="何为-markdown">何为 Markdown？</h2><p>Markdown(MD) 是一种轻量级的标记语言( markup language)。什么是标记语言？就是通过一些 标记，让你的文章具有一定的格式。让你专注于写字，而不是纠结于各种格式，它和txt 文件都是纯文本格式，只要有一个文本编辑器。</p><h2 id="markdown-编辑器">Markdown 编辑器</h2><p>MD 只是给文字做标签，所以要写 MD 建议使用合适的编辑器。这里首推国产的Typora 。理由如下：</p><ul><li>成熟。 Typora已经存在六七年了，发展很快，支持很多功能。截至目前为止，除了不能插入文献以外，我找不到它的任何缺点。</li><li>可定制化。现在很多的 MD 编辑器也在往这方面发展， Typora自然不例外。我不确定它是不是第一个把浏览器搬到笔记里的产品，但是它确实是我认识的第一个在笔记软件里可以使用浏览器功能的产品。</li><li>完美支持 MD 。甚至拓展 MD 。 MD为了简便被设计得非常简单，有时也因此存在其不足。对此很多平台都对 MD进行了拓展， Typora 也不例外。</li><li>所见即所得。 Typora 可以通过 MD的标记，轻轻松松渲染文本。让你的文章看起来更加舒服。</li><li>配合 Pandoc 可导成各种格式。 Pandoc是一个简单的文件格式转换器，支持几十种格式转换，特别是 MD。我们的文章写完之后可以借助它导出成各种格式。</li></ul><p>下面是 Typora中文网站<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="https://www.typora.io">[1]</span></a></sup>的 GIF 动图，这个网站和 Typora一样简洁大方。可以通过文章给出的网址下载 Typora。虽然现在的稳定版已经开始收费了，但是作者很良心，仍然提供beta版免费下载。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112211557226.gif"alt="Typora中文官网" /></p><p>MD 的文件扩展名是"md"，你想写 MD时只需把拓展名改成"md"即可。废话不多说，我们先来看 Markdown 的语法。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201032015265.png"alt="文件名" /></p><hr /><h1 id="markdown语法入门">Markdown语法入门</h1><h2 id="标题">标题</h2><p>Word 通常支持1~6级标题， MD 也一样。 MD的标题使用<code>#</code>作为标记。例如：</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Markdown"><span class="hljs-section"># 一级标题</span><br><span class="hljs-section">## 二级标题</span><br><span class="hljs-section">### 三级标题</span><br></code></pre></div></td></tr></table></figure><h3 id="动图演示">动图演示</h3><p>MD 支持最高六级标题。在 Typora中，标题的级数可以通过快捷键记忆：<code>ctrl+数字</code>，数字从 0 到 6，0 是正文，1~6 是标题。下面是演示：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112211621673.gif"alt="标题输入" /></p><p>如果只是单纯想要输入<code>#</code>怎么办？很简单，你只需要把<code>#</code>输入到反引号("`")之间即可,如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">`#`<br></code></pre></div></td></tr></table></figure><p>我使用暗主题，所以 GIF 才是黑色的， Typora内置几种主题都非常好看：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112211627694.png"alt="Github主题" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112211627315.png"alt="newprint主题" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112211628105.png"alt="我自己的主题" /></p><hr /><h2 id="加粗">加粗</h2><p>加粗很简单，文字左右各放一个<code>**</code>即可：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">**加粗**<br></code></pre></div></td></tr></table></figure><h3 id="效果如下">效果如下</h3><p><strong>加粗</strong></p><p>快捷键是 <code>ctrl+b</code>。</p><hr /><h2 id="斜体"><em>斜体</em></h2><p>斜体和加粗很相似，只需文字左右各放一个<code>*</code>即可：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">*斜体*<br></code></pre></div></td></tr></table></figure><h3 id="效果如下-1">效果如下</h3><p><em>斜体</em></p><p>快捷键是<code>ctrl+i</code>(斜体是italic)，所以快捷键是<code>i</code>)</p><h3 id="动图演示-1">动图演示</h3><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112211643630.gif"alt="斜体演示" /></p><hr /><p><em>斜体</em> <strong>加粗</strong>叠加使用即可:</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Markdown"><span class="hljs-strong">**<span class="hljs-emphasis">*斜体加粗*</span>**</span><br></code></pre></div></td></tr></table></figure><p>快捷键也叠加：<code>ctrl+i+b</code></p><hr /><h2 id="删除线"><del>删除线</del></h2><p>删除线，把文字左右各放一个<code>~~</code>即可。如下:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">~~删除线~~<br></code></pre></div></td></tr></table></figure><h3 id="效果">效果</h3><p><del>删除线</del></p><p>快捷键比较奇葩：<code>atl+shift+5</code></p><h3 id="动图演示-2">动图演示</h3><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112212038552.gif"alt="删除线演示" /></p><hr /><h2 id="下划线"><u>下划线</u></h2><p>下划线建议使用快捷键<code>ctrl+u</code>，因为下划线 MD 不支持，但是Typora 有这个快捷键，使用 HTML渲染。当然，你也可以使用这个标签<code>&lt;u&gt;&lt;/u&gt;</code>手动输入。</p><hr /><h2 id="超链接">超链接</h2><p>超链接使用这样的语法:</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Markdown">[<span class="hljs-string">文字</span>](<span class="hljs-link">链接</span>)<br></code></pre></div></td></tr></table></figure><p>方框中是你的文字，括号里边是你的链接。快捷键是<code>ctrl+k</code></p><h3 id="动图演示-3">动图演示</h3><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112211655668.gif"alt="添加链接" /></p><hr /><h2 id="添加图片">添加图片</h2><p>对的没错！ MD虽然是纯文本文件，但是人家可以添加图片！方法类似添加链接：</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Markdown">添加图片<br>![<span class="hljs-string">图注</span>](<span class="hljs-link">图片链接/地址</span>)<br></code></pre></div></td></tr></table></figure><p>就是在添加链接的前面添加一个感叹号而已。快捷键是<code>ctrl+shift+i</code></p><p>效果就不用展示了，我的文章就是 MD写的，里边的图片自然就是这样添加的。手打地址或者链接肯定麻烦，所以Typora 可以直接拖拽添加，配合图床使用简直不要太舒服！！</p><h3 id="动图演示-4">动图演示</h3><p>找张温馨一点的图：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112211711892.gif"alt="直接拖拽" /></p><p>这个方式还可以添加 GIF、视频等。</p><hr /><h2 id="分割线">分割线</h2><p>分割线就跟简单了，就像上面这条分割线就是 MD的标记，单个短杆<code>-</code>：</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Markdown">---<br></code></pre></div></td></tr></table></figure><h3 id="动图演示-5">动图演示</h3><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112211724390.gif"alt="分割线" /></p><hr /><h2 id="列表">列表</h2><p>列表很好玩，也很简单。</p><h3 id="无序列表">无序列表</h3><p>无序列表使用<code>-</code>加上一个空格，如下:</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Markdown"><span class="hljs-bullet">-</span> 第一个<br><span class="hljs-bullet">-</span> 二级无序列表<br><span class="hljs-bullet">-</span> 第二个<br><span class="hljs-bullet">-</span> 第三个<br></code></pre></div></td></tr></table></figure><h4 id="效果如下-2">效果如下</h4><p>无序列表</p><ul><li>第一个<ul><li>二级无序列表</li></ul></li><li>第二个</li><li>第三个</li></ul><p>快捷键: <code>ctrl+shift+]</code>。</p><h3 id="有序列表">有序列表</h3><p>有序列表只需要使用阿拉伯数字加上一个小点(dot)和一个空格:</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Markdown"><span class="hljs-bullet">1.</span> 一级列表<br><span class="hljs-bullet">1.</span> 二级列表<br><span class="hljs-bullet">2.</span> 一级列表<br><span class="hljs-bullet">3.</span> 一级列表<br></code></pre></div></td></tr></table></figure><h4 id="效果如下-3">效果如下</h4><p>有序列表</p><ol type="1"><li>一级列表<ol type="1"><li>一级列表</li></ol></li><li>一级列表</li><li>一级列表</li></ol><p>快捷键：<code>ctrl+shift+[</code>。</p><h3 id="动图演示-6">动图演示</h3><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112211734121.gif"alt="列表演示" /></p><h2 id="任务列表">任务列表</h2><p>任务列表很简单，就是<code>-空格[空格]空格文字</code>表示 未完成，<code>-空格[x]空格文字</code>表示 完成 。</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Markdown">未完成<br><span class="hljs-bullet">-</span> [] 明天好好复习<br><br>完成<br><span class="hljs-bullet">-</span> [x] 待会好好吃饭<br></code></pre></div></td></tr></table></figure><h3 id="效果如下-4">效果如下</h3><ul class="task-list"><li><input type="checkbox" disabled="" />明天好好复习</li><li><input type="checkbox" disabled="" checked="" />待会好好吃饭</li></ul><h3 id="动图演示-7">动图演示</h3><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112220919301.gif"alt="任务列表" /></p><p>可以看到， Typora是有交互功能的，任务列表可以点击，就像表格一样。</p><hr /><h2 id="引用">引用</h2><p>当你想引用别人的一句名言时，就可使用引用了。引用的格式也比较简单：一个尖括号加空格，然后就是名言——<code>&gt; 名言</code></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">&gt; 子曰：君子不器。<br></code></pre></div></td></tr></table></figure><h3 id="效果如下-5">效果如下</h3><blockquote><p>子曰：君子不器。</p></blockquote><p>快捷键：要个啥快捷键？？</p><h3 id="动图演示-8">动图演示</h3><h3 id="引用演示"><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112212044977.gif"alt="引用演示" /></h3><hr /><h2 id="表格">表格</h2><p>表格比较重要了。 MD 标准的没有表格，但是拓展的 MD是有的。格式比较神奇：</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Markdown">|姓名|身份|排行|<br>|:---|:---:|---:|<br>|左对齐|中间对齐|右对齐|<br>|刘备|皇叔|老大|<br>|关羽|商户|老二|<br>|张飞|屠户|老三|<br></code></pre></div></td></tr></table></figure><p><code>|---|---|---|</code>以上是表头 ，以下是表身，冒号<code>:</code>表示对齐方式(下面没有展示出来，下面都是居中对齐)。</p><h3 id="效果如下-6">效果如下</h3><table><thead><tr class="header"><th style="text-align: center;">姓名</th><th style="text-align: center;">身份</th><th style="text-align: center;">排行</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">刘备</td><td style="text-align: center;">皇叔</td><td style="text-align: center;">老大</td></tr><tr class="even"><td style="text-align: center;">关羽</td><td style="text-align: center;">商户</td><td style="text-align: center;">老二</td></tr><tr class="odd"><td style="text-align: center;">张飞</td><td style="text-align: center;">屠户</td><td style="text-align: center;">老三</td></tr></tbody></table><p>快捷键是<code>ctrl+t</code>。谁都不会亲手去打这个表格，所以直接使用快捷键。</p><h3 id="动图演示-9">动图演示</h3><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112212057001.gif"alt="表格演示" /></p><p>Typora 里边处理表格很舒服，此外还可以通过自定义的 CSS改变表格格式：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112212059948.gif"alt="不同主题中的表格" /></p><h2 id="注脚">注脚</h2><p>格式是<code>[^ 数字]</code>。</p><figure class="highlight lua"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lua">鲁迅说：我没说过[^<span class="hljs-number">4</span>]。<br><br><br><span class="hljs-comment">---------------</span><br>假设这里是篇末<br><span class="hljs-comment">---------------</span><br>[^<span class="hljs-number">4</span>]: 《狂人日记》，p250.<br></code></pre></div></td></tr></table></figure><h3 id="效果如下-7">效果如下</h3><p>鲁迅说：我没说过<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="《狂人日记》，p250.">[4]</span></a></sup>。</p><h3 id="动图演示-10">动图演示</h3><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112212108251.gif"alt="庄子曰" /></p><hr /><p>我知道大家觉得这个很无聊，毕竟码字谁都会，但是我下面介绍的东西，理科生和文科生就该提起精神了，因为这会挑战你们做笔记的速度。</p><h2 id="画图文科生">画图——文科生</h2><p>首先声明， MD 不支持绘图，但是现在我们使用的是 Typora ，它集成了 MD里绘图的语言： Mermaid 。是的，美人鱼。在 MD里使用某种(编程)语言的时候，都要放到一对```里边，如下：</p><p>使用python ```python import nothing</p><p>print(nothing) ```</p><p>使用C++ ```cpp #include &lt;iostream&gt;</p><p>int main(int argc, char const* argv[]){ return 0; } ```</p><p>使用lua ```lua local cos = math.cos local print = print _ENV = nil```</p><p>所以使用 Mermaid 的时候，也需要这样使用</p><p>```mermaid</p><p>```</p><p>可以使用快捷键 <code>ctrl+shift+k</code> 快速插入代码。</p><h3 id="动图演示-11">动图演示</h3><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112212125411.gif"alt="使用编程语言" /></p><hr /><p>Mermaid 支持的绘图格式很多，包括时序图 、甘特图、饼图和流程图等。下面主要讲解饼图 、时序图和流程图 。</p><h3 id="饼图">饼图</h3><p>我们使用 Mermaid 画图，所以先进入 Mermaid :</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112212129599.png"alt="写代码的地方" /></p><p>如果我们要画 饼图 ，我们需要在首行标注饼图（刚考过六级，饼图怎么说？cookie chart ? 非也： pie ）。</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">pie<br><span class="hljs-code">title 为什么总是宅在宿舍？</span><br><span class="hljs-code">&quot;没有npy&quot;: 30</span><br><span class="hljs-code">&quot;太冷了&quot;: 12</span><br><span class="hljs-code">&quot;遭被子残忍封印&quot;: 5</span><br><span class="hljs-code">&quot;穷&quot;: 500</span><br></code></pre></div></td></tr></table></figure><h4 id="效果如下-8">效果如下：</h4><pre><code class=" mermaid">pietitle 为什么总是宅在宿舍？&quot;没有npy&quot;: 30&quot;太冷了&quot;: 18&quot;遭被子残忍封印&quot;: 12&quot;穷&quot;: 500</code></pre><h4 id="动图演示-12">动图演示</h4><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112212212114.gif"alt="饼图演示" /></p><h3 id="流程图">流程图</h3><p>流程图的画法主要有两种: Mermaid 中的 Graph 和 Flowchart 。先介绍Graph 。</p><h4 id="graph">Graph</h4><p>主要是方向性。你的流程图如果从左( Left)到右( Right)，那就再首行写下<code>graph LR</code>(反之<code>graph RL</code>)，如果是上(Top)到下(Down)就是<code>graph TD</code>(反之 <code>graph BT</code>,bottom top)。使用两个短杆加小于号<code>–&gt;</code>表示方向。</p><p>方向：</p><ul><li><code>--&gt;</code>表示直线</li><li><code>-.-&gt;</code>表示虚线</li><li><code>--文字--&gt;</code>表示实线标签</li><li><code>-.文字.-&gt;</code>表示虚线标签</li></ul><p>方框:</p><ul><li>纯文字，默认<code>方框</code></li><li>id(文字)，<code>圆角</code>。所谓<code>id</code>就是给名字找一个方便记忆的id</li><li>id[()]，<code>圆柱</code></li><li>id([])，<code>椭圆</code></li><li>id{}，<code>菱形</code></li><li>等等</li></ul><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">graph TD<br><span class="hljs-code">夏明--&gt;大东</span><br><span class="hljs-code">夏明-.-&gt;大东</span><br><span class="hljs-code">夏明--标签--&gt;大东</span><br><span class="hljs-code">夏明-.标签.-&gt;大东</span><br></code></pre></div></td></tr></table></figure><h4 id="效果如下-9">效果如下</h4><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112212235419.png"alt="graph演示" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112212238193.png"alt="方框格式" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112212242594.png"alt="各种格式" /></p><p>因为是介绍，所以不会太深入了。</p><h4 id="flowchart">Flowchart</h4><p>Flowchart 和 Graph 差不多，但是更加丝滑：</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">flowchart TD<br><span class="hljs-code">%% subgraph 是子图</span><br><span class="hljs-code">subgraph Left</span><br><span class="hljs-code">男主--&gt;铃兰一中</span><br><span class="hljs-code">end</span><br><span class="hljs-code"></span><br><span class="hljs-code">subgraph Right</span><br><span class="hljs-code">女主--&gt;快乐星球</span><br><span class="hljs-code">end</span><br><span class="hljs-code">   </span><br><span class="hljs-code">女主 --x 铃兰一中</span><br><span class="hljs-code">男主 --x 快乐星球</span><br><span class="hljs-code"></span><br><span class="hljs-code">Left--&gt;南开大学</span><br><span class="hljs-code">Right--&gt;南开大学</span><br></code></pre></div></td></tr></table></figure><h4 id="效果如下-10">效果如下</h4><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112212245690.png"alt="flowchart" /></p><h4 id="插个时序图">插个时序图</h4><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">sequenceDiagram<br><span class="hljs-code">participant Alice</span><br><span class="hljs-code">participant Bob</span><br><span class="hljs-code">participant Hohn</span><br><span class="hljs-code">Alice-&gt;&gt;Hohn: Hello Hohn, how are you ?</span><br><span class="hljs-code">loop HealthCheck</span><br><span class="hljs-code">Hohn-&gt;&gt;Hohn: Fight against hypochondria</span><br><span class="hljs-code">    end</span><br><span class="hljs-code">    Note right of Hohn: Rational thoughts &lt;br/&gt;prevail</span><br><span class="hljs-code">    Hohn--&gt;&gt;Alice:Greate!</span><br><span class="hljs-code">    Hohn-&gt;&gt;Bob: How about you?</span><br><span class="hljs-code">    Bob--&gt;&gt;Hohn: Jolly good</span><br></code></pre></div></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112221044616.png"alt="时序图" /></p><h2 id="公式理科生">公式——理科生</h2><p>写数学公式是物理数学同学不可避免地悲剧，使用 Word记录的话直接就是死亡，所以很多人使用手写(电子笔记)。但是我想说， MD可以救你。</p><p>公式使用 <span class="math inline">\(L_EX\)</span>渲染，所以还是很好玩地。行内公式左右各一个 <code>$</code>，独立公式则用两个 <code>$$</code> 。如下：</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Markdown">$$ <br>\sum^&#123;x \to \infty&#125;<span class="hljs-emphasis">_&#123;y \to 0&#125;&#123;\frac&#123;x&#125;&#123;y&#125;&#125; </span><br><span class="hljs-emphasis">$$</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">$ \alpha $</span><br></code></pre></div></td></tr></table></figure><h4 id="效果如下-11">效果如下</h4><p><span class="math display">\[\sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}\]</span></p><p>$ $</p><p>不过我使用的不多，大家要是感兴趣地话可以去查查，随便百度就可以找到很多教程的。我这里浅尝辄止。</p><h2 id="上下标和高亮">上下标和高亮</h2><p>上下标和高亮是 Typora 支持的，其他编辑器未必支持。</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">上标 X^2^<br>下标 O~2~<br>高亮 ==中国==<br></code></pre></div></td></tr></table></figure><h3 id="效果如下-12">效果如下</h3><p>上标 <span class="math inline">\(X^2\)</span></p><p>下标 <span class="math inline">\(O_2\)</span></p><p>高亮 <mark>中国</mark></p><p>需要在 Typora 中打开：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112212301341.png"alt="拓展语法" /></p><hr /><h1 id="markdown回顾">Markdown回顾</h1><h2 id="定义">定义</h2><p>Markdown是一门轻量级的标记语言，可以通过几个简单的标记让你的文章具有一定的格式。Markdown写出来的文章和笔记本质上只是纯文本，通过笔记软件或者一些网站渲染，可以展现不同的效果，可以让你专心于写作而不担心排版问题。</p><h2 id="渲染">渲染</h2><p>网络平台或者软件、网址进行渲染。</p><p>目前大多数的笔记平台(有道等)、博客平台(知乎、博客园等)、思维导图(Xmind、百度脑图等)都支持Markdown ，除了被诟病的 wx 公众号。公众号不支持 Markdown，但是仍然有很多人开发了很多地接入公众号的工具，基本都是网页工具，可以实现软件写完之后复制到公众号即可——例如我就是这样，本地写完，导出HTML 文件，复制到公众号即可。</p><h2 id="语法和typora快捷键">语法和Typora快捷键</h2><ol type="1"><li><p>标题</p><p>使用井号<code>#空格标题</code>，几个井号就是几级标题。快捷键:<code>ctrl+数字(0-6)</code>。</p><p>例如：<code># 一级标题</code>、<code>## 二级标题</code></p></li><li><p>加粗</p><p>文字左右各放一个<code>**</code>。快捷键是<code>ctrl+b</code>。</p><p>例如：<code>**我是249+1**</code></p></li><li><p>斜体</p><p>文字左右各放一个<code>*</code>。快捷键<code>ctrl+i</code>。</p><p>例如：<code>*学名需要斜体，因为人家是拉丁文*</code></p></li><li><p>删除线</p><p>文字左右各放一个<code>~~</code>。快捷键是<code>alt+shift+5</code>。</p><p>例如：<code>~~我是大聪明~~</code></p></li><li><p>下划线</p><p>文字放到<code>&lt;u&gt;&lt;/u&gt;</code>标签里边。快捷键<code>ctrl+u</code>。</p><p>例如：<code>&lt;u&gt;这道题要考&lt;/u&gt;</code></p></li><li><p>超链接和图片</p><p>方括号<code>[]</code>里边放文字或者图注，紧接着括号<code>()</code>里边放网址或者图片地址。快捷键：超链接<code>ctrl+k</code>;图片<code>ctrl+shift+i</code>。实在懒，直接拖拽。</p><p>例如：<code>[7k7k](www.7k7k.com)</code>、<code>[图片](D:/user/pictures/atl.jpg)</code></p></li><li><p>分割线</p><p>三个短杆<code>-</code>即可，没有快捷键。</p><p>例如: <code>---</code></p></li><li><p>列表</p><p>有序列表使用阿拉伯数字加点(dot)加空格(space)加文字。快捷键<code>ctrl+shift+[</code></p><p>无序列表使用短杆<code>-</code>加空格(space)加文字。快捷键<code>ctrl+shift+]</code></p><p>例如：<code>1. 第一项</code>、<code>- 列举</code></p></li><li><p>任务列表</p><p>已完成使用短杆<code>-</code>加空格(space)加方括号包围的x<code>[x]</code>加空格(space)加文字。</p><p>未完成使用短杆<code>-</code>加空格(space)加方括号包围的空格(space)<code>[ ]</code>加空格加文字。</p><p>例如：<code>- [ ] 未完成</code>、<code>- [x] 完成了</code></p></li><li><p>引用</p><p>使用右尖括号<code>&gt;</code>加空格(space)加文字。</p><p>例如：<code>&gt; 子曰: 吾知子知吾不知子知吾知。</code></p></li><li><p>表格</p><p>短杆和竖杠排列，这个，建议直接使用快捷键<code>ctrl+t</code>。</p></li><li><p>注脚</p><p>方括号<code>[]</code>里边放<code>^</code>和数字。</p><p>例如：</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.typora.io">[1]</span></a></sup><br></code></pre></div></td></tr></table></figure></li><li><p>画图和公式</p><p>画图放到代码编辑块里边。快捷键：<code>ctrl+shift+k</code>，选择<code>mermaid</code>。</p><p>公式左右各放一个 <code>$</code> 或者 <code>$$</code>，前者是行内公式，后者是块公式。</p><p>例如： <figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ x^2 $<br>    <br>$$ <br><span class="hljs-built_in">sum</span>^&#123;x \to 100&#125;_&#123;x=0&#125; <br>$$<br></code></pre></div></td></tr></table></figure></p></li><li><p>上下标和高亮</p><p>这是 Typora的拓展，上边使用<code>^</code>包围，下标使用<code>~</code>包围，高亮使用<code>==</code>包围。</p><p>例如：<code>X^2^</code>、<code>O~2~</code>、<code>==收到==</code></p></li></ol><hr /><h1 id="typora">Typora</h1><p>Typora<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="https://www.typora.io">[1]</span></a></sup>官网可以下载 Beta 版，免费使用。作为一款优秀的Markdown 笔记软件，无可挑剔，但是需要配合 Pandoc (导出任何格式，导出 PDF需配合 <span class="math inline">\(L_EX\)</span> )使用。建议先安装Pandoc 再安装 Typora 。</p><p>Typora包含几个主题，有需要的也可以上网查找相关主题，甚至自己设置自己的主题——它支持CSS 格式，只要自己会写就行。</p><h2 id="安装">安装</h2><p>简单安装即可，确认到底。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112221005761.gif"alt="安装Typora" /></p><h2 id="pandoc">Pandoc</h2><p>Pandoc<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="https://pandoc.org">[2]</span></a></sup> 官网下载。如果电脑上不去，可以使用手机。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112221009185.png"alt="pandoc官网" /></p><h2 id="设置-pandoc-路径">设置 Pandoc 路径</h2><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112221012699.png"alt="设置路径" /></p><h2 id="如果需要导出成pdf">如果需要导出成PDF</h2><p>如果要导出成 PDF ，建议安装<spanclass="math inline">\(MiKT_EX\)</span><sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="https://miktex.org">[3]</span></a></sup>。安装有任何问题可以上网查找问题。</p><hr /><h1 id="导出效果">导出效果</h1><p>下面可以看看我的导出结果。因为我的这篇文章也是使用 Typora写的，所以恰好可以看看。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112221019439.png"alt="暗夜模式" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112221020894.png"alt="推送主题" /></p><h2 id="导出-pdf">导出 PDF</h2><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112221021120.png"alt="导出" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112221021774.png"alt="pdf效果" /></p><h2 id="导出-word-文档">导出 Word 文档</h2><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112221023441.png"alt="导出word" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112221024813.png"alt="导出效果" /></p><h2 id="导出到公众号">导出到公众号</h2><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112221024245.png"alt="公众号是html格式复制" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112221026210.png"alt="浏览器预览" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112221027377.png"alt="复制到公众号" /></p><p>至于 MD 效果如何，想必大家看完我的文章就知道了。</p><h1 id="相关网址">相关网址</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>https://www.typora.io<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>https://pandoc.org<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>https://miktex.org<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>《狂人日记》，p250.<a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
