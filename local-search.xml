<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Shell 脚本加 cURL, 再见 PicGo</title>
    <link href="/2022/06/27/Shell-%E8%84%9A%E6%9C%AC%E5%8A%A0-cURL,%E5%86%8D%E8%A7%81-PicGo/"/>
    <url>/2022/06/27/Shell-%E8%84%9A%E6%9C%AC%E5%8A%A0-cURL,%E5%86%8D%E8%A7%81-PicGo/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>谈谈最近的小事。</p><h2 id="Sway-平铺窗口管理"><a href="#Sway-平铺窗口管理" class="headerlink" title="Sway-平铺窗口管理"></a>Sway-平铺窗口管理</h2><p>GNOME 桌面 的极简主义让我很满意。为了让 GNOME 更符合自己的审美，我添加了七八个插件。正因此，最近多次重启电脑，因为这货居然会卡住没反应！考虑到GNOME 一直以内存泄漏出名，我打算试试平铺窗口管理（Tiling Window Manager）。</p><p>所谓”窗口平铺”，就是系统自动将打开的各种窗口排好，而不是一般系统的叠加（正确来说叫做”浮动（Floating）”）。</p><p>Linux 上平铺窗口管理最著名的就是 <a href="https://i3wm.org/" title="i3wm">i3wm</a>，我选择 <a href="https://swaywm.org/" title="Sway">Sway</a>，适用于 <a href="https://wayland.freedesktop.org/" title="Wayland">Wayland</a> 的 i3。<a href="https://manjaro.org/" title="Manjaro Linux">Manjaro Linux</a> 社区有在维护 Sway 版，可惜我最开始的时候并没有选择 Sway。</p><p><img src="http://101.200.84.36/images/2022/06/27/202206271741491.png" alt="官网截的图，因为我的 Sway 已经被我卸了。" title="官网截的图，因为我的 Sway 已经被我卸了。"></p><p>平铺有利于桌面空间的利用，全快捷键操作也可以让人脱离键盘，看起来极富极客（Geek）风格，也就是装～。其实 Windows 系统也有平铺的功能，以前都是快捷键，Windows11 之后直接在最大化按钮加上平铺。</p><p>安装 Sway 主要借助的是 <a href="https://wiki.archlinux.org/" title="Arch Linux Wiki">Arch Linux Wiki</a>。没办法，这家伙的文档贼丰富。Sway 的配置太难受了，包括 i3，由于不希望安装太多第三方软件，我真的是从头到脚写了各种脚本，真的要吐。折腾到后面，感觉虽然有成就感，但是自己不愿折腾了，回到了 GNOME。继续使用我的 GNOME 拓展 <a href="https://extensions.gnome.org/extension/28/gtile/" title="gTile">gTile</a>。</p><h2 id="GitHub-Copilot"><a href="#GitHub-Copilot" class="headerlink" title="GitHub-Copilot"></a>GitHub-Copilot</h2><p><a href="https://github.blog/2022-06-21-github-copilot-is-generally-available-to-all-developers/" title="GitHub Copilot 消息来源">GitHub Copilot</a> 是一个可以根据注释生成代码的人工智能。Copilot，顾名思义，当你的副手。GitHub 对外开放不代表免费，实际上价格极其感人。好消息是，对于开源项目维护者和学生、老师来说，这东东是免费的。当然，前提是你得完成学生认证。GitHub 的<a href="https://education.github.com/" title="学生认证">学生认证</a>其实好处多多（认证的邮箱建议使用学校邮箱），可以拿到各种优惠包。由于自己用不上，所以还没有进行认证。白嫖只是白白占有资源，何必呢。</p><p>GitHub Copilot 支持 Visual Studio、Visual Studio Code 和 NeoVIM。如果感兴趣，也可以到<a href="https://github.com/features/copilot/" title="GitHub Copilot">官网</a>瞄瞄这家伙如何工作。当然，如果进行学生认证的话还可以免费使用。</p><p><img src="http://101.200.84.36/images/2022/06/27/202206271808381.png" alt="GitHub Copilot" title="GitHub Copilot"></p><h2 id="PicGo"><a href="#PicGo" class="headerlink" title="PicGo"></a>PicGo</h2><p><a href="https://www.picgo.net/" title="PicGO">PicGo</a> 才是今天的主角，准确说是即将退场的主角。PicGo 是一款集成各类图床的上传工具，可以通过 图床API（Application Programming Interface，应用编程接口）轻松实现图片的上传。具体就不介绍了。</p><p>是这样的，Linux 系统 PicGo 的 AppImage 包高达 100M。不得不说，对于有洁癖的人来说，是可忍孰不可忍？自己使用的图床主要包括 <a href="https://chevereto-free.github.io/" title="Chevereto">Chevereto</a>、<a href="https://github.com/" title="GitHub">GitHub</a> 和 <a href="https://sm.ms/" title="SM.MS">SM.MS</a>，主要是前两者，后者只是以前用的。自己用不上 PicGo 的多功能，而且 PicGo 还那么臃肿，由此萌发了使用脚本自己写一个上传工具的念头。</p><p>说到脚本，很多人想到的自然是 Python，不过很可惜，Python 在我眼中就是臃肿的另一个代表，虽然自己的系统就有Python。依赖越少的工具，越深得我的心，所以像 Python 这类脚本语言基本可以散了，实际上 Lua 可以考虑。Linux 系统离不开 Shell，所以后面决定用 Shell&#x2F;Bash。</p><h1 id="替代-PicGo"><a href="#替代-PicGo" class="headerlink" title="替代 PicGo"></a>替代 PicGo</h1><p>写一个替代 PicGo 的脚本其实还是很简单的。Windows 系统没必要看，因为 Windows 系统的生态确实太好了，没必要折腾。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>简单介绍用到的东东：</p><ol><li>Linux GNOME 桌面环境。指定 GNOME 系统是为了使用 GNOME 的全局自定义快捷键。因为我需要减少依赖，不可能为了设置全局快捷键下载一个软件或者程序。</li><li>Xclip，Linux X桌面协议系统（Xorg）的剪贴板程序。Linux 不是 X协议 就是 Wayland协议。由于 Wayland协议 现在生态不咋地，为了兼容 Xorg 生出了 XWayland 这个缝合怪（对的，就是两者的结合），因此直接使用Xclip 就行，没必要用 wl-clipboard，徒增兼容问题。这是 Linux 标配。</li><li>Bash&#x2F;Shell，最普遍的 Shell 环境，Linux 标配。</li><li>SED，Stream Editor，流式编辑器，Linux 标配。</li><li><a href="https://curl.se/" title="cURL">cURL</a>，非常强大的命令行文件传输工具，Linux 标配。</li><li>notify-send，命令行或者脚本下的通知工具，非常简单。不清楚是不是有桌面的 Linux 都会带着，但是一般确实如此。</li><li>JQ，命令行环境处理 JSON 格式文件的利器，见鬼，以前自己不愿安装，纯手工解析 JSON,后面学乖了，好好使用 JQ 吧。一般需要安装，一般使用命令行的都会安装。</li><li>GitHub 帐号，可选，用于保存图片，也就是做图床。</li><li>SM.MS 帐号，可选，做图床。</li></ol><p>上面的工具基本都是一个正常的 Linux 系统自带的，除了 JQ 可能没有。还有，那两个帐号可不自带。</p><h2 id="搭建框架"><a href="#搭建框架" class="headerlink" title="搭建框架"></a>搭建框架</h2><p>找一个放脚本的目录，例如我喜欢把自己的脚本放到 <code>$HOME/.scripts</code> 目录下，创建一个 Shell 脚本。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Bash">$ <span class="hljs-built_in">cd</span> ~/.scripts <span class="hljs-comment"># 进入脚本目录</span><br>$ <span class="hljs-built_in">pwd</span> <span class="hljs-comment"># 输出当前目录</span><br>/home/chunshuyumao/.scripts<br>$ vim upload.sh<br><br><span class="hljs-comment"># 以下为脚本内容</span><br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-built_in">set</span> -euo pipefail<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">main</span></span>() &#123;<br><br>&#125;<br><br>main <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span><br></code></pre></div></td></tr></table></figure><p>创建脚本之后先写一个主函数(main)，让我们的脚本看起来更加清晰。这些内容之前的博客都出现过了，这就不解释了。</p><p>我们使用的是 GNOME 桌面系统自带的截图工具。GNOME42 之后，这个工具的快捷键是 <code>prt</code>，也就是键盘上的打印键。默认截图之后会保留在剪贴板，接下来我们需要从剪贴板获得图片。</p><p>不过想想，获取的图片保存到哪里？由于我们把图片上传到图床，本地保留一份看起来没必要，所以建议创建一个临时文件，上传之后删掉。我就是这么做的。实际上 PicGo 也是这样做的（之前，现在有内置方法）。从剪贴板获取图片使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Bash">xclip -sel clip -t image/png -o &gt; image.png<br></code></pre></div></td></tr></table></figure><p>当然，你要是乐意，可以写全参数：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Bash">xclip -selection clipboard -target image/png -out &gt; image.png<br></code></pre></div></td></tr></table></figure><p>懒人就不会选择长命令。长命令形式一目了然，我们从（selection）剪贴板（clipboard）获取目标图片PNG格式（target image&#x2F;png），输出（out &gt;）到 <code>image.png</code>。好家伙，完全不用解释哦！</p><p>这样在脚本所在目录就会出现一个 <code>image.png</code> 文件。</p><p><img src="http://101.200.84.36/images/2022/06/27/202206272005261.png" alt="从剪贴板获取图片" title="从剪贴板获取图片"></p><p>可是这样不优雅，图片直接在脚本所在的地方生成非常恶心。好在我们可以做得更好！一个优雅的方式是，创建一个临时目录，把所有的临时文件放到这个目录中，等到任务完成之后再删去目录。好巧不巧，刚刚好有一个这样的命令符合我们的预期，它就是 <code>mktemp</code>。通过查阅使用手册，我们可以知道，<code>mktemp</code> 可以这样创建临时文件夹：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Bash">$ <span class="hljs-built_in">mktemp</span> -d -t temp.XXXXXXXXXX<br>/tmp/tmp.e7Y2FzNj5Q<br></code></pre></div></td></tr></table></figure><p><code>-d</code> 表示生成临时文件夹，不加的话会生成临时文件。<code>-t</code> 表示在临时文件夹（&#x2F;tmp）下生成。 <code>temp.XXXXXXXXXX</code> 是生成的文件夹名，其中 <code>temp.</code> 是随便取的，这是我自己选的；<code>XXXXXXXXXX</code> 代表生成多少个随机的字符，你要乐意，写一万个也行。<code>mktemp</code> 生成临时文件夹之后会返回文件夹的路径。</p><p>为了让自己的脚本更加健壮，我们需要确认 <code>mktemp</code> 确实成功创建了文件夹，否则（||）直接退出（exit）。除此之外通过 <code>date</code> 创建图片的名字，然后和临时文件夹整合到一起作为图片的路径。因此我们的脚本现在变成了这样：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">set</span> -euo pipefail<br><br><span class="hljs-comment"># 按时间给图片命名，依次是 年 月 日 时 分 秒 星期</span><br><span class="hljs-comment"># [Y]ear [m]onth [d]ay [H]our [M]inute [S]econd  u --&gt; 鬼知道这是什么的缩写</span><br><span class="hljs-built_in">declare</span> -r image_name=<span class="hljs-string">&quot;<span class="hljs-subst">$(date +%Y%m%d%H%M%S%u)</span>.png&quot;</span><br><span class="hljs-comment"># 如果创建临时文件夹失败，就使用 exit 1 退出</span><br><span class="hljs-built_in">declare</span> -r tmpdir=<span class="hljs-string">&quot;<span class="hljs-subst">$(mktemp -d -t temp.XXXXXXXXXX)</span>&quot;</span> || <span class="hljs-built_in">exit</span> 1<br><span class="hljs-built_in">declare</span> -r path2image=<span class="hljs-string">&quot;<span class="hljs-variable">$tmpdir</span>/<span class="hljs-variable">$image_name</span>&quot;</span><br><span class="hljs-comment"># 通知持续时间为 3 秒</span><br><span class="hljs-built_in">declare</span> -r expire=3000<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">main</span></span>() &#123;<br><br>  <span class="hljs-comment"># Notifies when there is not image in clipboard, and exits.</span><br>  xclip -sel clip -t image/png -o &gt; <span class="hljs-string">&quot;<span class="hljs-variable">$path2image</span>&quot;</span> || &#123;<br>    notify-send -t <span class="hljs-variable">$expire</span> -i <span class="hljs-string">&#x27;dialog-warning&#x27;</span> <span class="hljs-string">&#x27;WARNING&#x27;</span> <span class="hljs-string">&quot;There is not image exiting in clipboard.&quot;</span><br>    <span class="hljs-built_in">exit</span> 1<br>  &#125;<br>&#125;<br><br>main <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span><br></code></pre></div></td></tr></table></figure><p><code>||</code>表示前面的命令失败的话就执行后面的命令。其实这些在之前的文章都有讲到。<code>notify-send</code> 用于弹出通知，大概这样使用：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Bash"><span class="hljs-comment">#             通知几秒后关闭？          图标是啥？              标题      内容</span><br>$ notify-send --expire-time milliseconds --icon <span class="hljs-string">&#x27;dialog-icon&#x27;</span> <span class="hljs-string">&#x27;Caption&#x27;</span> <span class="hljs-string">&#x27;Details&#x27;</span><br></code></pre></div></td></tr></table></figure><p>脚本中的意思是：从（selection）剪贴板（clipboard）获取（target）PNG格式的图片（image&#x2F;png），并输出（out &gt;）到 <code>path2image</code> 中。如果获取失败（||），以警告图标（icon dialog-warning）发送标题为”WARNING”，内容为”巴拉巴拉”的通知（notify-send），通知时间持续 3 秒。</p><p>上传到 SM.MS 还是 GitHub 是不同的选择，所以待会写两个函数，一个传到 SM.MS，一个传到 GitHub。我们希望调用函数之后，函数返回上传成功后图片的地址，也就是：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Bash"><span class="hljs-built_in">local</span> image_url=<span class="hljs-string">&quot;<span class="hljs-subst">$(upload2github)</span>&quot;</span><br></code></pre></div></td></tr></table></figure><p>获得的地址以 Markdown 格式传到剪贴板，这样就可以直接粘贴了，也就是</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;![](<span class="hljs-variable">$&#123;image_url&#125;</span>)&quot;</span> | xclip -sel clip<br></code></pre></div></td></tr></table></figure><p>最后再发送(notify-send)一个通知(dialog-information)，说明（details）成功（caption）了：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Bash">notify-send -t <span class="hljs-variable">$expire</span> -i <span class="hljs-string">&#x27;dialog-information&#x27;</span> <span class="hljs-string">&#x27;SUCCESS&#x27;</span> <span class="hljs-string">&#x27;$&#123;image_url&#125;&#x27;</span><br></code></pre></div></td></tr></table></figure><p>处理完之后，别忘了删除我们的临时文件夹，写一个 clean 函数，在 main 函数里面显式调用，或者当捕捉(trap)到退出(EXIT)信号时被动调用。现在来看看我们的脚本：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">set</span> -euo pipefail<br><br><span class="hljs-built_in">trap</span> clean EXIT<br><br><span class="hljs-comment"># 按时间给图片命名，依次是 年 月 日 时 分 秒 星期</span><br><span class="hljs-comment"># [Y]ear [m]onth [d]ay [H]our [M]inute [S]econd  u --&gt; 鬼知道这是什么的缩写</span><br><span class="hljs-built_in">declare</span> -r image_name=<span class="hljs-string">&quot;<span class="hljs-subst">$(date +%Y%m%d%H%M%S%u)</span>.png&quot;</span><br><span class="hljs-built_in">declare</span> -r tmpdir=<span class="hljs-string">&quot;<span class="hljs-subst">$(mktemp -d -t temp.XXXXXXXXXX)</span>&quot;</span> || <span class="hljs-built_in">exit</span> 1<br><span class="hljs-built_in">declare</span> -r path2image=<span class="hljs-string">&quot;<span class="hljs-variable">$tmpdir</span>/<span class="hljs-variable">$image_name</span>&quot;</span><br><span class="hljs-comment"># 通知持续时间为 3 秒</span><br><span class="hljs-built_in">declare</span> -r expire=3000<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">clean</span></span>() &#123;<br>  /bin/rm -rf <span class="hljs-variable">$tempdir</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">main</span></span>() &#123;<br><br>  <span class="hljs-comment"># Notifies when there is not image in clipboard, and exits.</span><br>  xclip -sel clip -t image/png -o &gt; <span class="hljs-string">&quot;<span class="hljs-variable">$path2image</span>&quot;</span> || &#123;<br>    notify-send -t <span class="hljs-variable">$expire</span> -i <span class="hljs-string">&#x27;dialog-warning&#x27;</span> <span class="hljs-string">&#x27;WARNING&#x27;</span> <span class="hljs-string">&quot;There is not image exiting in clipboard.&quot;</span><br>    <span class="hljs-built_in">exit</span> 1<br>  &#125;<br>  <br>  <span class="hljs-comment"># 默认上传到 GitHub</span><br>  <span class="hljs-built_in">local</span> image_url=<span class="hljs-string">&quot;<span class="hljs-subst">$(upload2github)</span>&quot;</span><br>  <span class="hljs-comment"># 复制到剪贴板</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;![](<span class="hljs-variable">$&#123;image_url&#125;</span>)&quot;</span> | xclip -sel clip<br>  notify-send -t <span class="hljs-variable">$expire</span> -i <span class="hljs-string">&#x27;dialog-information&#x27;</span> <span class="hljs-string">&#x27;SUCCESS&#x27;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;image_url&#125;</span>&quot;</span><br>  <br>  clean<br>&#125;<br><br>main <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span><br></code></pre></div></td></tr></table></figure><p>框架搭建完毕！后面如果有其他的图床，多写一个函数就完了。此外， PicGo 干的其实也不多就是这件事，只不过是人家是跨平台可视化的，而我写的这个仅限于 类Unix 系统。</p><h2 id="编写-upload2github-函数"><a href="#编写-upload2github-函数" class="headerlink" title="编写 upload2github 函数"></a>编写 upload2github 函数</h2><p>具体实现上传函数。为了普适性，我拿 GitHub 图床做一个例子。首先要准备几样东西</p><ol><li>图床仓库</li><li>私人令牌（Token）</li></ol><p>这里就不介绍如何申请 GitHub 仓库了，默认你建立了自己的仓库。这个仓库名一定要准确。例如我的仓库 <code>202203</code>：</p><p><img src="http://101.200.84.36/images/2022/06/27/202206272146001.png" alt="202203" title="202203"></p><p>有了这个我们可以写函数了：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Bash"><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">upload2github</span></span>() &#123;<br><br>  <span class="hljs-comment">#################设置####################</span><br>  <span class="hljs-built_in">local</span> repo=<span class="hljs-string">&#x27;202203&#x27;</span><br>  <span class="hljs-built_in">local</span> username=<span class="hljs-string">&#x27;chunshuyumao&#x27;</span><br>  <span class="hljs-built_in">local</span> token=<span class="hljs-string">&#x27;xxxxxxxxxxxxxxxxxxxxxx&#x27;</span><br>  <span class="hljs-comment">#################可选####################</span><br>  <span class="hljs-built_in">local</span> cdn=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/gh/<span class="hljs-variable">$username</span>/<span class="hljs-variable">$repo</span>@master&quot;</span><br>  <span class="hljs-comment">#################设置####################</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>私人令牌（token）需要到帐号设置里获取。CDN（Content Delivery Network，内容分发网络），用于加速 GitHub 图床的图片显示，毕竟国外的东西，访问难免慢，使用 CDN 加速就会快一点。除了设置网起来的配置，其他都不要动。</p><p>参考 <a href="https://docs.github.com/en/rest/repos/contents" title="GitHub API PUT">GitHub官方API使用说明</a> 上传图片。</p><p><img src="http://101.200.84.36/images/2022/06/27/202206272200431.png" alt="GitHub API" title="GitHub API"></p><p>语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Bash">curl \<br>  -X <span class="hljs-string">&#x27;PUT&#x27;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$github_url</span>&quot;</span> \<br>  -H <span class="hljs-string">&#x27;Accept: application/vnd.github.v3+json&#x27;</span> \<br>  -H <span class="hljs-string">&quot;Authorization: token <span class="hljs-variable">$token</span>&quot;</span> \<br>  -d <span class="hljs-string">&#x27;&#123; &quot;message&quot;: &quot;upload&quot;, &quot;content&quot;: &quot;&#x27;</span><span class="hljs-variable">$content</span><span class="hljs-string">&#x27;&quot; &#125;&#x27;</span><br></code></pre></div></td></tr></table></figure><p><code>-X</code> 表示请求的方式，这里使用 <code>PUT</code>。<code>-H</code> 用于构建请求的头部，也就是 <code>header</code>。<code>-d</code> 是上传的数据，即网络请求的 <code>data</code>。</p><p><code>$github_url</code> 是一个 API URL，如下：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Bash"><span class="hljs-built_in">local</span> github_url=<span class="hljs-string">&quot;https://api.github.com/repos/<span class="hljs-variable">$username</span>/<span class="hljs-variable">$repo</span>/contents/<span class="hljs-variable">$image_name</span>&quot;</span><br></code></pre></div></td></tr></table></figure><p><code>token</code> 我们已经见过了。<code>$content</code> 呢？官网说的很清楚，是一个通过<br><code>base64</code> 编码的字符串。这样获取：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Bash"><span class="hljs-built_in">local</span> content=<span class="hljs-string">&quot;<span class="hljs-subst">$(base64 -w 0 $path2image)</span>&quot;</span><br></code></pre></div></td></tr></table></figure><p><code>-w 0</code> 表示不用换行（no wrap）。习惯上，文本文件一行限制 70 个字符，这称为 <code>wrap</code>。无缘无故添加换行符，后面难以处理，所以我们设置不换行。</p><p>请求之后返回的结果是 JSON 格式，保存到一个变量，然后用 JQ 进行处理：</p><p><img src="http://101.200.84.36/images/2022/06/27/202206272209181.png"></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Bash"><span class="hljs-built_in">local</span> message=<span class="hljs-string">&quot;<span class="hljs-subst">$(curl \</span></span><br><span class="hljs-subst"><span class="hljs-string">  -X &#x27;PUT&#x27; <span class="hljs-string">&quot;<span class="hljs-variable">$github_url</span>&quot;</span> \</span></span><br><span class="hljs-subst"><span class="hljs-string">  -H &#x27;Accept: application/vnd.github.v3+json&#x27; \</span></span><br><span class="hljs-subst"><span class="hljs-string">  -H <span class="hljs-string">&quot;Authorization: token <span class="hljs-variable">$token</span>&quot;</span> \</span></span><br><span class="hljs-subst"><span class="hljs-string">  -d &#x27;&#123; <span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;upload&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;&#x27;<span class="hljs-variable">$content</span>&#x27;&quot;</span> &#125;&#x27; \</span></span><br><span class="hljs-subst"><span class="hljs-string">  2&gt; /dev/null | jq &#x27;commit..message?&#x27; sed -r &#x27;s/\&quot;(.*)</span>\&quot;/\1/g&#x27;)&quot;</span><br><br><span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$message</span>&quot;</span> != <span class="hljs-string">&quot;upload&quot;</span> ]]; <span class="hljs-keyword">then</span><br>  notify-send -t <span class="hljs-variable">$expire</span> -i <span class="hljs-string">&#x27;dialog-error&#x27;</span> <span class="hljs-string">&#x27;ERROR&#x27;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$message</span>&quot;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-built_in">exit</span> 1<br></code></pre></div></td></tr></table></figure><p>我们不需要使用返回的结果，只需要判断是否成功。文档说明，如果上传成功，返回的 message 是我们之前的 message 的内容，我们只需要判断两个 message 想不相同即可。如果不同，直接报错通知。</p><p><code>2&gt; /dev/null</code> 表示把错误输出到 <code>/dev/null</code> 文件。<code>|</code> 叫做”管道符”，表示把左边的输出当作右边的输入。<code>jq &#39;.message?&#39;</code> 的意思是获取 JSON 格式第一层的 <code>message</code> 信息，问号表示如果没有这个信息，那就返回 <code>null</code> 代替，相当于:</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Bash"><span class="hljs-keyword">if</span> message exists <span class="hljs-keyword">in</span> JSON, <span class="hljs-keyword">then</span> <span class="hljs-built_in">return</span> message <span class="hljs-keyword">else</span> <span class="hljs-built_in">return</span> null<br></code></pre></div></td></tr></table></figure><p>上传成功之后，我们直接返回图片的链接：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Bash"><span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;<span class="hljs-variable">$cdn</span>/<span class="hljs-variable">$image_name</span>&quot;</span><br></code></pre></div></td></tr></table></figure><p>Shell 脚本的返回和其他语言的返回不大一样，其实这个是打印，而不是返回。最后我们的脚本是：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Bash"><span class="hljs-comment"># 函数描述:</span><br><span class="hljs-comment">#   上传图片到 GitHub 图床</span><br><span class="hljs-comment"># 参数: 无</span><br><span class="hljs-comment"># 返回值: 图片的链接，或者弹出失败后的信息</span><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">upload2github</span></span>() &#123;<br><br>  <span class="hljs-comment">####################设置#######################</span><br>  <span class="hljs-built_in">local</span> repo=<span class="hljs-string">&#x27;202203&#x27;</span>  <span class="hljs-comment"># 这是你的仓库名</span><br>  <span class="hljs-built_in">local</span> username=<span class="hljs-string">&#x27;chunshuyumao&#x27;</span> <span class="hljs-comment"># 这是你的帐号名，现在写的是我的</span><br>  <span class="hljs-built_in">local</span> token=<span class="hljs-string">&#x27;xxxxxxxxxxxxxxxxxxxxxx&#x27;</span> <span class="hljs-comment"># 你的私人令牌，token</span><br>  <span class="hljs-comment">################可选 CDN 加速###################</span><br>  <span class="hljs-built_in">local</span> cdn=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/gh/<span class="hljs-variable">$username</span>/<span class="hljs-variable">$repo</span>@master&quot;</span><br>  <span class="hljs-comment">####################设置########################</span><br><br>  <span class="hljs-built_in">local</span> content=<span class="hljs-string">&quot;<span class="hljs-subst">$(base64 -w 0 $path2image)</span>&quot;</span><br>  <span class="hljs-built_in">local</span> github_url=<span class="hljs-string">&quot;https://api.github.com/repos/<span class="hljs-variable">$username</span>/<span class="hljs-variable">$repo</span>/contents/<span class="hljs-variable">$image_name</span>&quot;</span><br>  <span class="hljs-built_in">local</span> message=<span class="hljs-string">&quot;<span class="hljs-subst">$(curl \</span></span><br><span class="hljs-subst"><span class="hljs-string">    -X &#x27;PUT&#x27; <span class="hljs-string">&quot;<span class="hljs-variable">$github_url</span>&quot;</span> \</span></span><br><span class="hljs-subst"><span class="hljs-string">    -H &#x27;Accept: application/vnd.github.v3+json&#x27; \</span></span><br><span class="hljs-subst"><span class="hljs-string">    -H <span class="hljs-string">&quot;Authorization: token <span class="hljs-variable">$token</span>&quot;</span> \</span></span><br><span class="hljs-subst"><span class="hljs-string">    -d &#x27;&#123; <span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;upload&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;&#x27;<span class="hljs-variable">$content</span>&#x27;&quot;</span> &#125;&#x27; 2&gt; /dev/null | jq &#x27;.message?&#x27;)</span>&quot;</span><br><br>  <span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$message</span>&quot;</span> != <span class="hljs-string">&quot;upload&quot;</span> ]]; <span class="hljs-keyword">then</span><br>    notify-send -t <span class="hljs-variable">$expire</span> -i <span class="hljs-string">&#x27;dialog-error&#x27;</span> <span class="hljs-string">&#x27;ERROR&#x27;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$message</span>&quot;</span><br>    <span class="hljs-built_in">exit</span> 1<br>  <span class="hljs-keyword">fi</span><br><br>  <span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;<span class="hljs-variable">$cdn</span>/<span class="hljs-variable">$image_name</span>&quot;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>GitHub 函数写完。后面来看看 SM.MS。</p><h2 id="SM-MS-函数"><a href="#SM-MS-函数" class="headerlink" title="SM.MS 函数"></a>SM.MS 函数</h2><p>SM.MS 图床也需要准备一个 <code>token</code>，主要结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Bash"><span class="hljs-comment"># 函数描述:</span><br><span class="hljs-comment">#   上传图片到 SM.MS 图床</span><br><span class="hljs-comment"># 参数: 无</span><br><span class="hljs-comment"># 返回值: 图片的链接，或者返回失败后的信息</span><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">upload2smms</span></span>() &#123;<br><br>  <span class="hljs-comment">#################SETTINGS START#################</span><br>  <span class="hljs-built_in">local</span> smms_url=<span class="hljs-string">&quot;https://sm.ms/api/v2/upload&quot;</span><br>  <span class="hljs-built_in">local</span> token=<span class="hljs-string">&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;</span><br>  <span class="hljs-comment">#################SETTINGS END###################</span><br><br>  <span class="hljs-built_in">local</span> result=<span class="hljs-string">&quot;<span class="hljs-subst">$(curl \</span></span><br><span class="hljs-subst"><span class="hljs-string">    -X &#x27;POST&#x27; <span class="hljs-string">&quot;<span class="hljs-variable">$smms_url</span>&quot;</span> \</span></span><br><span class="hljs-subst"><span class="hljs-string">    -H &#x27;Content-Type: multipart/form-data&#x27; \</span></span><br><span class="hljs-subst"><span class="hljs-string">    -H <span class="hljs-string">&quot;Authorization: Basic <span class="hljs-variable">$token</span>&quot;</span> \</span></span><br><span class="hljs-subst"><span class="hljs-string">    -F <span class="hljs-string">&quot;smfile=@<span class="hljs-variable">$&#123;path2image&#125;</span>;type=image/png;filename=<span class="hljs-variable">$&#123;image_name&#125;</span>&quot;</span> 2&gt; /dev/null)</span>&quot;</span><br><br>  <span class="hljs-built_in">local</span> image_url=<span class="hljs-string">&quot;<span class="hljs-subst">$(echo -n <span class="hljs-string">&quot;<span class="hljs-variable">$result</span>&quot;</span> | jq &#x27;.data.url?&#x27; | sed -r &#x27;s/\&quot;(.*)</span>\&quot;/\1/g&#x27;)&quot;</span><br>  <span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$image_url</span>&quot;</span> == <span class="hljs-string">&quot;null&quot;</span> ]]; <span class="hljs-keyword">then</span><br>    notify-send -t <span class="hljs-variable">$expire</span> -i <span class="hljs-string">&#x27;dialog-error&#x27;</span> <span class="hljs-string">&quot;ERROR&quot;</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(echo <span class="hljs-string">&quot;<span class="hljs-variable">$result</span>&quot;</span> | jq &#x27;.message?&#x27;)</span>&quot;</span><br>    <span class="hljs-built_in">exit</span> 1<br>  <span class="hljs-keyword">fi</span><br><br>  <span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;<span class="hljs-variable">$image_url</span>&quot;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>这个也很简单，参考<a href="https://doc.sm.ms/" title="SM.MS API">官网</a>。<code>-F</code> 参数是 <code>cURL</code> 传递 <code>form-data</code> 的方式，因为官网说了上传的是文件。一般上传文件直接使用 <code>-F</code>。</p><p><a href="http://101.200.84.36/images/2022/06/27/202206272237441.png" title="SM.MS上传">SM.MS上传</a></p><p><code>jq &#39;.data.url?&#39;</code> 表示从 JSON 中获取 data 下的 url 内容。大概是这样的布局：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">&#123;<br>    <span class="hljs-string">&quot;data&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;usr&quot;</span>: <span class="hljs-string">&quot;blabla&quot;</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>问号仍然表示没有这东东的话返回 <code>null</code>，后面的 <code>message</code> 也一样。</p><p><code>sed -r &#39;s/\&quot;(.*)\&quot;/\1/g&#39;</code> 用于删掉链接两边的双引号（””），因为链接两边不应该有双引号。</p><p>最后判断获取的是不是链接，不是的话就通知错误，并退出。轻轻松松，脚本完成！</p><h2 id="设置全局快捷键"><a href="#设置全局快捷键" class="headerlink" title="设置全局快捷键"></a>设置全局快捷键</h2><p>这里只说 GNOME 的全局快捷键。打开<code>gnome-center-control</code>，或者直接找设置（settings）</p><p><img src="http://101.200.84.36/images/2022/06/27/202206272247001.png" alt="设置" title="设置"></p><p>选择<code>键盘（Keyboard）=&gt; 键盘快捷键（Keyboard Shortcuts）=&gt; 浏览与自定义快捷键（View and Custumize Shortcuts）=&gt; 自定义快捷键（Custom Shortcuts）</code>，点击<code>➕</code>：</p><p><img src="http://101.200.84.36/images/2022/06/27/202206272250411.png" alt="添加" title="添加"></p><p><img src="http://101.200.84.36/images/2022/06/27/202206272251341.png" alt="添加快捷键" title="添加快捷键"></p><p><code>描述（Name）</code> 只是描述，随便写啥；<code>命令（comamnd）</code>写你的脚本所在的路径，最后点击 <code>快捷键（Shortcut）</code>进行快捷键设置。Over！</p><h1 id="后语"><a href="#后语" class="headerlink" title="后语"></a>后语</h1><p>最后，把 PicGo 给卸了，毕竟，自己写的脚本才几K？开玩笑，其实 PicGo<br>除了简单，还有可视化、预览、删除图床图片等等的功能，自己的这个脚本只是阉割版罢了。不得不说，Linux<br>下真的可以自己动手丰衣足食。</p>]]></content>
    
    
    <categories>
      
      <category>Manjaro</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell脚本下载B站视频</title>
    <link href="/2022/06/08/Shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E8%BD%BDB%E7%AB%99%E8%A7%86%E9%A2%91/"/>
    <url>/2022/06/08/Shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E8%BD%BDB%E7%AB%99%E8%A7%86%E9%A2%91/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前一阵子想在 B站 下载点东西，可没有登陆各种网站的习惯。网上存在一些在线解析 B站 视频的网站提供下载，不过我当时需要的是批量下载——可能是有洁癖吧，什么东西都觉得本地保留一份才是最安全的。这样一来，线上解析的网站就难找了。再说了，有些网站为了维持运营，不得不添加一些广告，这就很烦人了——好吧，白嫖没理由抱怨。</p><p>后来不得不使用了 <a href="https://github.com/soimort/you-get">You-get</a> 这个堪称下载神器的东西。You-get 虽然可以实现批量下载，但是问题也很明显，就是批量下载可能会卡住，一卡住就得从来，见鬼。为了加快下载速度，自己又得在 You-get 的基础上写一个多线程下载。You-get 用 Python，我一来对这门语言不感兴趣，二来这东东好像后面还是调用了 <a href="https://ffmpeg.org/">FFmpeg</a> 进行音视频合并，这种东东使用简单的 Shell 也可以实现，何必多此一举？</p><p>有了想法开始动手实现自己的 B站 视频下载脚本。这里要说说，You-get 的功能太强大，一般我用不上，所以自己的脚本自然看起来简单多了，但是和 You-get 比还是功能太少。自己写的脚本不支持列表下载，不过可以配合自己之前写的多线程实现下载——适合自己的就是最好的。</p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>使用 Shell 脚本自然不可能是 Windows 系统，所以 Windows 系统的同志可以散了。想要自己写写的可以随便上网搜搜 Python 语言的，运气好可能搜到一篇真的在教你怎么用 Python 下载的。一般而言，使用国内的搜索引擎会非常痛苦——你不会找到自己想要的东西，你只会找到别人开钱给你看的东西。下面是基本工具：</p><ol><li>Unix&#x2F;Linux 系统，也就是除了 Windows 外的系统。</li><li><a href="https://ffmpeg.org/">FFmpeg</a> 一个跨平台的音视频框架。其实就一句话，合并音视频用的。</li><li>Shell，形形色色的 Shell 都行，为了最大的兼容性，一般是 Bash。</li><li>JQ，一个 Shell 上处理 <a href="https://www.json.org/">JSON</a> 数据的工具。通常 Unix&#x2F;Linux 系统不会自带，是用包管理器直接可以下载。</li></ol><p>除此之外还使用到 SED、<a href="https://curl.se/">cURL</a> 等工具，一般 Unix&#x2F;Linux 系统都自带了，所以不单独列出。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>接下来会分步骤进行实现。</p><h2 id="构建框架"><a href="#构建框架" class="headerlink" title="构建框架"></a>构建框架</h2><p>为了精简脚本的功能，我的想法是脚本如此调用：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">bl.sh https://www.bilibili.com/video/BV1UE411d7QZ<br></code></pre></div></td></tr></table></figure><p>也就是 <code>脚本 + URL</code>。然后就没有任何功能了——要的就是精简。</p><p>首先要创建一个脚本，我用的是 VIM 编辑器，所以下面是基本操作：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ vim bl.sh<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-built_in">set</span> -euo pipefail<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">main</span></span>() &#123;<br><br><br>&#125;<br><br>main <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span><br></code></pre></div></td></tr></table></figure><p>在上面的 <code>bl.sh</code> 脚本中写了一个 <code>main</code> 函数作为主函数，并在最后调用这个函数。因为自己最开始接触到的语言是 C&#x2F;C++ ，总觉得无论如何还是写一个主函数逻辑上才清楚，不喜欢一上来就是各种奇葩语句和乱入的函数堆叠。</p><p><code>set -euo pipefail</code> 设置脚本的一些功能，其中 <code>-e</code> 表示遇到报错直接退出（EXIT），<code>-u</code> 表示使用没有声明的变量（undecleared variable）就直接退出，<code>-o pipefail</code> 表示使用管道符失败就报错退出。</p><p>设置上面的功能源于我的一些理念：只要没有得到正确执行就是错误，错误没有必要存在，没必要存在就没必要执行，程序直接算失败。这是一种习惯，有些人就喜欢和警告（warning、info）、错误（error）共存，咱也没办法。</p><p>为了进行检验，下面会以 <code>https://www.bilibili.com/video/BV1Sg41137WR</code> 作为下载事例。</p><h2 id="使用-cURL"><a href="#使用-cURL" class="headerlink" title="使用 cURL"></a>使用 cURL</h2><p>我们先用 cURL 请求目标网址试试：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ curl -O <span class="hljs-string">&quot;https://www.bilibili.com/video/BV1Sg41137WR&quot;</span><br>  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current<br>                                 Dload  Upload   Total   Spent    Left  Speed<br>100 47405    0 47405    0     0  83409      0 --:--:-- --:--:-- --:--:-- 83312<br>$ <span class="hljs-built_in">ls</span><br>BV1Sg41137WR<br>$ file BV1Sg41137WR<br>BV1Sg41137WR: gzip compressed data, from Unix, original size modulo 2^32 259418<br></code></pre></div></td></tr></table></figure><p><img src="http://101.200.84.36/images/2022/06/08/202206082248087.png" alt="尝试请求" title="尝试请求"></p><p><code>curl -O url</code> 表示把请求网址的结果保存，我们看到，保存之后生成了一个 <code>BV1Sg41137WR</code> 的 gZIP 压缩文件。解压这个文件试试：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">mv</span> BV1Sg41137WR&#123;,.gz&#125;<br>$ gzip -d BV1Sg41137WR.gz<br>$ file BV1Sg41137WR<br>BV1Sg41137WR: HTML document, Unicode text, UTF-8 text, with very long lines (63971), with no line terminators<br></code></pre></div></td></tr></table></figure><p><img src="http://101.200.84.36/images/2022/06/08/202206082249382.png" alt="解压文件" title="解压文件"></p><p>可以看到，解压之后这个文件其实是一个 HTML 文件，也就是网页的源码。我们要找的视频网址等内容都在里边，接下来就是我们解读了。解释解释上面的行为。</p><p><code>mv</code> 是重命名的意思，因为后面需要解压，自然就需要重名了。FreeBSD 等 Unix 直系后代系统习惯通过文件内容判断文件格式。比如上面的 <code>BV1Sg41137WR</code> 文件，通过判断可以得知是 gZIP 文件。在 FreeBSD 中可以直接使用 <code>gzip -d</code> 解压，因为通过内容可以轻松辨认出来；但是 Linux 系统通过文件扩展名辨认文件， <code>BV1Sg41137WR</code> 没有文件名，在 Linux 上使用 <code>gzip -d</code> 它就分辨不出来这个文件是啥，自然就拒绝解压。</p><p><img src="http://101.200.84.36/images/2022/06/08/202206082255543.png" alt="错误案例" title="错误案例"></p><p><code>mv</code> 是 <code>move</code> 的缩写，用于移动和重命名。按理来说我们的操作应该是</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> BV1Sg41137WR BV1Sg41137WR.gz<br></code></pre></div></td></tr></table></figure><p><code>.gz</code> 是 gZIP 文件的扩展名。可是我们看到上面的操作重复的字符太多了，懒人就不该写那么多的字母，所以 Linux Shell 又有这种操作</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> BV1Sg41137WR&#123;,.gz&#125;<br></code></pre></div></td></tr></table></figure><p>通过在花括号和一个逗号省略相同的部分。于是就有我们的上面的操作。</p><p><code>gzip -d</code> 中的 <code>-d</code> 是 <code>--decompress</code> 的缩写，也就是解压咯。</p><p>接下来可以使用文本编辑器查看下载的 HTML 源码，其实最好的方式是通过浏览器直接查看源码。因为已经搞清楚了 B站 尿性，所以我这里就不解释如何通过分析源码了解我们想要的内容。直接告诉大家：我们需要的部分在源码中的 <code>window.__playinfo__</code> 部分，可以通过浏览器查看源码然后查找得到。</p><p><img src="http://101.200.84.36/images/2022/06/09/202206091212163.png" alt="目标" title="目标"></p><p>接下来要做的就是把 <code>__playinfo__=</code> 后面的内容提取出来，然后通过 jq 格式化显示出来。</p><h2 id="获取目标内容"><a href="#获取目标内容" class="headerlink" title="获取目标内容"></a>获取目标内容</h2><p>已经有了 HTML 源码，现在就是从源码中提取我们需要的部分。上面已经说过，<code>__playinfo__=</code> 后面就是我们的目标内容。在命令行上输入</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> BV1Sg41137WR | sed -nr <span class="hljs-string">&#x27;s/.*__playinfo__=(.*)&lt;\/script&gt;&lt;script&gt;.*/\1/gp&#x27;</span><br></code></pre></div></td></tr></table></figure><p><img src="http://101.200.84.36/images/2022/06/09/202206091254062.png" alt="获取需要的部分" title="获取需要的部分"></p><p>这里解释一下，我们需要使用 <code>BV1Sg41137WR</code> 的内容，所以通过 <code>cat</code> 和管道符 <code>|</code> 把内容传递给 SED。SED 参数 <code>-n</code> 表示不打印，SED 一般匹配之后会直接打印出来，我们希望打不打印由自己控制，所以默认直接不打印；<code>-r</code> 表示后面我们会用到正则表达式（Regular Expression）。</p><p><code>s/.*__playinfo__=(.*)&lt;\/script&gt;&lt;script&gt;.*/\1/gp</code> 是传递给 SED 的正则匹配模式。在 SED 中使用替换的语法是 <code>s/old/new/gp</code>，把 <code>old</code> 替换为 <code>new</code>，<code>g</code> 表示全局替换，SED 默认只替换一次，使用全局替换就是见到的就替换；<code>p</code> 表示打印出来，也就是替换之后打印出来；这里的 <code>gp</code>是可选的，也就是可有可无。正则中的 <code>.*</code> 表示任何字符，<code>(.*)</code> 表示任意字符，并把它们分成一个小组，小组的编号从 1 开始，使用 <code>\1</code> 代替。如果看不懂就算了，这就是提取内容罢了。</p><p>获取内容之后，我们可以看到内容非常乱，简直不是人看的。使用 JQ 进行格式化就好看了：</p><p><img src="http://101.200.84.36/images/2022/06/09/202206091305686.png" alt="格式化之后" title="格式化之后"></p><p>现在我们需要的是视频的链接。B站 由于各种原因——谁都有自己的原因——为了防止别人下载自己的视频，把视频和音频分开存储，这样如果你使用具有嗅探功能的下载器也只能下载到没有音频的视频而已——没办法。</p><p>分析我们抓取到内容可以看出，数据中存在视频（video）和音频（audio）两个部分，我们需要做的就是抓取音、视频，然后通过 FFmpeg 合并。</p><p>通过格式化后的 JSON 数据可以看到，视频在 <code>data</code> 标签下的 <code>dash</code> 下的 <code>video</code> 下的 <code>baseUrl</code> 。我们可以通过 JQ 回去，格式是：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ jq <span class="hljs-string">&#x27;.data.dash.video[0].baseUrl&#x27;</span> JSON<br></code></pre></div></td></tr></table></figure><p><code>video</code> 加 <code>[0]</code> 是因为视频有多种清晰度，我们只需要获取第一个清晰度就行——在编程中，第一个往往从 0 开始数。同理，音频如此获取：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ jq <span class="hljs-string">&#x27;.data.dash.audio[0].baseUrl&#x27;</span> JSON<br></code></pre></div></td></tr></table></figure><p>JQ 可以一次性获取多个值，所以我们可以简单写成：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ jq <span class="hljs-string">&#x27;.data.dash.video[0].baseUrl, .data.dash.audio[0].baseUrl&#x27;</span> JSON<br></code></pre></div></td></tr></table></figure><p>最后我们这样获取想要的数据：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> BV1Sg41137WR | sed -nr <span class="hljs-string">&#x27;s/.*__playinfo__=(.*)&lt;\/script&gt;&lt;script&gt;.*/\1/gp&#x27;</span> | jq <span class="hljs-string">&#x27;.data.dash.video[0].baseUrl, .data.dash.audio[0].baseUrl&#x27;</span><br><br><span class="hljs-string">&quot;https://upos-sz-mirrorhw.bilivideo.com/upgcxcode/53/45/348384553/348384553_nb2-1-30080.m4s?e=ig8euxZM2rNcNbdlhoNvNC8BqJIzNbfqXBvEqxTEto8BTrNvN0GvT90W5JZMkX_YN0MvXg8gNEV4NC8xNEV4N03eN0B5tZlqNxTEto8BTrNvNeZVuJ10Kj_g2UB02J0mN0B5tZlqNCNEto8BTrNvNC7MTX502C8f2jmMQJ6mqF2fka1mqx6gqj0eN0B599M=&amp;uipk=5&amp;nbs=1&amp;deadline=1654755278&amp;gen=playurlv2&amp;os=hwbv&amp;oi=3723425079&amp;trid=9f2d5b2f02c543e4919e6644832471cbu&amp;mid=0&amp;platform=pc&amp;upsig=dfcbb72afadc553a5c83c23fcacb7148&amp;uparams=e,uipk,nbs,deadline,gen,os,oi,trid,mid,platform&amp;bvc=vod&amp;nettype=0&amp;orderid=0,3&amp;agrr=1&amp;bw=255483&amp;logo=80000000&quot;</span><br><span class="hljs-string">&quot;https://upos-sz-mirrorhw.bilivideo.com/upgcxcode/53/45/348384553/348384553_nb2-1-30280.m4s?e=ig8euxZM2rNcNbdlhoNvNC8BqJIzNbfqXBvEqxTEto8BTrNvN0GvT90W5JZMkX_YN0MvXg8gNEV4NC8xNEV4N03eN0B5tZlqNxTEto8BTrNvNeZVuJ10Kj_g2UB02J0mN0B5tZlqNCNEto8BTrNvNC7MTX502C8f2jmMQJ6mqF2fka1mqx6gqj0eN0B599M=&amp;uipk=5&amp;nbs=1&amp;deadline=1654755278&amp;gen=playurlv2&amp;os=hwbv&amp;oi=3723425079&amp;trid=9f2d5b2f02c543e4919e6644832471cbu&amp;mid=0&amp;platform=pc&amp;upsig=8b68ed8743e01fde1dc6ac48136b3bc4&amp;uparams=e,uipk,nbs,deadline,gen,os,oi,trid,mid,platform&amp;bvc=vod&amp;nettype=0&amp;orderid=0,3&amp;agrr=1&amp;bw=23987&amp;logo=80000000&quot;</span><br></code></pre></div></td></tr></table></figure><p><img src="http://101.200.84.36/images/2022/06/09/202206091318587.png" alt="获取音、视频链接" title="获取音、视频链接"></p><p>可以看到，获取的链接两边有引号，我们不需要这些引号，所以使用 SED 去除。方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> BV1Sg41137WR | sed -nr <span class="hljs-string">&#x27;s/.*__playinfo__=(.*)&lt;\/script&gt;&lt;script&gt;.*/\1/gp&#x27;</span> | jq <span class="hljs-string">&#x27;.data.dash.video[0].baseUrl, .data.dash.audio[0].baseUrl&#x27;</span> | sed -nr <span class="hljs-string">&#x27;s/\&quot;(.*)\&quot;/\1/gp&#x27;</span><br></code></pre></div></td></tr></table></figure><p>既然已经获得链接，可以把上面的步骤写进脚本了。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">set</span> -euo pipefail<br><br><span class="hljs-comment"># 测试的 B站 视频链接</span><br><span class="hljs-built_in">declare</span> url=<span class="hljs-string">&#x27;https://www.bilibili.com/video/BV1Sg41137WR&#x27;</span><br><br><span class="hljs-comment"># 获取内容的正则表达式，用于 sed</span><br><span class="hljs-built_in">declare</span> -r reg_data=<span class="hljs-string">&#x27;s/.*__playinfo__=(.*)&lt;\/script&gt;&lt;script&gt;.*/\1/gp&#x27;</span><br><span class="hljs-comment"># 获取音、视频的正则，用于 jq</span><br><span class="hljs-built_in">declare</span> -r reg_video_audio=<span class="hljs-string">&#x27;.data.dash.video[0].baseUrl, .data.dash.audio[0].baseUrl&#x27;</span><br><span class="hljs-comment"># User-Agent 用于伪装成这成浏览器的请求——因为 B站 发现是脚本在下载视频就会阻止你下载。</span><br><span class="hljs-comment"># 如果你伪装成浏览器，它就以为你使用浏览器，自然不会影响到它的利益，也就不管你下载多少</span><br><span class="hljs-comment"># 视频了——毕竟你浏览越多，对它越好</span><br><span class="hljs-built_in">declare</span> -r user_agent=<span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.116 Safari/537.36&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">main</span></span>() &#123;<br><br>  <span class="hljs-comment"># 获取原始 HTML 源文件，把输出输出到 /dev/null，同时使用 gzip 进行解压，解压的内容放到</span><br>  <span class="hljs-comment"># raw_html 变量中</span><br>  <span class="hljs-built_in">local</span> raw_html=$(curl --user-agent <span class="hljs-string">&quot;<span class="hljs-variable">$user_agent</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$url</span>&quot;</span> 2&gt; /dev/null | gzip -d -)<br>  <span class="hljs-built_in">local</span> va=($(<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$raw_html</span>&quot;</span> | sed -nr <span class="hljs-variable">$reg_data</span> | jq <span class="hljs-string">&quot;<span class="hljs-variable">$reg_video_audio</span>&quot;</span> | sed -nr <span class="hljs-string">&#x27;s/\&quot;(.*)\&quot;/\1/gp&#x27;</span>))<br>&#125;<br><br>main <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span><br></code></pre></div></td></tr></table></figure><p>这里，我们不再下载网页源码成单独一个文件，而是处理之后直接保存到一个变量（raw_html）中。最后把音、视频内容放到一个数组 <code>va</code> 中。Shell 中的数组使用 <code>()</code> 括起来。现在视频地址在 <code>va[0]</code>，音频地址在 <code>va[1]</code>。</p><h2 id="下载音、视频"><a href="#下载音、视频" class="headerlink" title="下载音、视频"></a>下载音、视频</h2><p>下载音视频的方法比较简单：给 cURL 添加一个 <code>referer</code> 然后就可以下载了，语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">curl --referer <span class="hljs-string">&quot;<span class="hljs-variable">$url</span>&quot;</span> --user-agent <span class="hljs-string">&quot;va[0]&quot;</span> --output <span class="hljs-string">&quot;视频.mp4&quot;</span><br>curl --referer <span class="hljs-string">&quot;<span class="hljs-variable">$url</span>&quot;</span> --user-agent <span class="hljs-string">&quot;va[1]&quot;</span> --output <span class="hljs-string">&quot;音频.mp4&quot;</span><br></code></pre></div></td></tr></table></figure><p>所以脚本现在是：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">  <span class="hljs-built_in">local</span> va=($(<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$raw_html</span>&quot;</span> | sed -nr <span class="hljs-variable">$reg_data</span> | jq <span class="hljs-string">&quot;<span class="hljs-variable">$reg_video_audio</span>&quot;</span> | sed -nr <span class="hljs-string">&#x27;s/\&quot;(.*)\&quot;/\1/gp&#x27;</span>))<br>  <span class="hljs-built_in">local</span> tempfile=$(mktmpfile) || <span class="hljs-built_in">exit</span> 1<br>  curl --referer <span class="hljs-string">&quot;<span class="hljs-variable">$url</span>&quot;</span> --user-agent <span class="hljs-string">&quot;va[0]&quot;</span> --output <span class="hljs-string">&quot;<span class="hljs-variable">$tmpfile</span>-video.mp4&quot;</span><br>  curl --referer <span class="hljs-string">&quot;<span class="hljs-variable">$url</span>&quot;</span> --user-agent <span class="hljs-string">&quot;va[1]&quot;</span> --output <span class="hljs-string">&quot;<span class="hljs-variable">$tmpfile</span>-audio.mp4&quot;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>其中 我们创建（mktmpfile）了一个临时文件（temporary file, tmpfile），并确保只有创建成功才执行下面的语句，否则退出（exit 1）。</p><p>然后我们把音、视频的文件名改为临时文件的文件名加 <code>video</code> 和 <code>audio</code> 等字样，这是防止文件名重复，导致多线程下载失败。</p><p>接下来就是合并我们的音、视频。不过我们还没有获取视频的标题——这里我直接给出获取视频标题的正则表达式：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">declare</span> -r reg_title=<span class="hljs-string">&#x27;s/.*&lt;h1 title=.*&gt;(.*)&lt;\/h1&gt;.*/\1/gp&#x27;</span><br><br><span class="hljs-comment"># 获取标题</span><br>title=<span class="hljs-string">&quot;<span class="hljs-subst">$(echo <span class="hljs-string">&quot;<span class="hljs-variable">$raw_html</span>&quot;</span> | sed -nr <span class="hljs-string">&quot;<span class="hljs-variable">$reg_title</span>&quot;</span>)</span>&quot;</span><br></code></pre></div></td></tr></table></figure><p>最后使用 FFmpeg 进行合并：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">ffmpeg -i <span class="hljs-string">&quot;<span class="hljs-variable">$tmpfile</span>-video.mp4&quot;</span> -i <span class="hljs-string">&quot;<span class="hljs-variable">$tmpfile</span>-audio.mp4&quot;</span> -c copy <span class="hljs-string">&quot;<span class="hljs-variable">$title</span>.mp4&quot;</span> -y -loglevel quiet<br></code></pre></div></td></tr></table></figure><p>FFmpeg 的参数介绍一下：</p><ol><li><code>-i</code> 是 <code>inputfile</code> 的缩写，代表输入的文件，也就是要合并的文件。</li><li><code>-c</code> 是 <code>codec</code> 的缩写，编码的方式——这里直接使用复制。</li><li><code>-y</code> 是 <code>yes</code> 的缩写，其实就是直接覆盖文件，它会覆盖之前合并的文件，懒人专用。</li><li><code>-loglevel</code> 是日志打印的等级，这里是 <code>quiet</code> ，也就是不打印任何日志。</li></ol><p>FFmpeg 不会用没关系，知道这么回事就行——我也不咋地使用这东东。</p><p>合并之后，做好把之前的文件删了，所以再写删除脚本执行过程中产生的文件。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">/bin/rm -r <span class="hljs-variable">$tmpfile</span> <span class="hljs-variable">$tmpfile</span>-audio.mp4 <span class="hljs-variable">$tmpfile</span>-video.mp4<br></code></pre></div></td></tr></table></figure><p>所以我们的脚本最现在是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash是">#!/bin/bash<br>set -euo pipefail<br><br># 获取内容的正则表达式，用于 sed<br>declare -r reg_data=&#x27;s/.*__playinfo__=(.*)&lt;\/script&gt;&lt;script&gt;.*/\1/gp&#x27;<br># 获取音、视频的正则，用于 jq<br>declare -r reg_video_audio=&#x27;.data.dash.video[0].baseUrl, .data.dash.audio[0].baseUrl&#x27;<br><br># 获取标题<br>declare -r reg_title=&#x27;s/.*&lt;h1 title=.*&gt;(.*)&lt;\/h1&gt;.*/\1/gp&#x27;<br><br># User-Agent 用于伪装成这成浏览器的请求——因为 B站 发现是脚本在下载视频就会阻止你下载。<br># 如果你伪装成浏览器，它就以为你使用浏览器，自然不会影响到它的利益，也就不管你下载多少<br># 视频了——毕竟你浏览越多，对它越好<br>declare -r user_agent=&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.116 Safari/537.36&#x27;<br><br>function main() &#123;<br><br>  # 这里把命令行第一个参数当作 URL<br>  declare url=&quot;$1&quot;<br><br>  # 获取原始 HTML 源文件，把输出输出到 /dev/null，同时使用 gzip 进行解压，解压的内容放到<br>  # raw_html 变量中<br>  local raw_html=$(curl --user-agent &quot;$user_agent&quot; &quot;$url&quot; 2&gt; /dev/null | gzip -d -)<br>local va=($(echo &quot;$raw_html&quot; | sed -nr $reg_data | jq &quot;$reg_video_audio&quot; | sed -nr &#x27;s/\&quot;(.*)\&quot;/\1/gp&#x27;))<br>  <br>  local tmpfile=$(mktemp) || exit 1<br>  curl --referer &quot;$url&quot; --user-agent &quot;$user_agent&quot; &quot;$&#123;va[0]&#125;&quot; --output &quot;$tmpfile-video.mp4&quot;<br>  curl --referer &quot;$url&quot; --user-agent &quot;$user_agent&quot; &quot;$&#123;va[1]&#125;&quot; --output &quot;$tmpfile-audio.mp4&quot;<br><br>  local title=&quot;$(echo &quot;$raw_html&quot; | sed -nr &quot;$reg_title&quot;)&quot;<br>  <br>  # 合并音、视频<br>  ffmpeg -i &quot;$tmpfile-video.mp4&quot; -i &quot;$tmpfile-audio.mp4&quot; -c copy &quot;$title.mp4&quot; -y -loglevel quiet<br>  <br>  # 删除脚本产生的文件爱你<br>  /bin/rm -r $tmpfile $tmpfile-audio.mp4 $tmpfile-video.mp4<br>&#125;<br><br>main &quot;$@&quot;<br></code></pre></div></td></tr></table></figure><p>至此脚本完成——非常简短。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>写完不代表一定成功，我们需要测试下载</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">ls</span><br>bl.sh<br>$ <span class="hljs-built_in">chmod</span> u+x bl.sh <span class="hljs-comment"># 赋予脚本可执行权限</span><br>$ ./bl.sh <span class="hljs-string">&quot;https://www.bilibili.com/video/BV1Sg41137WR&quot;</span><br>https://www.bilibili.com/video/BV1Sg41137WR<br>  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current<br>                                 Dload  Upload   Total   Spent    Left  Speed<br>100 52.6M  100 52.6M    0     0  2945k      0  0:00:18  0:00:18 --:--:-- 2977k<br>  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current<br>                                 Dload  Upload   Total   Spent    Left  Speed<br>100 5059k  100 5059k    0     0  2936k      0  0:00:01  0:00:01 --:--:-- 2938k<br>$ <span class="hljs-built_in">ls</span><br> bl.sh  <span class="hljs-string">&#x27;【红楼梦】夜曲 宝玉.mp4&#x27;</span><br></code></pre></div></td></tr></table></figure><p>完工！到这里， B站 视频下载就算完工了。</p><h1 id="后语"><a href="#后语" class="headerlink" title="后语"></a>后语</h1><p>简单来说，这次的教程不难，就是以下几个步骤：</p><ol><li>获取网页源码</li><li>分析源码，获取音、视频链接</li><li>下载音、视频</li><li>合并音视频</li></ol><p>知道了过程，使用其他编程语言也可以。使用 Shell 脚本看起来确实不是很优雅，为此我在这里附上用 Python 写的下载，不然简单的下载真的被我写的很难：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#!/bin/python3</span><br><span class="hljs-comment"># -*- conding:utf-8 -*-</span><br><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Please Waiting...&#x27;</span>, flush=<span class="hljs-literal">True</span>)<br>    <span class="hljs-comment"># 获取 URL</span><br>    url = sys.argv[<span class="hljs-number">1</span>]<br>    <span class="hljs-comment"># 设置 User-Agent</span><br>    headers = &#123;<br>        <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.116 Safari/537.36&#x27;</span><br>    &#125;<br><br>    <span class="hljs-comment"># 获取网页源码</span><br>    raw_html = requests.get(url, headers=headers)<br>    <span class="hljs-comment"># 视频标题</span><br>    title = re.search(<span class="hljs-string">&#x27;&lt;h1 title=.*&gt;(.*)&lt;/h1&gt;&#x27;</span>, raw_html.text).group(<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 获取目标数据，</span><br>    data = re.search(<span class="hljs-string">&#x27;__playinfo__=(.*?)&lt;/script&gt;&lt;script&gt;&#x27;</span>, raw_html.text).group(<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 把目标数据转化为 Python 可读的 JSON 格式</span><br>    json_data = json.loads(data)<br>    video_url = json_data[<span class="hljs-string">&#x27;data&#x27;</span>][<span class="hljs-string">&#x27;dash&#x27;</span>][<span class="hljs-string">&#x27;video&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;baseUrl&#x27;</span>]<br>    audio_url = json_data[<span class="hljs-string">&#x27;data&#x27;</span>][<span class="hljs-string">&#x27;dash&#x27;</span>][<span class="hljs-string">&#x27;audio&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;baseUrl&#x27;</span>]<br>    <br>    <span class="hljs-comment"># 设置 Referer</span><br>    headers.update(&#123;<span class="hljs-string">&#x27;Referer&#x27;</span>: url&#125;)<br><br>    <span class="hljs-comment"># 随即生成 1～100 作为基础文件名</span><br>    basefile_name = <span class="hljs-built_in">str</span>(random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>))<br>    <span class="hljs-comment"># 获取当前目录</span><br>    working_path = os.getcwd()<br>    <span class="hljs-comment"># 创建临时文件名，</span><br>    video_file = os.path.join(working_path, <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;basefile_name&#125;</span>-video.mp4&#x27;</span>)<br>    audio_file = os.path.join(working_path, <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;basefile_name&#125;</span>-audio.mp4&#x27;</span>)<br><br>    <span class="hljs-comment"># 下载视频和音频</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(video_file, <span class="hljs-string">&#x27;ab&#x27;</span>) <span class="hljs-keyword">as</span> video:<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">iter</span> <span class="hljs-keyword">in</span> requests.get(video_url, headers=headers).iter_content(<span class="hljs-number">1024</span>):<br>            video.write(<span class="hljs-built_in">iter</span>)<br><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(audio_file, <span class="hljs-string">&#x27;ab&#x27;</span>) <span class="hljs-keyword">as</span> audio:<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">iter</span> <span class="hljs-keyword">in</span> requests.get(audio_url, headers=headers).iter_content(<span class="hljs-number">1024</span>):<br>            audio.write(<span class="hljs-built_in">iter</span>)<br><br>    <span class="hljs-comment"># 调用 FFmpeg 进行合并</span><br>    os.system(<span class="hljs-string">f&#x27;ffmpeg -i <span class="hljs-subst">&#123;video_file&#125;</span> -i <span class="hljs-subst">&#123;audio_file&#125;</span> &quot;<span class="hljs-subst">&#123;title&#125;</span>.mp4&quot; -c copy -y -loglevel quiet&#x27;</span>)<br><br>    <span class="hljs-comment"># 删除创建的临时文件</span><br>    os.remove(video_file)<br>    os.remove(audio_file)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Download END...&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></div></td></tr></table></figure><p>Python 解析 JSON 非常慢，原本我写了一个进度条，结果发现解析 JSON 就很慢了，进度条基本等于没用，所以这里就没有加上。</p><p>即使是 Python 也需要使用 FFmpeg。如果使用的是 Windows 系统，需要设置 FFmpeg 的环境变量——或者把 <code>ffmpeg</code> 改为 <code>ffmpeg 的路径</code> 也行。例如，我使用 Windows 系统，并且下载的 FFmpeg 在 <code>C:\User\chunshuyumao\Downloads\ffmpeg.exe</code>， Python 脚本倒数第六行从</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">os.system(<span class="hljs-string">f&#x27;ffmpeg -i......&#x27;</span>)<br></code></pre></div></td></tr></table></figure><p>改为</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">os.system(<span class="hljs-string">f&#x27;C:\\User\\chunshuyumao\\Downloads\\ffmpeg.exe -i.....&#x27;</span>)<br></code></pre></div></td></tr></table></figure><p>如果觉得好玩——也许可以用用自己喜欢的语言实现一遍？</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>脚本</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GitHub 图床加速</title>
    <link href="/2022/05/23/GitHub-%E5%9B%BE%E5%BA%8A%E5%8A%A0%E9%80%9F/"/>
    <url>/2022/05/23/GitHub-%E5%9B%BE%E5%BA%8A%E5%8A%A0%E9%80%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>图床迁移到 GitHub 之后，我也面临 DNS 污染的问题。图片保存在 GitHub 通常不会有什么问题，就是访问比较慢，国内如此。想要加速，我们就的使用 CDN 加速。</p><p>CDN<ruby>（内容分发网络）<rt>Content Delivery Network</rt></ruby> 尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。一句话总结，就是让距离最近的服务器响应请求，加快网络内容的传输。一般用于加速静态资源，如网站上面上传的图片、媒体等。</p><p>通常我们使用的是 <a href="https://www.jsdelivr.com/" title="JsDelivr">JsDelivr</a>，一个免费、可靠的 CDN 加速。下面是官网，主页面直接放了大量的使用方法：</p><p><img src="http://101.200.84.36/images/2022/05/23/202205231714065.png" alt="JsDelivr 官网主页" title="JsDelivr 官网主页"></p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>首先找一张 GitHub 上的图片，我这里选了一张之前用过的 Zettlr 官网的图片，地址是</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">https://raw.githubusercontent.com/chunshuyumao/202203bf/master/202203132034512.png<br>或者<br>https://github.com/chunshuyumao/202203bf/raw/master/202203132034512.png<br></code></pre></div></td></tr></table></figure><p>效果如下——一般是看不到下面的图片的，也不排除图片可以显示，只是加载比较慢。</p><p><img src="https://raw.githubusercontent.com/chunshuyumao/202203bf/master/202203132034512.png" alt="未加速前 Zettlr 官网图片" title="未加速前 Zettlr 官网图片"></p><p>要使用 CDN 加速，需要把地址改成下面的形式</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203132034512.png<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203132034512.png" alt="JsDelivr 加速后的 Zettlr 编辑器官网主页图片" title="JsDelivr 加速后的 Zettlr 编辑器官网主页图片"></p><p>可以看到，要加速 GitHub 的图片，加速地址是这样的</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">https://cdn.jsdelivr.net/gh/github帐号名/仓库名@分支名/图片名<br></code></pre></div></td></tr></table></figure><p>其中，分支名一般是主分支，也就是 master 或者 main，至于到底是哪个，要是看你的仓库的主分支。</p><h1 id="PicGo-加速"><a href="#PicGo-加速" class="headerlink" title="PicGo 加速"></a>PicGo 加速</h1><p>如果使用 GitHub 作为图床，建议配合 PicGo 使用。使用 PicGo ，需要修改 GitHub 的配置。打开 PicGo，转到 GitHub 设置，按照下面进行配置。</p><p>首先，分支名要写你的 GitHub 分支，我这里是 main 分支。其次写自定义域名，格式和上面说的一样。这样，PicGo 上传后会自动返回加速后的地址。</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">https://cdn.jsdelivr.net/gh/GitHub帐号/仓库名@分支名<br></code></pre></div></td></tr></table></figure><p><img src="http://101.200.84.36/images/2022/05/23/202205231727605.png" alt="PicGo 中的 GitHub 设置" title="PicGo 中的 GitHub 设置"></p><h1 id="Hexo-加速"><a href="#Hexo-加速" class="headerlink" title="Hexo 加速"></a>Hexo 加速</h1><p><code>cdn.jsdelivr.net</code> 加速也不一定完全可靠，比如前几天这个加速也样被污染了。<code>cdn.jsdelivr.net</code> 使用不了，我们可以改成 <code>fastly.jsdelivr.net</code> 或者 <code>gcore.jsdelivr.net</code>。如果使用 Hexo 管理静态博客，我们可能需要修改博客中的图片地址。</p><p>如果不嫌麻烦，可以使用文本编辑器直接全局修改。例如在 Linux 系统上使用 <ruby>SED（文件流编辑器）<rt>Stream Editor</rt></ruby> 全局修改：首先转到博客源文件（Markdown 文件）目录，然后输入修改代码。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> Docment/NotePages/source/_posts <span class="hljs-comment"># 进入源文件目录</span><br>$ <span class="hljs-built_in">ls</span> | xargs -i sed -i <span class="hljs-string">&#x27;s/cdn.jsdelivr.net/fastly.jsdelivr.net/g&#x27;</span> &#123;&#125; <span class="hljs-comment"># 修改文件内地址</span><br></code></pre></div></td></tr></table></figure><p><img src="http://101.200.84.36/images/2022/05/23/202205231740399.png" alt="SED 批量修改地址" title="SED 批量修改地址"></p><p>如果是其他系统的用户，可以使用文件编辑器打开文件，然后使用全局修改。</p><p>不过这只是权宜之计，我希望还是使用 <code>cdn.jsdelivr.net</code> 只是在它使用不了的时候再改成其他加速。既然如此，我们就需要借助其他工具了。</p><p><a href="https://hexo.fluid-dev.com/" title="Hexo Fluid 主题">Hexo Fluid 主题</a> 有 <a href="https://hexo.fluid-dev.com/posts/hexo-injector/" title="Fluid 主题注入功能">注入功能</a>，也就是下面用到的。如果想要真正了解该主题的注入功能，最好到 <a href="https://hexo.fluid-dev.com/posts/hexo-injector/" title="Fluid 主题注入功能">官网</a> 查看。</p><p>然后上 GitHub 用户 <a href="https://github.com/PipecraftNet/jsdelivr-auto-fallback" title="PipecraftNet">PipecraftNet</a> 的仓库下载 <code>index.min.js</code> 或者 <code>index.js</code> 文件，或者直接复制里边的内容。这位大佬写了一个自动检测加速有没有用的脚本，会给自己的博客自动替换更好的 CDN 加速。</p><p>转到博客源文件根目录（也就是 source 目录），新建一个 js 文件夹，把下载的 <code>index.js</code> 文件放到里边，最好重命名。如果是直接复制内容，那就在 js 文件夹中新建一个扩展名为 <code>js</code> 的文件，把复制的内容粘贴到里边。</p><p>下面演示使用 axel 下载，并且重命名文件为 <code>change_cdn.js</code>。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> Documents/NotePages/source <span class="hljs-comment"># 转到源文件根目录</span><br>$ tree -L 1 <span class="hljs-comment"># 查看是否有 js 文件夹，没有就新建</span><br>.<br>├── about<br>├── _drafts<br>└── _posts<br><br>3 directories, 0 files<br>$ <span class="hljs-built_in">mkdir</span> js <span class="hljs-comment"># 新建 js 文件夹</span><br>$ tree -L 1<br>.<br>├── about<br>├── _drafts<br>├── js<br>└── _posts<br><br>4 directories, 0 files<br>$ <span class="hljs-built_in">cd</span> js<br>$ axel https://github.91chi.fun/https://raw.githubusercontent.com/PipecraftNet/jsdelivr-auto-fallback/main/index.js -o change_cdn.js<br></code></pre></div></td></tr></table></figure><p>下载完之后，转到 Hexo 博客根目录，在根目录下创建一个 <code>scripts</code> 文件夹，在里边创建一个名为 <code>insert.js</code> 的文件（文件名随便取）。将后面的代码复制到 <code>insert.js</code> 文件内。<code>src</code> 后面写的是刚刚下载的文件的文件名，我的是 <code>change_cdn.js</code>。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> ~/Documents/NotesPage<br>$ <span class="hljs-built_in">mkdir</span> scripts<br>$ vim scripts/insert.js<br><br>hexo.extend.injector.register(<span class="hljs-string">&#x27;head_begin&#x27;</span>, <span class="hljs-string">&#x27;&lt;script defer src=&quot;/js/change_cdn.js&quot;&gt;&lt;/script&gt;&#x27;</span>, <span class="hljs-string">&#x27;default&#x27;</span>);<br></code></pre></div></td></tr></table></figure><p>保存退出，完成脚本的注入了。</p><p>输入 <code>hexo clean &amp;&amp; hexo g -d</code> 进行博客部署，脚本会自己判断哪一个 CDN 更好用，然后自动修改。当然，这个只对博客的展示产生影响，不会直接修改你的博客内容。</p><h1 id="后语"><a href="#后语" class="headerlink" title="后语"></a>后语</h1><p>好像 <code>cdn.jsdelivr.net</code> 加速又可以访问了，其实已经卡了好几天了。</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图床</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么要捉弄ta...</title>
    <link href="/2022/05/19/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%8D%89%E5%BC%84ta/"/>
    <url>/2022/05/19/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%8D%89%E5%BC%84ta/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>相比欧亨利，契科夫的小说少有让我记住。现在记得最清楚，还是改变了我对契科夫看法的《捉弄》。《捉弄》是一篇非常短的小说，但是看完之后，你却希望它可以长一点。</p><p>今天先闲来无事，感觉可以搬过来分享。看完之后可以想想契科夫是不是又双叒叕讽刺了哪个黑暗的世界。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>那是深冬的一个正午，太阳高挂在天空，射出冷冰冰的光线……真是冷得很，树干被冻得崩裂而喀喀作响。卡娜佳挽着我的胳膊，她脸颊上金色的绒毛附着着薄薄的银霜。</p><p>我们俩站在一座高山上，脚下就是一片积雪的斜坡，在阳光下的照耀下，像镜子一样记录着遥远的璀璨，在我们身边放着一副小小的轻便雪橇，蒙着红色的天鹅绒布——这便是我记忆里那天开始的样子。</p><p>“卡娜佳！我们好不容易上来的，跟我滑一次吧，一切都准备好了。”我双手扶着她的肩膀央求她“就一次！我发誓，你和我都会完整无缺的，不会出意外的！”</p><p>我看得出娜佳还是怕极了，从她小小的个子往下俯瞰，雪坡就像一个深不可测的可怕地穴，时刻都要将她吞噬一般。我拉着她把她拉进雪橇，她往下看了一眼，狠狠地吸了一口冷气，噎在喉头。她真的要冒险飞向深渊吗？会有危险吗？想到这里，她吓死了，吓疯了。</p><p>“求你啦！”我又说，“用不着害怕！你要相信我，你只是缺少决心，别怕了！”</p><p>娜佳最后还是让步了，不过看她脸色我知道，她是抱着有可能死掉的危险做出让步的，我扶着她坐在小雪橇上，一手搂着这个小小个子脸色惨白、浑身打颤的姑娘，准备跟她一道跌入深渊。</p><p>雪橇像出了膛的子弹，滑开空气向深渊飞去，耳边的风怒吼着，凶狠的撕扯我们的衣帽，像刀割一样刺痛着我们的脸颊，像要一把将你肩头的脑袋揪下。在巨大的风压下，我们变得难以呼吸，就像恶魔紧紧的扼住了我们脖子，愤怒着叫嚷着要把我们拖入地狱。四周的景物汇成了一条长长的一闪而过的飘带……那时我只有一个念头，下一秒我们就要粉身碎骨了！</p><p>“我爱你，娜佳！”我小声说。</p><p>雪橇滑得越来越平缓，风的吼声和滑木的沙沙声已经不那么可怕了，呼吸也不再困难，我们终于滑到了山脚下。可是卡娜佳已经半死不活。她脸色煞白，奄奄一息……</p><p>我帮她站起身来。</p><p>“骗子，下一回说什么也不滑了，”她睁大一双布满恐惧的眼睛望着我说，“一辈子也不滑了！差点没把我吓死！一辈子也不信你了！”</p><p>过了一会，她渐渐缓过神，开始用一种试探怀疑的眼神看我，好像在说：那句话是我说的吗？或者仅仅是旋风的呼啸让她产生了幻听？虽然我看见了她的眼神，但我还是假装检查我的手套，站她身边若无其事的抽着烟。</p><p>她又挽起我的胳膊，我们在山下玩了很久。但那个谜显然搅得她心神不宁。他到底说了没说？说了还是没有？那句话是他说的吗？这些问题反复出现在她脑子里，这可太重要了，这事关她的自尊心、未来、生命和幸福的问题，是非常非常重要的问题，这世上第一等重要的问题！</p><p>卡娜佳不厌其烦地用那种忧郁、困惑、识图看穿我的眼神打量着我，除此之外什么也思考不了，胡乱回答着我的问题，等着我会不会再说出那句话，或者露出什么马脚。</p><p>唉，那张可爱的小脸呀，那表情是多么丰富，多么可怜！我看得出，她竭力控制住自己，想好好的质问一下我，问我有没有说那句话，但她找不到词句，怕是自己多情了，她别扭坏了，焦急的不行。</p><p>“那个，有个事情……”她说，眼睛没有看我。</p><p>“什么？”我问。</p><p>“让我们再……再滑一次雪橇。”</p><p>于是我们沿着阶梯拾级而上。我再一次扶着脸色苍白、浑身打颤的娜佳坐上雪橇，我们再一次飞向恐怖的深渊，再一次听到风的呼啸，滑木的沙沙声，而且在雪橇飞得最快、风声最大的时刻，我再一次小声说：</p><p>“我爱你，娜佳！”</p><p>雪橇终于停住，卡娜佳立即回头观看我们刚刚滑下来的山坡，随后久久地审视着我的脸，倾听着我那无动于衷、毫无热情的声音，于是她整个人，浑身上下，连她的皮手笼和围巾、帽子在内，无不流露出极度的困惑。她的脸上分明写着：</p><p>“怎么回事？那句话到底是谁说的？是他，还是我听错了？”</p><p>这个疑团弄得她心神不定，失去了耐心。可怜的姑娘不回答我的问话，愁眉苦 脸，眼看着就要哭出来了。</p><p>“我们是不是该回家了？”我故意问她。</p><p>“可是我……我喜欢这样滑雪，”她涨红着脸说，“我们再滑一次好吗？”</p><p>虽说她“喜欢”这样滑雪，可是，当她坐上雪橇时，跟前两次一样，她依旧脸色苍白，吓得透不过气来，浑身直打哆嗦。</p><p>我们第三次飞身滑下，我看到，她一直盯着我的脸，注视着我的嘴唇。可是我用围巾挡住嘴，咳嗽一声，正当我们滑到半山腰时，我又小声说了一句：</p><p>“我爱你，娜佳！”</p><p>结果谜依旧是谜！卡娜佳默默不语，想着心事……我从冰场把她送回家，她尽量不出声地走着，放慢脚步，一直期待着我会不会对她再说那句话。我看得出来，她的内心怎样受着煎熬，又怎样竭力克制自己，免得说出：</p><p>“这句话不可能是风说的！我也不希望是风说的！”</p><p>第二天上午，我收到一张便条：“如果您今天还去冰场，请顺便来叫我一声——娜。”从此以后，我和卡娜佳几乎天天都去滑雪。当我们坐着雪橇滑下坡时，每一次我总是小声说出那句话：</p><p>“我爱你，娜佳！”</p><p>很快卡娜佳对这句话就听上瘾了，就像人对喝酒、抽烟能上瘾一样。现在缺了这句话她就没法生活了。当然，从山顶上飞身滑下依旧令人胆战心惊，可是此刻的恐惧和危险，反给那句表白爱情的话平添一种特殊的魅力，尽管这句话依旧是个谜，依旧折磨着她的心。受到怀疑的依旧是我和风……这二者中究竟谁向她诉说了爱情，她不知道，但后来她显然已经不在乎了——只要喝醉了就成，管它用什么样的杯子喝的呢！</p><p>一天中午，我独自一人去了冰场。我混在拥挤的人群中，突然发现卡娜佳正朝山脚下走去，东张西望地在寻找我……后来她畏畏缩缩地顺着阶梯往上走……一个人滑下来是很可怕的，唉呀，可怕极了！她脸色白得像雪，战战兢兢地走着，倒像赴刑场一般，但还是走着，头也不回，坚决地走着。</p><p>她显然打定主意，最后要试一试，身边没有我的时候，还能不能听到那句美妙而甜蜜的话？ 我看到她脸色苍白，吓得张着嘴，坐上雪橇，闭上眼睛，像向人世告别似的滑下去……“沙沙沙”……滑木发出响声。我不知道卡娜佳是否听到了那句话，我只看到，她从雪橇上站起来时已经摇摇晃晃、有气无力了。看她的脸色可知，连她自己也不知道究竟听到什么没有，她一人滑下时的恐惧夺走了她的听觉，她已经丧失了辨别声音和理解的能力。</p><p>眼看着早春三月已经来临……阳光变得暖和起来。我们那座冰山渐渐发黑，失去了原有的光彩，最后冰雪都化了。我们也不再去滑雪。可怜的卡娜佳再也听不到那句话，何况也没人对她说了，因为这时已听不到风声，而我正要动身去彼得堡——要去很久，也许一去不复返了。</p><p>有一回，大约在我动身的前两天，薄暮中我坐在小花园里，这花园同娜佳居住的那个院子只隔着一道带钉子的高板墙……天气还相当冷，畜粪下面还有积雪，树木萧条，但已经透出春天的气息，一群白嘴鸦大声贴噪，忙着找旧枝宿夜。</p><p>我走到板墙跟前，从板缝里一直往里张望。我看到卡娜佳走出门来，站在台阶上，抬起悲凉伤感的目光望着天空……春风吹拂着她那苍白忧郁的脸……这风勾起她的回忆；昔日，在半山腰，正是在呼啸的风声中她听到了那句话。于是她的脸色变得越来越忧郁，两行眼泪夺眶而出……可怜的姑娘张开臂膀，似乎在央求春风再一次给 她送来那句话。我等着一阵风刮过去，小声说：</p><p>“我爱你，娜佳！”</p><p>我的天哪，卡娜佳一下子像换了一个人！她一声欢呼，笑开了脸，迎着风张开臂 膀，那么高兴，幸福，她真是美丽极了。</p><p>随后我走开了，回去收拾行装……</p><p>这已是很久以前的事了。如今卡娜佳已经出嫁。究竟是出于父母之命，还是她本人的意愿，如今已经无关紧要，她嫁给了贵族监护会的一名秘书，现在已经有了三个 孩子。想当年，我们一块儿滑雪，那风送到她耳畔一句话：</p><p>“我爱你，娜佳！”</p><p>这段回忆是永生难忘的。对她来说，这是一生中最幸福、最动人、最美好的回忆……</p><p>如今我也上了年纪，已经不明白，为什么当初我说了那句话，为什么要捉弄她…… </p><p>一八八六年三月十二日</p><h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><p>我一直觉得，男生和女生是两个矛盾体，就像磁铁的正负极，也许柏拉图是对的？看完《捉弄》，如果你也觉得有点短，我可以给你描绘描绘你捉弄的那个 Ta：</p><p>男生看：</p><blockquote><p>淑景斗清明，和风拂面轻。</p><p>小杯盘、同集郊坰。</p><p>著个簥儿不肯上，须索要、大家行。</p><p>行步渐轻盈。行行笑语频。</p><p>凤鞋儿、微褪些根。</p><p>忽地倚人陪笑道，真个是、脚儿疼。</p></blockquote><p>辛弃疾大佬的《唐(糖)多令》</p><p>女生看：</p><blockquote><p>昨夜海棠初着雨，数朵轻盈娇欲语。</p><p>佳人晓起出兰房，折来对镜比红妆。</p><p>问郎花好奴颜好，郎道不如花窈窕。</p><p>佳人见话发娇嗔，不信死花胜活人。</p><p>将花揉碎掷郎前，请郎今夜伴花眠。</p></blockquote><p>唐寅大佬的《妒花歌》。</p><p>东坡大佬《赏心十六事》镇文：</p><blockquote><p>清溪浅水行舟，微雨竹窗夜话。</p><p>暑至临溪濯足，雨后登楼看山。</p><p>柳荫堤畔闲行，花坞樽前微笑。</p><p>隔江山寺闻钟，月下东邻吹箫。</p><p>晨兴半柱茗香，午倦一方藤枕。</p><p>开瓮忽逢陶谢，接客不着衣冠。</p><p>乞得名花盛开，飞来家禽自语。</p><p>客至汲泉烹茶，抚琴听者知音。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>契科夫</tag>
      
      <tag>捉弄</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zettlr 编辑器部分功能优化——网页元素及时渲染</title>
    <link href="/2022/05/12/Zettlr-%E7%BC%96%E8%BE%91%E5%99%A8%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94%E7%BD%91%E9%A1%B5%E5%85%83%E7%B4%A0%E5%8F%8A%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    <url>/2022/05/12/Zettlr-%E7%BC%96%E8%BE%91%E5%99%A8%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94%E7%BD%91%E9%A1%B5%E5%85%83%E7%B4%A0%E5%8F%8A%E6%97%B6%E6%B8%B2%E6%9F%93/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><ruby>Zettlr<rt>&#x2F;ˈsetlər&#x2F;</rt></ruby> 服务的是写作者和科研工作者，这类受众通常不会使用花里胡哨的东西，所以 <a href="https://zettlr.com/" title="Zettlr">Zettlr</a> 减少了很多方面的扩展。举个例子，在 Zettlr 中使用 <ruby>HTML（超文本标记语言）<rt>HyperText Markup Language</rt></ruby>的标签不会得到渲染，你输入 <code>&lt;button&gt;这是一个按钮&lt;/button&gt;</code> ，它会原样输出。</p><p><img src="http://101.200.84.36/images/2022/05/12/202205122125084.png" alt="原生 Zettlr " title="原生 Zettlr "></p><p>写博客的时候时不时会使用到英文简写（一般不大适合使用中文），这时候我会给英文简写做个备注，比如把简写的原文写下。按理来说，原文应该使用括号写出，但是英文原文太长会影响排版，因此我会选择使用 <code>&lt;ruby&gt;</code> 标签把原文写在简写和中文的上方，减少页面占用。这种时候 Zettlr 不渲染就会显得比较难看。</p><p>因此很早之前我就考虑修改 Zettlr，自己渲染网页元素。可惜，我没接触过 <a href="https://www.electronjs.org/" title="Electron">Electron</a> 开发，不了解这种应用的基本运行框架，而 Zettlr 就是用 Electron 开发的。</p><p>前一阵子对 Zettlr 的部分功能进行了优化，感觉自己可以再试试，搞不好可以实现自己很久以来的想法。于是今天下午花了点时候，大概摸清 Zettlr 渲染的部分代码，然后就直接动手，想不到还真的让我这只瞎猫碰到了死耗子！</p><p>修改代码之后，现在自己编译的 Zettlr 已经可以渲染网页标签——还可以自定义标签，当然是在<ruby>资源管理<rt>Asset Manager</rt></ruby>中配置自定义的 <ruby>CSS（层叠样式表）<rt>Cascading Style Sheets</rt></ruby>。</p><p><img src="http://101.200.84.36/images/2022/05/12/202205122138784.png" alt="改造后的 Zettlr " title="改造后的 Zettlr "></p><h1 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h1><p>和上次的一样准备 Zettlr 源码，建议直接使用上一次的，免得还得把之前的修改放进来。要修改的文件位置在 Zettlr 源码根目录下的</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">source</span>/common/modules/markdown-editor/hooks/render-elements.ts<br></code></pre></div></td></tr></table></figure><p>使用你习惯的编辑器打开这个 TypeScripts 文件。</p><p>首先在开头从 <code>can-render-element</code> 文件引入 <code>canRenderElement</code> 函数。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">import canRenderElement from <span class="hljs-string">&#x27;../plugins/util/can-render-element&#x27;</span><br></code></pre></div></td></tr></table></figure><p><img src="http://101.200.84.36/images/2022/05/12/202205122141485.png" alt="引入需要的函数" title="引入需要的函数"></p><p>接下来在 <code>renderElements</code> 函数的最后调用 <code>renderElems</code> 函数，函数是我们要写的，所以不用担心。</p><p><img src="http://101.200.84.36/images/2022/05/12/202205122144351.png" alt="调用添加的渲染" title="调用添加的渲染"></p><p>在 <code>renderElememts</code> 上方写一个函数，叫做 <code>renderElems</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">// 这是我们的函数<br><span class="hljs-keyword">function</span> renderElems (cm: CodeMirror.Editor): void &#123;<br><br>  // 获取视图，里面包含编辑器的原始文本<br>  const viewport = cm.getViewport()<br>  // 按行读取文本<br>  <span class="hljs-keyword">for</span> (<span class="hljs-built_in">let</span> i = viewport.from; i &lt; viewport.to; i++) &#123;<br>  // 无关的内容不用渲染<br>    <span class="hljs-keyword">if</span> (cm.getModeAt(&#123; <span class="hljs-string">&#x27;line&#x27;</span>: i, <span class="hljs-string">&#x27;ch&#x27;</span>: 0 &#125;).name !== <span class="hljs-string">&#x27;markdown-zkn&#x27;</span>) <span class="hljs-built_in">continue</span><br><br>    const line = cm.getLine(i)<br>    // 正则表达式获取标签名和内容<br>    <span class="hljs-keyword">for</span>(const match of line.matchAll(/&lt;\b([^&gt;]+)&gt;(.*?)&lt;\/\1\b&gt;/g)) &#123;<br><br>      const curFrom = &#123; <span class="hljs-string">&#x27;line&#x27;</span>: i, <span class="hljs-string">&#x27;ch&#x27;</span>: match.index as number &#125;<br>      const curTo = &#123; <span class="hljs-string">&#x27;line&#x27;</span>: i, <span class="hljs-string">&#x27;ch&#x27;</span>: match.index as number + match[0].length &#125;<br>     // 判断是否该渲染。这里需要注意不能落下，因为当你的鼠标靠近标签的时候不该渲染<br>     <span class="hljs-keyword">if</span> (!canRenderElement(cm, curFrom, &#123; line: curTo.line, ch: curTo.ch + 1 &#125;)) &#123;<br>       <span class="hljs-built_in">continue</span><br>     &#125;<br><br>      // 通过标签名创造一个标签<br>      const tag = document.createElement(match[1])<br>      tag.innerHTML = match[2];<br><br>      // 这个用于用于标记标签元素是否该被渲染<br>      const marker = cm.markText(<br>        curFrom, curTo, &#123;<br>          <span class="hljs-string">&#x27;clearOnEnter&#x27;</span>: <span class="hljs-literal">true</span>,<br>          <span class="hljs-string">&#x27;replacedWith&#x27;</span>: tag,<br>          <span class="hljs-string">&#x27;inclusiveLeft&#x27;</span>: <span class="hljs-literal">false</span>,<br>          <span class="hljs-string">&#x27;inclusiveRight&#x27;</span>: <span class="hljs-literal">false</span><br>         &#125;)<br>      // 因为已经渲染了标签，所以广播编辑器修改元素所占的位置<br>      marker.changed() // Notify CodeMirror of the potentially updated size<br> <br>      // 如果鼠标点击，或者光标靠近标签，就清除渲染的标签，回归原来的状态<br>      tag.onclick = (e) =&gt; &#123;<br>        marker.clear()<br>        cm.setCursor(cm.coordsChar(&#123; left: e.clientX, top: e.clientY &#125;))<br>        cm.focus()<br>       &#125;<br>     &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment"># 下面是原有的 renderElements 函数</span><br><span class="hljs-keyword">function</span> renderElements (cm: CodeMirror.Editor): void &#123;<br>...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>现在只需要重新编译就可以实现网页标签的渲染了，上一篇博客介绍过怎么编译。</p><h1 id="后语"><a href="#后语" class="headerlink" title="后语"></a>后语</h1><p>修改完 Zettlr 之后，我如愿彻底离开 Typora 了。不过说来，Typora 在 Manjaro 居然有 200M 以上，远比 Zettlr（112M）大。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zettlr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zettlr 编辑器部分功能优化</title>
    <link href="/2022/05/10/Zettlr-%E7%BC%96%E8%BE%91%E5%99%A8%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2022/05/10/Zettlr-%E7%BC%96%E8%BE%91%E5%99%A8%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为 Zettlr 编辑器支持在 Markdown 下的文献引用，自己逐步从 Tyopra 转向 Zettlr。和 Tyopra 比，Zettlr 的体验确实不是很好。此外，Zettlr 还存在图片默认左对齐、文章字数统计对中英文支持不好等问题。</p><p><img src="http://101.200.84.36/images/2022/05/09/202205100936007.png" alt="图片左对齐，中英文（右上角）混合统计有问题。按理来说统计有 4 千字，这里的统计接近 8 千字。" title="图片左对齐，中英文（右上角）混合统计有问题。按理来说统计有 4 千字，这里的统计接近 8 千字。"></p><p>我希望的是图片可以默认居中对齐，然后中英文混输的字数统计可以准确一点。前者可以通过自定义 <ruby>CSS（层叠样式表）<rt>Cascading Style Sheets</rt></ruby> 进行修改，后者只能修改源码了。</p><p><img src="http://101.200.84.36/images/2022/05/09/202205100942279.png" alt="修改后的效果" title="修改后的效果"></p><p>既然要修改源码，索性一并修改 <ruby>CSS（层叠样式表）<rt>Cascading Style Sheets</rt></ruby> 的源码。因此这就是接下来的工作。接下来的修改在 Zettlr 2.2.5 和 2.2.6（最新版） 版本都是通用的。以后的版本可能在代码上有所不同，但本修改应该仍然起作用。由于是自己修改源码，每次发布新版的时候都需要手动修改。一个好的解决办法是给 GitHub 上的维护着提个 issue 或者直接拉取分支和人家一起干（这不是我该干的）。</p><h1 id="开工"><a href="#开工" class="headerlink" title="开工"></a>开工</h1><p>开始之后需要你的电脑安装这几样东西：</p><ol><li><a href="https://nodejs.cn/" title="Node.js">Node.js</a>，让 JavaScript 脱离浏览器。版本什么其实不重要，不要太旧就行。Linux 发行版一般可以通过命令行安装，例如我的 Manjaro ：<code>sudo pacman -S nodejs --noconfirm</code>。</li><li><a href="https://www.yarnpkg.cn/" title="Yarn">Yarn</a>，JavaScript 软管理包，用于拉取源码所需的各个包。Linux 发行版一般可以通过命令行安装，例如我的 Manjaro：<code>sudo pacman -S yarn --noconfirm</code>。</li><li><a href="https://git-scm.com/" title="Git">Git</a>，分布式版本管理系统，用于从 GitHub 拉取 Zettlr 源码。这个是可选的——因为可以直接从 GitHub 上下载源码，不一定通过 Git 拉取。</li></ol><p>Windows 系统需要到官网下载，当然，如果你使用 <a href="https://chocolatey.org/" title="Chocolatey">Chocolatey</a> 等 Windows 下的包管理器的话也可以选择直接使用这个管理器下载——据我所知，这个包管理器现在已经包含了许多的软件。</p><h2 id="获取-Zettlr-源码"><a href="#获取-Zettlr-源码" class="headerlink" title="获取 Zettlr 源码"></a>获取 Zettlr 源码</h2><p>获取 Zettlr 源码有两种方式，分别是 Git 拉取和 GitHub 直接下载。</p><ol><li>Git 拉取。</li></ol><p>首先创建一个文件夹用于保存 Zettlr 源码，随便取个名字，这里就叫做 Shr2hst。进入文件夹中，并通过<ruby>克隆<rt>clone</rt></ruby>指令拉取源码。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">mkdir</span> ~/Shr2hst &amp;&amp; <span class="hljs-built_in">cd</span> ~/Shr2hst<br>$ git <span class="hljs-built_in">clone</span> https://github.com/zettlr/zettlr<br>Cloning into <span class="hljs-string">&#x27;zettlr&#x27;</span>...<br>remote: Enumerating objects: 47557, <span class="hljs-keyword">done</span>.<br>remote: Counting objects: 100% (3/3), <span class="hljs-keyword">done</span>.<br>remote: Compressing objects: 100% (3/3), <span class="hljs-keyword">done</span>.<br>remote: Total 47557 (delta 0), reused 0 (delta 0), pack-reused 47554<br>Receiving objects: 100% (47557/47557), 105.81 MiB | 1.88 MiB/s, <span class="hljs-keyword">done</span>.<br>Resolving deltas: 100% (36147/36147), <span class="hljs-keyword">done</span>.<br>$ <span class="hljs-built_in">ls</span><br>zettlr<br>$ <span class="hljs-built_in">cd</span> zettlr<br>$ <span class="hljs-built_in">ls</span><br>CHANGELOG.md          forge.config.js  scripts      tsconfig.json<br>CITATION.cff          LICENSE          SECURITY.md  webpack.main.config.js<br>CODE_OF_CONDUCT.md    package.json     <span class="hljs-built_in">source</span>       webpack.renderer.config.js<br>CONTRIBUTING.md       README.md        static       webpack.rules.js<br>electron-builder.yml  resources        <span class="hljs-built_in">test</span>         yarn.lock<br></code></pre></div></td></tr></table></figure><p>这个操作一般会比较慢——国内一直比较慢，所以需要耐心。进入 Zettlr 文件夹之后可以看到许多的文件，其中 source 文件夹就是我们的源码所在的位置。</p><ol start="2"><li>GitHub 下载压缩包。</li></ol><p>打开浏览器，输入 <code>https://github.com/zettlr/zettlr</code> 进入 GitHub 界面，选择 Code 中的 Download ZIP 进行下载。</p><p><img src="http://101.200.84.36/images/2022/05/09/202205101008484.png"></p><p>下载完成之后可以进行解压。在 Windows ，随便使用一个压缩软件就可以解压。在 Linux 中可以使用 unzip 命令解压，效果如下。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ unzip Zettlr-develop.zip<br>$ <span class="hljs-built_in">ls</span><br>Zettlr-develop  Zettlr-develop.zip<br>$ <span class="hljs-built_in">cd</span> Zettlr-develop<br>$ <span class="hljs-built_in">ls</span><br>CHANGELOG.md          forge.config.js  scripts      tsconfig.json<br>CITATION.cff          LICENSE          SECURITY.md  webpack.main.config.js<br>CODE_OF_CONDUCT.md    package.json     <span class="hljs-built_in">source</span>       webpack.renderer.config.js<br>CONTRIBUTING.md       README.md        static       webpack.rules.js<br>electron-builder.yml  resources        <span class="hljs-built_in">test</span>         yarn.lock<br></code></pre></div></td></tr></table></figure><h2 id="字数统计"><a href="#字数统计" class="headerlink" title="字数统计"></a>字数统计</h2><p>首先修改我们的最初目标中英文混合的字数统计。这是一个 TypeScript 文件，位于 source&#x2F;common&#x2F;util&#x2F;count-words.ts。</p><p>Windows 用户，建议通过文件管理找到这个文件，然后使用你喜欢的编辑器打开。<br>Linux 用户可以在命令行上输入 <code>vim source/common/util/count-words.ts</code> 直接打开文件进行修改。</p><p>转到最后一行，把 44 到49 行的代码删掉或注释掉，在后面添加以下代码。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">content = content.replace(/(\r\n+|\s+| +)/g, <span class="hljs-string">&quot;𰻝&quot;</span>);<br>content = content.replace(/[\x00-\xff]/g, <span class="hljs-string">&quot;w&quot;</span>);<br>content = content.replace(/w+/g, <span class="hljs-string">&quot;*&quot;</span>);<br>content = content.replace(/𰻝+/g, <span class="hljs-string">&quot;&quot;</span>);<br></code></pre></div></td></tr></table></figure><p><img src="http://101.200.84.36/images/2022/05/09/202205101026625.png" alt="未更改" title="未更改"></p><p><img src="http://101.200.84.36/images/2022/05/09/202205101030724.png" alt="更改后" title="更改后"></p><p>保存退出。这几行代码的统计方式虽然原始，但是十分高效——和 Word、WPS Word 的统计基本是一样的。代码里的“<ruby>𰻝<rt>biáng</rt></ruby>”字如果打不出来可以使用其他生僻字代替，例如“ <ruby>龘<rt>dá</rt></ruby>”“ <ruby>爨<rt>cuàn</rt></ruby>”“<ruby>厶<rt>sī</rt></ruby>”“ <ruby>鬱<rt>yù</rt></ruby>”“<ruby>𣊧<rt>lǎng</rt></ruby>”等等。其实上面的统计很简单，大概意思是：先将空格符、回车符、换行符换成一个生僻字，然后将拉丁字母替换成 w ，在把以生僻字隔离的一个至多个 w 替换成 * ，然后减去生僻字就是所有的字数了。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 举个例子，看下面的文字</span><br>我 Wǒ 是 shì 爱 aì 南 nán 开 kāi 的 de 。<br>俺也一样。<br><span class="hljs-comment"># 替换后</span><br>我𰻝Wǒ𰻝是𰻝shì𰻝爱𰻝aì𰻝南𰻝nán𰻝开𰻝kāi𰻝的𰻝de𰻝。𰻝俺也一样。𰻝<br><span class="hljs-comment"># 替换拉丁字母</span><br>我𰻝ww𰻝是𰻝www𰻝爱𰻝ww𰻝南𰻝www𰻝开𰻝www𰻝的𰻝w𰻝。𰻝俺也一样。𰻝<br><span class="hljs-comment"># 去掉拉丁字母</span><br>我𰻝*𰻝是𰻝*𰻝爱𰻝*𰻝南𰻝*𰻝开𰻝*𰻝的𰻝*𰻝。𰻝俺也一样。𰻝<br><span class="hljs-comment"># 去掉生僻字</span><br><span class="hljs-comment"># 1 2 3  4 5 6 7 8 9 10 11 12 13 14 15 16 17 18</span><br> 我 * 是 * 爱* 南* 开*  的 *  。 俺 也 一 样 。 <br></code></pre></div></td></tr></table></figure><p><img src="http://101.200.84.36/images/2022/05/10/202205101207897.png" alt="以防出现方框"></p><h2 id="图片居中"><a href="#图片居中" class="headerlink" title="图片居中"></a>图片居中</h2><p>图片居中的源码位于 source&#x2F;common&#x2F;modules&#x2F;markdown-editor&#x2F;editor.less 文件中，使用任意文本编辑器打开。转到 217 行——或者慢慢找也行。在 figture 里边的 img 添加 <code>margin: 0 auto;</code>，表示居中对齐。保存退出。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ vim <span class="hljs-built_in">source</span>/common/modules/markdown-editor/editor.less<br></code></pre></div></td></tr></table></figure><p><img src="http://101.200.84.36/images/2022/05/09/202205101049346.png" alt="未修改" title="未修改"></p><p><img src="http://101.200.84.36/images/2022/05/09/202205101050726.png" alt="修改后" title="修改后"></p><p>这一部分是前端知识，知道这么回事就行。</p><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>编译之前下载依赖包，执行一下命令。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ yarn install --frozen-lockfile<br></code></pre></div></td></tr></table></figure><p>确认安装完依赖包之后就可以进行编译。</p><p>编译选项包括：</p><ul><li><code>package:mac-x64</code> (Intel-based Macs)</li><li><code>package:mac-arm</code> (Apple Silicon-based Macs)</li><li><code>package:win-x64</code> (Intel-based Windows)</li><li><code>package:win-arm</code> (ARM-based Windows)</li><li><code>package:linux-x64</code> (Intel-based Linux)</li><li><code>package:linux-arm</code> (ARM-based Linux)</li></ul><p>如果不知道自己的系统是啥构架，直接使用 <code>yarn package</code> 就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ yarn package:linux-x64 <span class="hljs-comment"># 这个是编译 Linux 的包</span><br>✔ Checking your system<br>✔ Preparing native dependencies<br>✔ Compiling Main Process Code<br>✔ Compiling Renderer Template<br>✔ Compiling Renderer Preload: main_window<br>✔ Compiling Renderer Preload: <span class="hljs-built_in">print</span><br>✔ Compiling Renderer Preload: log_viewer<br>✔ Compiling Renderer Preload: quicklook<br>✔ Compiling Renderer Preload: preferences<br>✔ Compiling Renderer Preload: tag_manager<br>✔ Compiling Renderer Preload: paste_image<br>✔ Compiling Renderer Preload: error<br>✔ Compiling Renderer Preload: about<br>✔ Compiling Renderer Preload: stats<br>✔ Compiling Renderer Preload: assets<br>✔ Compiling Renderer Preload: update<br>✔ Compiling Renderer Preload: project_properties<br>✔ Preparing to Package Application <span class="hljs-keyword">for</span> <span class="hljs-built_in">arch</span>: x64<br>✔ Preparing native dependencies<br>✔ Packaging Application<br>Done <span class="hljs-keyword">in</span> 236.96s.<br></code></pre></div></td></tr></table></figure><p>编译完成，接下来就是打包。</p><p>打包选项包括：</p><ul><li><code>release:mac-x64</code> (Intel-based Macs)</li><li><code>release:mac-arm</code> (Apple Silicon-based Macs)</li><li><code>release:win-x64</code> (Intel-based Windows)</li><li><code>release:win-arm</code> (ARM-based Windows)</li><li><code>release:linux-x64</code> (Intel-based Linux)</li><li><code>release:linux-arm</code> (ARM-based Linux)</li></ul><p>Linux 系统打包会生成多个安装包，如 deb、rpm、zip 和 Appimage。这个过程可能还会失败。由于 Appimage 包是公用包，几乎所有的 Linux 系统都可以使用，所以我建议按照这个来打包。好处是通用、简单，缺点是有点大。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ yarn release:linux-x64 <span class="hljs-comment"># 生成所有预定义的包</span><br>$ yarn electron-builder --linux AppImage --x64 --publish never --prepackaged out/Zettlr-linux-x64 <span class="hljs-comment"># 只生成 Appimage包</span><br>  • electron-builder  version=23.0.3 os=5.15.32-1-MANJARO<br>  • loaded configuration  file=/root/Shr2hst/zettlr/electron-builder.yml<br>  • writing effective config  file=release/builder-effective-config.yaml<br>  • building        target=AppImage <span class="hljs-built_in">arch</span>=x64 file=release/Zettlr-2.2.6-x86_64.AppImage<br>Done <span class="hljs-keyword">in</span> 8.78s.<br></code></pre></div></td></tr></table></figure><p>打包完成后，所有的包都在 Zettlr 根目录下的 release 文件夹中。Windows 系统可以直接运行安装。Linux 系统的 Appimage 包还有点事要做。</p><h1 id="Appimage-包"><a href="#Appimage-包" class="headerlink" title="Appimage 包"></a>Appimage 包</h1><p>首先赋予 Appimage 包可执行权限。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">chmod</span> u+x Zettlr-2.2.6-x86_64.AppImage<br>$ <span class="hljs-built_in">mkdir</span> -p ~/.local/bin/<br>$ <span class="hljs-built_in">cp</span> Zettlr-2.2.6-x86_64.AppImage ~/.local/bin/<br>$ <span class="hljs-built_in">ln</span> -s ~/.local/bin/Zettlr-2.2.6-x86_64.AppImage  ~/.local/bin/zettlr<br>$ ./Zettlr-2.2.6-x86_64.AppImage --appimage-extract<br>$ <span class="hljs-built_in">mkdir</span> -p ~/.local/share/applications/<br>$ <span class="hljs-built_in">mkdir</span> -p ~/.local/share/icons/<br>$ <span class="hljs-built_in">cp</span> squashfs-root/zettlr.desktop ~/.local/share/applications/<br>$ <span class="hljs-built_in">cp</span> squashfs-root/zettlr.png ~/.locals/share/icons/<br>$ <span class="hljs-built_in">rm</span> -rf squashfs-root<br></code></pre></div></td></tr></table></figure><p>输入 <code>vim ~/.local/share/appications/zettlr.desktop</code> 修改 </p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">Exec=AppRun --no-sandbox %U<br></code></pre></div></td></tr></table></figure><p>为</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">Exec=zettlr --no-sandbox %U<br></code></pre></div></td></tr></table></figure><p>保存退出。至此，Zettlr Appimage 已经按转完毕，可以直接从桌面启动了。如果是 Windows 就没有这么多的麻烦。</p><p>Zettlr 的源码可以删掉也可以保留——爱咋咋地。如果想给 Zettlr 添加功能的话可以自己在源码的基础上修改，我对 Zettlr 还是挺满意的。</p><h1 id="后语"><a href="#后语" class="headerlink" title="后语"></a>后语</h1><p>这篇博客无非就是记录一下自己修改的 Zettlr 的经历（虽然只是改了一丢丢）。这里可以谈谈使用 Manjaro 发现的问题。</p><p>记得在写安装常用软件教程的时候我说过自己的 Manjaro 使用不了 Flameshot 截图软件，其实还包括 Shutter、Deepin-screenshot、Wemeet 等等软件。后两者存在的问题是：可以正常使用，但是截图截的是黑屏、共享的也是黑屏。不信邪的我源码编译了 Flameshot，结果发现还是一样无法使用。</p><p>最近转念一想：好家伙，原来是 GNOME 4.1 之后的窗口系统后端默认是 Wayland。Wayland 是新生代，有天然的优势，但很多软件都没有支持，所以录屏、截屏甚至共享屏幕都使用的 X11 的接口，这自然就出现黑屏。</p><p>GNOME 也考虑到这一点，所以在用户登陆界面的右下角提供了一个后端选择选项，就是一个齿轮模样。其中的选项：</p><ul><li>GNOME，表示默认使用 Wayland 后端。</li><li>GNOME Classic，是经典的 GNOME 后端，不启用各种插件。</li><li>GNOME Xorg，启用 X11 后端。</li></ul><p>启用 X11 虽然可以使用我上面提到的软件，但是我发现它不像 Wayland 默认支持<ruby>触摸板手势<rt>Touchpad Gestures</rt></ruby>。这个应该可以通过安装 GNOME Shell <ruby>插件<rt>Extensions</rt></ruby> X11 Gestures 支持操作。反正现在我还是安于 Wayland 后端。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zettlr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>极简 VIM 入门</title>
    <link href="/2022/05/09/%E6%9E%81%E7%AE%80-VIM-%E5%85%A5%E9%97%A8/"/>
    <url>/2022/05/09/%E6%9E%81%E7%AE%80-VIM-%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><ruby>VIM<rt>&#x2F;vɪm&#x2F;</rt></ruby> 是一个古老的编辑器。有人听说这个编辑器可以脱离鼠标、完全依赖键盘操作之后，会好奇地上各种社交、知识问答类网站询问这款编辑器如何。他们通常会得到这样的回答：学习曲线非常陡峭，但学好之后效率非常。  </p><p>听到这样的回答，有些新手就开始退缩，而有些人觉得这值得挑战，选择继续练习。于是他们会跑到网上查看相关的 VIM 教程，写教程的人基本都是用过 VIM 或者从不同地方复制过各类教程引流，所以他们上来就先要把这个初学者镇住，以展现自己丰富的知识和 VIM 经验。请看 VIM 的快捷键：</p><p><img src="http://101.200.84.36/images/2022/05/09/202205091902478.gif" alt="基础操作"></p><p><img src="http://101.200.84.36/images/2022/05/09/202205091902865.png" alt="进阶操作"></p><p>就这样，一个初学者还没有入门，基本就被劝退了。这就好比，刚学英语的时候被告知“英语至少有 25 万个单词，历史上堆积的甚至超过 40 万个，一个人一辈子大约 8 万天，要背完所有的单词至少每天记住 5 个单词”，我相信就是丘吉尔也觉得活着好累。所以学 VIM 的时候，要想退出很简单 —— 找个大佬，让他教你，他基本会把你劝退，因为他大概率上来就是一个快捷键图。</p><p>秉承着劝退新手的使命，我今天也来讲讲如何学习 VIM。</p><h1 id="VIM-入门"><a href="#VIM-入门" class="headerlink" title="VIM 入门"></a>VIM 入门</h1><p>VIM 能够靠键盘操作，其实和它的“语言”有关。想要使用这个编辑器，最简单的方法就是学习它的语言。别吐嘈自己英文不好，VIM 的语法就是“动词 + 名词”这么简单。下面我会分两个部分介绍 VIM：工作模式和语法。工作模式是最基本的概念，如果使用过 VIM，可以直接跳过这一部分。</p><h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h2><p>VIM 有四种工作模式：</p><ol><li><ruby>普通模式<rt>Normal Mode</rt></ruby>（正常模式），这是进入 VIM 后默认的模式，也是其余模式工作的前提。想要进入这个模式很简单：按 <kbd>Esc</kbd> 键即可。</li><li><ruby>插入模式<rt>Insert Mode</rt></ruby>，普罗大众眼中编辑器的默认模式。这种模式就是打字时的模式，许多编辑器的默认模式就是这个。</li><li><ruby>命令（行）模式<rt>Command Mode</rt></ruby>，这个模式基本用于批量处理和查找、替换，通过输入命令完成操作。</li><li><ruby>可视（化）模式<rt>Visual Mode</rt></ruby>，其实就是选择模式。由于 VIM 是键盘操作，所以进行多行选择的时候我们不能通过鼠标操作，这时候就需要借助可视模式。如果你不知道什么叫做多行操作的话，非常好 —— 这说明这个模式你基本用不到。</li></ol><p>如果使用 Windows 系统，我还是建议不要靠近 VIM，因为你基本不可能习惯键盘操作。在使用 VIM 之前，我建议在家目录下的 VIM 配置文件 .vimrc 后面添加一些配置。具体使用是：复制下面的设置，在命令行上输入 <code>vim ~/.vimrc</code>，回车进入 VIM，输入 <kbd>Shift</kbd>+<kbd>g</kbd>，然后 <kbd>o</kbd>，<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>v</kbd> 粘贴。按 <kbd>Esc</kbd> ，输入 <code>:wq</code>，回车。</p><p>添加这个配置是修改 VIM 的 <ruby>状态栏<rt>statusline</rt></ruby>，以便后面学习。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> report=0<br><span class="hljs-built_in">set</span> laststatus=2<br><span class="hljs-built_in">set</span> statusline=%&lt;%F%m%r%h%=%(%&#123;&amp;fileformat&#125;\ %&#123;&amp;encoding&#125;\ %c,%l\ %p%%%)<br></code></pre></div></td></tr></table></figure><h3 id="普通模式"><a href="#普通模式" class="headerlink" title="普通模式"></a>普通模式</h3><p>普通模式需要记住的操作比较少，记住 —— 普通模式是不可以修改文件和输入内容的！VIM 的普通模式主要用于移动鼠标和视图。很多人习惯使用键盘上的箭头键，但是 VIM 使用的是 <kbd>h</kbd>、 <kbd>j</kbd>、<kbd>k</kbd>、<kbd>l</kbd> 表示左、下、上、右。为什么这么奇葩？因为上古时代的键盘就是这样的（请看下图），那个时候的编辑器还叫 VI （VIM 是 VI 的增强版，VI Improved）。此外，看一下下面键盘的 <kbd>Esc</kbd> 键是在 <kbd>Q</kbd> 左边，所以那个时候按退出键比现在简单。记住这些就可以了。</p><p><img src="http://101.200.84.36/images/2022/05/09/202205091946872.jpg" alt="上古时代的键盘"></p><h3 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h3><p>插入模式是从普通模式转换。先见过插入命令：</p><ol><li>i，insert 的第一个字母，表示在光标之前插入；I，insert 大写的第一个字母，表示在这一行的最开始插入。</li><li>a，append 的第一个字母，表示在光标之后插入；A，append 大写的第一个字母，表示在这一行的最后插入。</li><li>o，没有对应的英文，表示在光标下一行插入空白行并转到下一行；O，无对应英文，表示在光标上一行添加空白行并撞到上一行。</li><li>s，substitute 的第一个字母，表示删除光标下的字母并进入插入模式，即替换；S，substitute 大写的第一个字母，表示替换光标所在行。</li></ol><p>现在打开一个文件，像我一样通过 <kbd>h</kbd>、<kbd>j</kbd> 、<kbd>k</kbd>、<kbd>l</kbd> 随便选取一个位置。</p><p><img src="http://101.200.84.36/images/2022/05/09/202205091956771.png" alt="移动到指定位置"><br>现在我在 not 之前插入字符，那就把光标移动到 n 上，然后按 <kbd>i</kbd> 键，输入字符，效果如下：</p><p><img src="http://101.200.84.36/images/2022/05/09/202205092009991.png" alt="输入 you"><br>可以看到，这时候已经进入插入模式，所以左下角有一个“– INSERT –” 标志。其余的命令可以自己尝试。</p><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>要进入命令模式先进入普通模式：按 <kbd>Esc</kbd> 。命令模式其实就是普通模式加命令。命令模式的命令以冒号（:）开头，请在输入的时候注意左下角会出现命令 —— 冒号需要打出来。</p><p><img src="http://101.200.84.36/images/2022/05/09/202205092015997.png" alt="命令模式"></p><p>我们需要记住的命令有：</p><ol><li><code>:q!</code>回车，退出文件不保存。在普通模式下直接输入该命令。<code>q</code> 是 quit 单词的缩写。<code>!</code> 表示否定，即不保存。</li><li><code>:wq</code>回车，保存并退出。<code>w</code> 是 write 的缩写。 VIM 编辑器打开文件的时候会生成一个 swap 文件，我们的操作都在这个文件，所有操作不会影响原来的文件。如果想要保存，那就把 swap 文件的内容<ruby>写到<rt>write</rt></ruby>原文件，所以使用的是 write 而不是 save。<code>w</code> 也可以单独使用。</li><li><code>:s/old/new/</code>回车，替换。<code>s</code> 是 substitute 的缩写。这个操作只会影响光标所在行的第一个匹配项。不常用，经常使用的是全局替换 <code>:%s/old/new/g</code> 。<code>%</code> 表示所有行，<code>g</code> 是 globally 的缩写。<code>old</code> 是想要替换的字符串，<code>new</code> 是替换后的字符串。</li></ol><p>记住这些就行了。第三个命令甚至不用记住 —— 因为一般人不会使用全局替换。</p><h3 id="可视模式"><a href="#可视模式" class="headerlink" title="可视模式"></a>可视模式</h3><p>这个用于选择。在其他编辑器中，我们都是使用鼠标选择，然后滚动滚轮进行选择，在 VIM 中选择需要进入可视模式。进入可视模式之前先确认自己在普通模式：按 <kbd>Esc</kbd> 。进入可视模式的命令有两个：</p><ol><li>v，visual 的缩写，通常称为行可视化，进行行选择。</li><li>V，visual 的大写缩写，通常称为块可视化，进行块选择。</li></ol><p>比如下面，我要选择第二第三行，使用行可视化，会看到左下角有 “– VISUAL –”的标志。然后通过 <kbd>h</kbd>、<kbd>j</kbd> 、<kbd>k</kbd>、<kbd>l</kbd> 进行选择。这里使用 <kbd>j</kbd> 向下选择。选择完之后可以按 <kbd>Esc</kbd> 退出。因为还没有教其他操作，所以这里先不进行其他操作。</p><p><img src="http://101.200.84.36/images/2022/05/09/202205092026991.png" alt="选择第二第三行"></p><p><img src="http://101.200.84.36/images/2022/05/09/202205092029374.png" alt="进入可视模式"></p><p><img src="http://101.200.84.36/images/2022/05/09/202205092030765.png" alt="按 j 进行向下选择" title="按 j 进行向下选择"></p><p>下面来看块模式。块模式通常用于插入和删除。比如我要在第一第二第三行之前插入我的大名：光标移动到第一行的第一个字符， <kbd>Shift</kbd>+<kbd>v</kbd>（也就是大写 V），把光标往下移动到第三行，输入 <kbd>Shift</kbd>+<kbd>i</kbd>，然后输入 chunshuyumao —— 注意，这时候只有第一行出现了 chunshuyumao，接下来连按两次 <kbd>Esc</kbd> ，完成。</p><p><img src="http://101.200.84.36/images/2022/05/09/202205092035400.png" alt="Shift + i，输入 chunshuyumao"></p><p><img src="http://101.200.84.36/images/2022/05/09/202205092038342.png" alt="按两次 Esc 键"></p><p>到这里，最基础的部分就讲完了。开始学习语法部分。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>VIM 的语法主要是“动词 [+ 介词] + 名词”。介词一般可以省略，但是我下面不会省略介词。</p><p>介绍几个常用的动词：</p><ol><li>d，delete 的缩写，用于删除。</li><li>y，yank 的缩写，用于复制。这个比较奇葩，因为复制我们都认为是 copy，可是 VIM 用 yank（拖拽）表示复制。</li><li>c，change 的缩写，用于修改。</li><li>p，paste 的缩写，用于粘贴。</li><li>v，visual select 的缩写，用于选择。我们已经见过了，其实就是可视化。</li><li>r，replace 的缩写，用于替换。</li><li>x，无对应单词，用于删除光标下的单个字符，但是不会进入插入模式。</li></ol><p>第 6 个动词用处不是很大，因为它一般用于修改单个字符；第 7 个只是用于删除单个字符。</p><p>名词有：</p><ol><li>w，word 的缩写，表示一个字。</li><li>s，sentence 的缩写，表示一个句子。</li><li>p，paragraph 的缩写，表示一个段落。</li></ol><p>介词有：</p><ol><li>i，inside 的缩写，表示在……内部。</li><li>a，around 的缩写，表示在……之外。</li><li>t，to 的缩写，表示到……之前（不包括该字符），数学表达：左闭开 [   )。</li><li>f，forward 的缩写，表示到……之前（包括该字符），数学表达：左闭右闭 [ ]。 t 和 f 比较难以理解，其实就是一个包含于不包含的关系。</li></ol><p>所有的操作都要在普通模式下进行，所以请确认你按了 <kbd>Esc</kbd> 键。</p><h3 id="动词-介词-名词"><a href="#动词-介词-名词" class="headerlink" title="动词 + 介词 + 名词"></a>动词 + 介词 + 名词</h3><p>看下图，我现在要删除 important —— delete inside word，缩写就是 diw。使用 inside ，是因为我们的光标在这个单词之内。</p><p><img src="http://101.200.84.36/images/2022/05/09/202205092057496.png" alt="删除之前" title="删除之前"></p><p><img src="http://101.200.84.36/images/2022/05/09/202205092059060.png" alt="删除之后"></p><p>删除之后，我们发现 more 和 than 之间的空格有点大，因为 important 被删，空格变成了两个。如果我们想要把空格也删掉，可以在删除 important 的时候使用 delete around word（也就是 daw)。如下：</p><p><img src="http://101.200.84.36/images/2022/05/09/202205092103676.png" alt="把单词和空格一起删掉" title="把单词和空格一起删掉"></p><p>同理，想要删掉一个句子，使用 delete inside sentence（dis）或者 delete around sentence（das）。还有删除段落: delete inside paragraph（dip）和 delete around paragraph（dap）。</p><h4 id="冷语法"><a href="#冷语法" class="headerlink" title="冷语法"></a>冷语法</h4><p>除了上面的名词，搞编程的同学可能会碰到这样的问题：删除 main 函数的内容 —— 但是不删除括号。如下，我们需要做的就是 delete inside {（dt{），结果如下：</p><p><img src="http://101.200.84.36/images/2022/05/09/202205092207065.png" alt="删除 main 函数花括号内的内容"></p><p><img src="http://101.200.84.36/images/2022/05/09/202205092210408.png" alt="效果"></p><p>如果想要把花括号也给删了，那就使用 delete around {（da{）。这个 { 可以改成任何符号，例如 [、( 等等。如果遇到网页使用的<ruby>标签<rt>tag</rt></ruby>，可以使用 t 代替，例如我上面的 <code>&lt;img&gt;</code> 标签，我想删掉标签 <code>&lt;img&gt;</code> 内的内容就使用 delete inside tag（dit），删除内容和标签就使用 delete around tag（dat)。</p><h3 id="动词-数量词-介词-名词"><a href="#动词-数量词-介词-名词" class="headerlink" title="动词 + 数量词 + 介词 + 名词"></a>动词 + 数量词 + 介词 + 名词</h3><p>如果我想删除两个单词呢？删除两个单词用英语怎么说：delete 2 inside word（d2iw）或者 delete 2 around word（d2aw）。注意，如果你使用 inside ，空格也会被当作一个单词，所以建议使用 around。</p><p>删除两行？delete 2 inside paragraph（d2ip）或者 delete 2 around paragraph。</p><p>修改单词：change inside word（ciw）或者change around word（caw）；修改两个单词：change 2 inseide word（c2iw）或者 change 2 around word（c2aw）。</p><p>上面的介词都可以省略 —— 注意，省略的后果是：不论是句子、单词还是段落，编辑器默认从光标开始。例如使用 delete 2 word（d2w）：编辑器就认为你所说的两个单词是从光标之后。看下面的例子</p><p><img src="http://101.200.84.36/images/2022/05/09/202205092057496.png" alt="删除之前" title="删除之前"></p><p><img src="http://101.200.84.36/images/2022/05/09/202205092116759.png" alt="不使用介词,，输入 d2w" title="不使用介词,，输入 d2w"></p><h3 id="惯用法"><a href="#惯用法" class="headerlink" title="惯用法"></a>惯用法</h3><p>现在将光标移动到第九行，输入 yank inside sentence（yis）复制一行。输入 paste（p）就会粘贴到下一行（大写 P 会粘贴到上一行）。</p><p><img src="http://101.200.84.36/images/2022/05/09/202205092120488.png" alt="复制一行"></p><p><img src="http://101.200.84.36/images/2022/05/09/202205092123546.png" alt="粘贴"></p><p>虽然听起来很霸气，但是我们删除一行或者复制一行通常不会使用 dis（das）或者 yis（yas），因为需要三个字母 —— 我们是懒人，单词好越少越好，所以一般使用 dd 或者 yy 进行删除和复制。类似的还有使用 cc 代替 change inside sentence（cis）。</p><h3 id="数量词-动词-名词"><a href="#数量词-动词-名词" class="headerlink" title="数量词 + 动词 + 名词"></a>数量词 + 动词 + 名词</h3><p>这个和 “动词 + 数量词 + 介词 + 名词” 差不多，但是一般用于特殊的动词，例如 r(replace)、x(删除单个字符)、p(paste)。这些命令一般都是单个使用 —— 不存在 paste inside sentence 这个类用法，所以要粘贴多次的使用可以使用 2 paste（读作 twice paste）。</p><p>此外还可以搭配 yank 使用 —— yank 2 around sentence（y2as）&#x3D; 2 yank yank（2yy），这样要简单很多。还有删除 d 等等。基本是更简单的用法。当然，其实“动词 + 数量词 + 介词 + 名词”也可以省略为“动词 + 数量词 + 名词”。</p><h3 id="其他动词"><a href="#其他动词" class="headerlink" title="其他动词"></a>其他动词</h3><p>上面列出的是常用的动词，这里还有一些补充的动词：</p><ol><li>u，undo 的缩写，用于撤销操作，适用于上面的语法，可以单独使用，也可以搭配数量词（不需要介词）。</li><li><kbd>Ctrl</kbd>+<kbd>r</kbd>，redo 的缩写，不适用于上面的语法，单独使用，算作快捷键。撤销 撤销操作（我没有多写一个撤销）。</li><li>g，goto 的缩写，用于跳转到指定行。适用于上面的语法，不需要介词。gg 表示跳转到第一行，<kbd>Shift</kbd>+<kbd>g</kbd> 表示跳转到最后一行。跳转到 45 行使用 45gg。</li><li>z，无对应单词，表示滚动当前行。zz 表示滚动当前行到屏幕中间；zb，b 是 bottom 的缩写，表示滚动当前行到屏幕底部；zt，t 是 top 的缩写，表示滚动当前行到屏幕顶部。</li><li>w，word 的缩写，做动词表示移动到下一个单词开头。2w 表示移动到后面第二个单词的开头。适用与上面的部分语法。</li><li>e，end 的缩写，做动词表示移动到单词的结尾，与 b 相反。适用于上面的部分语法。</li><li>b，begin 的缩写，做动词表示移动到单词的开头，与 e 相反。是用于上面的部分语法。</li><li>f，find 的缩写，表示查找。ft 表示查找该行的字符 t ，并移动到相应位置。</li><li>^，head of line 的符号，表示开头，做动词表示移动到该行的开头，与 $ 相反。配合 delete 使用可以做到从当前字符删除到行首。可以当作名词与大部分动词搭配使用。</li><li>$，end of line 的符号，表示结尾，做动词表示移动到该行的结尾，与 ^ 相反。可以作为名词与大部分动词搭配使用。</li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>稍微介绍了一下 VIM 的语法，其实完全不算难。比如 b、e、f、w 我就很少用。用的多的基本是 goto、delete、insert、yank 和 paste。这里的功能基本是我用到的部分，其余如快捷键映射、宏录制甚至 VIM 脚本语法都是进阶用法（意思是说，我也未必知道），我们就懒得涉猎了。</p><p>祝 VIM 入门愉快！</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编辑器</tag>
      
      <tag>VIM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在 Linux 上实现回收站</title>
    <link href="/2022/04/29/%E5%9C%A8-Linux-%E4%B8%8A%E5%AE%9E%E7%8E%B0%E5%9B%9E%E6%94%B6%E7%AB%99/"/>
    <url>/2022/04/29/%E5%9C%A8-Linux-%E4%B8%8A%E5%AE%9E%E7%8E%B0%E5%9B%9E%E6%94%B6%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 Windows 系统的时候，我会习惯使用快捷键 <kbd>Shift</kbd> + <kbd>delete</kbd> 进行直接删除，感觉这很酷 —— 不用经过回收站。当然，时不时还是会后悔自己错删了某个文件，但是 Windows 上有太多的数据恢复软件，完全不用担心。使用 Linux 之后，我很习惯命令行上的 <code>rm</code> 命令，直接把数据删个干净。有次错把自己的一个重要文件给删了，差点没救回来。那时候起，我开始考虑实现一个脚本，就像 Windows 那样 —— 不直接删除数据，而是挪到一个地方。</p><h1 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h1><p>Linux 大部分桌面系统是有回收站的 —— 至少我使用的 GNOME 桌面系统是这样的。回收站的位置一般是 <code>~/.local/share/Trash</code> 。其中  <code>~</code> 表示家目录，例如我的家目录是 <code>/home/chunshuyumao</code> 。通过文件管理器删除一个文件，我们可以在回收站目录下看到两个文件: <code>info</code> 和 <code>files</code> 。前者是被删文件的信息，例如路径和删除时间；后者是被删文件移动到的位置。</p><p><img src="http://101.200.84.36/images/2022/04/29/202204291614948.png" alt="空回收站"></p><p>图形界面删除一个文件之后，可以在回收目录下找到删除的文件和信息：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ tree<br>.<br>├── expunged<br>├── files<br>│   └── test.sh<br>└── info<br>    └── test.sh.trashinfo<br><br>3 directories, 2 files<br></code></pre></div></td></tr></table></figure><p>查看 <code>trashinfo</code> 文件不难发现，这其实是被删文件的信息:</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> info/test.sh.trashinfo<br>[Trash Info]<br>Path=/home/chunshuyumao/test.sh<br>DeletionDate=2022-04-29T16:15:24<br></code></pre></div></td></tr></table></figure><p>现在，我们要做的，就是写一个脚本，做到和图形界面一样的效果：<code>rm</code> 不是直接删除，而是移动到固定位置，同时生成一个被删文件的信息。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>想法很简单，直接使用 <code>mv</code> 代替 <code>rm</code> 。不过我们还需要实现 <code>trashinfo</code> 文件，以便可以模仿图形界面恢复文件。</p><h2 id="搭建框架"><a href="#搭建框架" class="headerlink" title="搭建框架"></a>搭建框架</h2><p>首先创建一个文件，命名为 <code>mv2trash.sh</code> ，意思是移动到回收站而不是直接删除。至于脚本放哪里，我的建议是在自己的家目录创建一个 <code>.scripts</code> 文件夹，然后在里边放自己写的脚本或配置。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">mkdir</span> ~/.scripts<br>$ vim mv2trash.sh<br></code></pre></div></td></tr></table></figure><p>习惯性地在脚本第一行添加 <code>#!/bin/bash</code> ，之前说过这是例行公事。</p><p>首先，我们需要创建一些常量( read only ，符号是 <code>-r</code> )：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-comment"># TrashPath 表示被删文件的路径</span><br><span class="hljs-built_in">declare</span> -r TrashPath=<span class="hljs-variable">$HOME</span>/.local/share/Trash/files<br><span class="hljs-comment"># InfoPath 表示信息文件的位置</span><br><span class="hljs-built_in">declare</span> -r InfoPath=<span class="hljs-variable">$HOME</span>/.local/share/Trash/info<br><br><span class="hljs-comment"># 确认回收站的位置是否存在</span><br>[ ! -e <span class="hljs-string">&quot;<span class="hljs-variable">$TrashPath</span>&quot;</span> ] &amp;&amp; <span class="hljs-built_in">mkdir</span> -p <span class="hljs-string">&quot;<span class="hljs-variable">$TrashPath</span>&quot;</span><br>[ ! -e <span class="hljs-string">&quot;<span class="hljs-variable">$InfoPath</span>&quot;</span> ] &amp;&amp; <span class="hljs-built_in">mkdir</span> -p <span class="hljs-string">&quot;<span class="hljs-variable">$InfoPath</span>&quot;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">main</span></span>() &#123;<br><br>  <span class="hljs-keyword">while</span> [ <span class="hljs-variable">$#</span> -gt 0 ]; <span class="hljs-keyword">do</span><br>    <span class="hljs-comment"># 做一些操作</span><br>    <span class="hljs-comment"># command</span><br>    <span class="hljs-built_in">shift</span><br>  <span class="hljs-keyword">done</span><br>&#125;<br><br><span class="hljs-comment"># 调用函数， &quot;$@&quot; 是传递所有参数</span><br>main <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span><br></code></pre></div></td></tr></table></figure><p><code>$HOME</code> 表示家目录，一般是 <code>/home/username</code> ，比如我的家目录 <code>/home/chunshuyumao</code> ，使用 <code>$HOME</code> 而不是绝对路径是为了通用性 —— 当你移动这个脚本到其他电脑的时候它仍然指的是家目录，即使你的用户名并不是 <code>chunshuyumao</code>。</p><p><code>[ -e TrashPath&quot;  ]</code> 判断路径是否存在，<code>-e</code> 是 <code>exist</code> 的缩写，前面添加 <code>!</code> 则表示否定。<code>mkdir</code> 是 <ruby>创建目录<rt>make directory</rt></ruby>的缩写；<code>-p</code> 是 <code>--parents</code> 的短命令形式，如果父目录不存在就创建而不是报错。<code>&amp;&amp;</code> 表示前一个命令为真就执行后一个命令。因此，只有路径不存在的时候才会创建路径。</p><blockquote><p>-p 可能说的比较奇怪。其实是这样的，mkdir 命令只能创建一级目录，加上 -p 就可以创建多级目录。<br>mkdir file &amp;&amp; mkdir file&#x2F;filea &amp;&amp; mkdir file&#x2F;filea&#x2F;fileb 这就是之能够创建一级目录怎么创建 file&#x2F;filea&#x2F;fileb<br>如果使用 -p 或者 –parent 的话，可以直接通过 mkdir -p file&#x2F;filea&#x2F;fileb 一气呵成。</p><p>. 开头的文件是隐藏文件，使用 ls 是看不见的，需要使用 ls -a 才可以。 </p></blockquote><p>后面我们创建了一个函数 <code>main</code> 并调用了它。同时记得，我们把脚本的参数也一并传递了过去。在 <code>main</code> 函数中，我们判断，只要参数不为零，就一直循环，同时用 <code>shift</code> 移除使用过的参数。</p><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>首先看看我们的实现：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">main</span></span>() &#123;<br><br>  <span class="hljs-keyword">while</span> [ <span class="hljs-variable">$#</span> -gt 0 ]; <span class="hljs-keyword">do</span><br>  <br>    <span class="hljs-built_in">local</span> filename=<span class="hljs-string">&quot;<span class="hljs-subst">$(basename $1)</span>&quot;</span><br>    <span class="hljs-built_in">local</span> filepath=<span class="hljs-string">&quot;<span class="hljs-subst">$(cd $(dirname $1)</span>; pwd)/<span class="hljs-variable">$filename</span>&quot;</span><br>    <span class="hljs-built_in">local</span> trashinfofile=<span class="hljs-string">&quot;<span class="hljs-variable">$InfoPath</span>/<span class="hljs-variable">$filename</span>.trashinfo&quot;</span><br>    <span class="hljs-built_in">local</span> deletiondate=<span class="hljs-string">&quot;<span class="hljs-subst">$(date +%Y-%m-%dT%H:%M:%S)</span>&quot;</span><br>    <br>    <span class="hljs-comment"># 使用系统的移动命令移动文件到指定地点</span><br>    /usr/bin/mv <span class="hljs-string">&quot;<span class="hljs-variable">$filepath</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$TrashPath</span>&quot;</span><br>    <br>    <span class="hljs-comment"># 创建一个 trashinfo 文件</span><br>    <span class="hljs-comment"># 并写入相关信息</span><br>    <span class="hljs-built_in">cat</span> &gt;&gt; <span class="hljs-string">&quot;<span class="hljs-variable">$trashinfofile</span>&quot;</span> &lt;&lt; <span class="hljs-string">_EOF_</span><br><span class="hljs-string">[Trash Info]</span><br><span class="hljs-string">Path=$filepath</span><br><span class="hljs-string">DeletionDate=$deletiondate</span><br><span class="hljs-string">_EOF_</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;rm: remove <span class="hljs-variable">$filepath</span> to <span class="hljs-variable">$TrashPath</span> &quot;</span><br>    <span class="hljs-built_in">shift</span><br>  <span class="hljs-keyword">done</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面我们创建了四个局部变量 —— 也就是 <code>local</code> 修饰的那几个变量。这里有几个函数介绍一下：</p><ol><li><code>basename</code> ，语法：<code>basename path_to_file</code> 。这个函数返回给予路径的文件名。我们不知道使用者提供的是什么路径，可能是绝对路径 <code>/home/chunshuyumao/test.txt</code> ，也可能是相对路径 <code>~/test.txt</code> ，但使用这个 <code>basename</code> 函数，它会正确返回 <code>test.txt</code> 这个文件名。</li><li><code>dirname</code>，语法：<code>dirname path_to_file</code>。该函数会返回给予路径的路径名。如果我们提供的是 <code>/home/chunshuyumao/scripts/test.sh</code>，函数会返回 <code>/home/chunshuyumao/scripts</code>；如果提供的是当前目录下的 <code>test.sh</code> ，函数会返回 <code>.</code> —— 一个小圆点表示当前路径。为了得到当前位置的绝对路径，我们需要进入这个路径，然后使用 <code>pwd</code> 打印当前路径 —— <code>pwd</code> 是 <ruby>打印工作目录<rt>Print Working Directory</rt></ruby>的缩写。如果不理解，只需要知道这种方法可以获取文件绝对路径就行了。最后通过拼接，形成了文件的绝对路径。</li><li><code>date</code>，语法：<code>date formating_string</code>。这个函数可以获取当前时间 ，并按照 <code>formating_string</code> 进行格式化。在上面的脚本中，我们希望输出“年-月-日T时:分:秒”。</li></ol><p>获取变量之后使用系统的移动命令移动文件或者文件夹到指定位置即可。注意，这里的移动命令 <code>mv</code> 没有简单使用 <code>mv</code> 而是 <code>/usr/bin/mv</code> ，这是防止有其他的别名影响。</p><p>最后的 <code>cat</code> 一行可能比较难以理解。这里引入一个新的语法糖，我会慢慢解释。<br>如果我们需要创建一个新的文件，并在其中输入一些文字，最常用的方法是打开编辑器然后输入文字、保存、退出。有些时候我们输入的内容太少或者不想大费周章打开一个编辑器，这种时候重复上面的操作就难免有点复杂了。好在 Linux Shell 上重定向符号 <code>&gt;</code>、<code>&lt;</code>等可以满足我们的需求。下面介绍几种重定向符号：</p><ol><li><code>&gt;</code>输出重定向符。语法：<code>command &gt; output_file</code>。左边是 <ruby>命令<rt>Command</rt></ruby> ，右边是 <ruby>保存文件<rt>Output File</rt></ruby> 。重定向输出，如果指定的文件不存在会自动生成；可是也要注意：如果存在目标文件，命令会清空文件中的所有内容，然后再把结果写入到目标文件。一句话：如果之前就有这个保存文件，那么保存文件内的原始内容将被删掉。 <code>ls</code> 列出当前目录下的文件，使用重定向符号试试：</li></ol><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">ls</span> &gt; list.txt<br>$ <span class="hljs-built_in">ls</span><br>Desktop    Downloads  Music     Public     Videos<br>Documents  list.txt   Pictures  Templates  Zotero<br>$ <span class="hljs-built_in">cat</span> list.txt<br>Desktop<br>Documents<br>Downloads<br>list.txt<br>Music<br>Pictures<br>Public<br>Templates<br>Videos<br>Zotero<br></code></pre></div></td></tr></table></figure><p><img src="http://101.200.84.36/images/2022/05/08/202205081622531.png" alt="重定向之后 ls 输出的内容到了 list.txt 当中" title="重定向之后 ls 输出的内容到了 list.txt 当中"></p><p>可以看到，使用 <code>&gt;</code> 重定向符号之后 <code>ls</code> 命令不再把结果输出到屏幕上，而是输出到我们指定的文件 <code>list.txt</code> 中。这个时候如果不存在指定的文件，命令就会重建一个文件。这个功能其实很有用，特别是当我们希望把命令的操作结果保存时。</p><p>上面说了，如果这个文件本来就有内容了，这个操作会抹除原始的内容，所以专门有个 <code>&gt;&gt;</code> 符号（追加重定向）作为辅助 —— 这个符号只是在文件末尾追加内容，而不是抹除然后再输入：</p><p><img src="http://101.200.84.36/images/2022/05/08/202205081640928.png" alt="使用输出重定向会直接抹除原来的内容"></p><p><img src="http://101.200.84.36/images/2022/05/08/202205081642542.png" alt="使用追加重定向后 list.txt 的内容增加而不抹除原内容"></p><ol start="2"><li><code>&lt;</code> 输入重定向符。语法：<code>command &lt; input_file</code>。读取右边的文件，并把结果传给左边的命令。下面借助 <code>wc -l</code> 计算 <code>list.txt</code> 的行数：</li></ol><p><img src="http://101.200.84.36/images/2022/05/08/202205081636770.png" alt="输入重定向" title="输入重定向"></p><p>同理，也有一个 <code>&lt;&lt;</code> 不过这个一般不单独出现，而是出现在一个被称为 “Bash Here Document” 的东西。这个东西的语法是：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">command</span> &lt;&lt; <span class="hljs-string">InputComesFromHere</span><br><span class="hljs-string">...</span><br><span class="hljs-string">...</span><br><span class="hljs-string">...</span><br><span class="hljs-string">InputComesFromHere</span><br></code></pre></div></td></tr></table></figure><p>上面的 <code>.</code> 表示一些文字。其中 <code>InputComesFromHere</code> 是一个符号，表示从这里开始到下一个同样的符号结束的都是想要输入重定向的文字。这个 <code>inputComesFromHere</code> 符号一般随便选择 —— 通常我们会选择 <code>EOF</code> 或者 <code>_EOF_</code>，表示 <ruby>文件结束符<rt>End Of File</rt></ruby>，因为一般的文件末尾都使用它作为标识。到这里，我上面的命令就可以理解了：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">    <span class="hljs-built_in">cat</span> &gt;&gt; <span class="hljs-string">&quot;<span class="hljs-variable">$trashinfofile</span>&quot;</span> &lt;&lt; <span class="hljs-string">_EOF_</span><br><span class="hljs-string">[Trash Info]</span><br><span class="hljs-string">Path=$filepath</span><br><span class="hljs-string">DeletionDate=$deletiondate</span><br><span class="hljs-string">_EOF_</span><br></code></pre></div></td></tr></table></figure><p>把两个 <code>_EOF_</code> 之间的内容追加到文件 <code>&quot;$trashinfofile&quot;</code> 中，这就很直观了。</p><p>我们的脚本基本已经完成，输入 <code>chmod u+x mv2trash.sh</code> 赋予脚本可执行权限，然后尝试删除：</p><p><img src="http://101.200.84.36/images/2022/05/08/202205081709669.png" alt="使用我们的脚本"></p><p>现在 <code>.local/share/Trash</code> 下面有两个文件夹，其中分别装着刚刚删除的文件 <code>list.txt</code> 和 <code>list.txt.trashinfo</code>。以后我们删除的文件和生成的文件信息文件也会挪到这些位置。到这里，我们的框架基本搭完了，其实还可以补充更多的细节，例如交互模式 —— 用于确认删除。</p><h2 id="实现恢复"><a href="#实现恢复" class="headerlink" title="实现恢复"></a>实现恢复</h2><p>删除文件之后，我们希望可以做到一键恢复，这就不得不再写一个脚本 —— 如果不愿意再写一个脚本，可以选择直接移动文件到原来的位置，然后删除 <code>Trash Info</code> 文件。不过我这里还是实现一下自动恢复：</p><p><img src="http://101.200.84.36/images/2022/05/08/202205082105652.png" alt="恢复效果"></p><p>上面，我先创建了一个 <code>test.sh</code> 文件，然后删除它，再用 <code>rrm</code> 恢复文件。其中的 <code>rm</code> 和 <code>rrm</code> 其实是我刚写的两个脚本的文件别名，后面会讲到。可以看到，<code>rrm</code> 可以实现直接恢复文件到原来的位置 —— 就是通过读取原本的 <code>trashinfo</code> 文件内部的信息。记得吧，我们的 <code>trashinfo</code> 文件记录了文件原始目录。</p><p>先创建一个文件，然后再敲代码。我的恢复脚本名是 recover.sh ，感觉还是比较直观。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ vim ~/.scripts/recover.sh<br></code></pre></div></td></tr></table></figure><p>按照上面的步骤，我们先写好脚本框架，然后再慢慢补充。路径和上面的删除脚本都一样，照搬。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-comment"># TrashPath 表示被删文件的路径</span><br><span class="hljs-built_in">declare</span> -r TrashPath=<span class="hljs-variable">$HOME</span>/.local/share/Trash/files<br><span class="hljs-comment"># InfoPath 表示信息文件的位置</span><br><span class="hljs-built_in">declare</span> -r InfoPath=<span class="hljs-variable">$HOME</span>/.local/share/Trash/info<br><br><span class="hljs-comment"># 确认回收站的位置是否存在</span><br>[ ! -e <span class="hljs-string">&quot;<span class="hljs-variable">$TrashPath</span>&quot;</span> ] &amp;&amp; <span class="hljs-built_in">mkdir</span> -p <span class="hljs-string">&quot;<span class="hljs-variable">$TrashPath</span>&quot;</span><br>[ ! -e <span class="hljs-string">&quot;<span class="hljs-variable">$InfoPath</span>&quot;</span> ] &amp;&amp; <span class="hljs-built_in">mkdir</span> -p <span class="hljs-string">&quot;<span class="hljs-variable">$InfoPath</span>&quot;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">recover</span></span>() &#123;<br><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">main</span></span>() &#123;<br>  <br>  <span class="hljs-keyword">while</span> [ <span class="hljs-variable">$#</span> -gt 0 ]; <span class="hljs-keyword">do</span><br>    recover <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span><br>    <span class="hljs-built_in">shift</span> <br>  <span class="hljs-keyword">done</span><br>&#125;<br><br>main <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span><br></code></pre></div></td></tr></table></figure><p>接下来只需要补充函数 <code>recover</code> 即可。其实这个框架和上一个脚本都差不多 —— 只是上一个脚本没有隔离出新的函数罢了。脚本的使用方法：<code>rrm path_to_file1 path_to_file2 ...</code> 。这里的而 <code>path_to file1</code> 要求是全路径 —— 也就是必须指定文件路径<code>~/.local/share/Trash/files/file1</code>。为什么？其实这是为了避免误恢复，所以只有全路径才能让操作者脑子清醒一点。</p><h3 id="恢复前操作"><a href="#恢复前操作" class="headerlink" title="恢复前操作"></a>恢复前操作</h3><p>恢复之前，我们需要做一些工作，最主要的是判断参数的正确性。后面的代码都写在 <code>recover</code> 函数体中。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">recover</span></span>() &#123;<br>  <br>  <span class="hljs-comment"># 判断要恢复的文件存在于否，如果不存在直接返回</span><br>  <span class="hljs-keyword">if</span> [ ! -e <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;No such a file or directory: <span class="hljs-variable">$1</span>&quot;</span><br>    <span class="hljs-built_in">return</span> 1<br>  <span class="hljs-keyword">fi</span><br><br>  <span class="hljs-comment"># 获取文件的文件名</span><br>  <span class="hljs-built_in">local</span> filename=<span class="hljs-string">&quot;<span class="hljs-subst">$(basename <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span>)</span>&quot;</span><br>  <span class="hljs-comment"># 拼凑文件信息文件的路径</span><br>  <span class="hljs-built_in">local</span> infofile=<span class="hljs-string">&quot;<span class="hljs-variable">$InfoPath</span>&quot;</span>/<span class="hljs-string">&quot;<span class="hljs-variable">$filename</span>.trashinfo&quot;</span><br>  <span class="hljs-comment"># 判断文件信息文件是否存在，如果不存在则提示恢复者直接手动移动文件到目的目录就可以</span><br>  <span class="hljs-keyword">if</span> [ ! -e <span class="hljs-string">&quot;<span class="hljs-variable">$infofile</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;No such a file: <span class="hljs-variable">$infofile</span> . Please move target file or directory manually.&quot;</span><br>    <span class="hljs-built_in">return</span> 1<br>  <span class="hljs-keyword">fi</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面的操作我们判断恢复文件的存在和拼凑文件信息文件，为后面的恢复做准备。这里的操作我们其实都见过，例如 <code>basename</code> 获取文件名，还有 <code>-e</code> 判断文件存在。</p><h3 id="开始恢复"><a href="#开始恢复" class="headerlink" title="开始恢复"></a>开始恢复</h3><p>恢复代码写在上面的代码之后 —— 先看我们的恢复代码：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">local</span> path=<span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> line; <span class="hljs-keyword">do</span><br>  ...<br>  ...<br><span class="hljs-keyword">done</span> &lt; <span class="hljs-string">&quot;<span class="hljs-variable">$infofile</span>&quot;</span><br></code></pre></div></td></tr></table></figure><p>首先声明一个本地变量 —— 我不是很喜欢全局变量。这里使用了一个命令 —— <code>read</code> 。 <code>read</code> 命令语法是：<code>read variable</code>。后面的 <code>variable</code> 是变量名，可以随便取，我这里的变量名是 <code>line</code>。注意，<code>done</code> 之后的重定向 —— 其实就是把文件信息文件内的内容一行一行地读出来。重定向我们上面说过了，这就是重定向的用法。这里不停的读取一行一行信息。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">local</span> path=<span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> line; <span class="hljs-keyword">do</span><br>  <span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$line</span>&quot;</span> =~ <span class="hljs-string">&quot;Path&quot;</span> ]]; <span class="hljs-keyword">then</span><br>    path=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;line:$(expr index &quot;$line&quot; &#x27;=&#x27;)&#125;</span>&quot;</span><br>    <span class="hljs-built_in">break</span><br>  <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">done</span> &lt; <span class="hljs-string">&quot;<span class="hljs-variable">$infofile</span>&quot;</span><br></code></pre></div></td></tr></table></figure><p>上面的代码就是判断读入的每一行，如果这行中有 “Path” 字样，就进行处理，并退出循环。<code>=~</code> 运算符之前也有介绍过，就是判断某一个字符串是否包含另一个字符串。举个例子，我可以使用 <code>[[ &quot;$str&quot; =~ &quot;chunshu&quot; ]]</code> 判断 <code>$str</code> 是否包含 <code>chunshu</code>这个字符串。如果我们读入的行有 “Path” 字样，就说明这就是保存文件路径的一行，后面的命令其实是对这个的处理。</p><p>Shell 用 <ruby>切片<rt>Slice</rt></ruby>切割字符串 —— 之前我们介绍的 <code>#</code> 和 <code>%</code> 就属于 <ruby>切片<rt>Slice</rt></ruby>。这里使用了两个表达式：</p><ol><li><code>$&#123;str:from:length&#125;</code> 。意思是截取某一个字字符串。<code>str</code> 表示字符串，<code>from</code> 表示从第几个字符开始（不包括这个字符），<code>length</code> 表示总共截取多少个字母 —— 可以省略，表示截取到结尾。</li><li><code>expr index &quot;$str&quot; &#39;char(s)&#39;</code> 。 表示获取 <code>char(s)</code> 在 <code>str</code> 中的下标。<code>expr</code> 和 <code>index</code> 是保留字，<code>str</code> 表示字符串，<code>char(s)</code> 表示查找的字符或字符串。</li></ol><p>所以 <code>$&#123;line:$(expr index &quot;$line&quot; &#39;=&#39;)&#125;</code> 表示在这一行中找到 <code>=</code> 的下标，然后截取 <code>=</code> 之后的字符串。如果 <code>$line</code> 表示 <code>Path=/home/chunshuyumao/file1</code> ，这结果是 <code>/home/chunshuyumao/file1</code>。获得路径之后直接使用 <code>break</code>跳出 <code>while</code>循环。</p><p>使用系统的 <code>/bin/mv</code> 移动文件到指定位置，使用 <code>/bin/rm</code> 删除文件信息文件。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> line; <span class="hljs-keyword">do</span><br>...<br><span class="hljs-keyword">done</span> &lt; <span class="hljs-string">&quot;<span class="hljs-variable">$infofile</span>&quot;</span><br><br><span class="hljs-comment"># 一定要使用全路径命令</span><br><span class="hljs-comment"># Remove From                   To</span><br>/bin/mv <span class="hljs-string">&quot;<span class="hljs-variable">$TrashPath</span>/<span class="hljs-variable">$filename</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$path</span>&quot;</span><br>/bin/rm <span class="hljs-string">&quot;<span class="hljs-variable">$infofile</span>&quot;</span><br><br><span class="hljs-comment"># 输出提示信息</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;recover <span class="hljs-variable">$filename</span> to <span class="hljs-variable">$path</span>&quot;</span><br></code></pre></div></td></tr></table></figure><p>为什么这里的 <code>rm</code> 和 <code>mv</code> 要使用全路径（加 <code>/bin</code>）而不是直接使用 <code>rm</code> 和 <code>mv</code>？这是为了避免使用错误的命令。后面会有介绍。赋予脚本可执行权限，然后使用。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">chmod</span> u+x ~/.scripts/recover.sh<br></code></pre></div></td></tr></table></figure><h2 id="使用命令别名"><a href="#使用命令别名" class="headerlink" title="使用命令别名"></a>使用命令别名</h2><p>我们最开始的目标是防止自己误删文件导致后悔不已，可是现在的脚本是 mv2trash.sh 和 recover.sh ，我们基本不会使用这种长命令，所以接下来配置命令别名：打开自己的 Shell 配置文件 —— 我用的是 Zsh 所以配置的是 ~&#x2F;.zshrc ，如果你使用的是 Bash，配置的是应该是 ~&#x2F;.bashrc 。如果不知道自己的是什么 Shell ，可以输入 <code>echo $SHELL</code> ，看输出结果。</p><p>我使用 VIM 配置 .zshrc 所以操作是：进入 VIM 后，按 <kbd>Shift</kbd>+<kbd>g</kbd>转到最后一行，然后输入 <kbd>o</kbd> ，输入下面的别名，按 <kbd>Esc</kbd> 键，然后输入 <code>:wq</code> ，回车 —— 完成保存退出。在命令行上输入 <code>source ~/.zshrc</code> 立即生效。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ vim ~/.zshrc<br><br><span class="hljs-comment"># 这是别名</span><br><span class="hljs-built_in">alias</span> <span class="hljs-built_in">rm</span>=<span class="hljs-variable">$HOME</span>/.scripts/mv2trash.sh<br><span class="hljs-built_in">alias</span> rrm=<span class="hljs-variable">$HOME</span>/.scripts/recover.sh<br><br>$ <span class="hljs-built_in">source</span> ~/.zshrc<br></code></pre></div></td></tr></table></figure><p>完成别名，接下来我们使用 的<code>rm</code> 就是自己的脚本，<code>rrm</code> 是恢复命令。如果想使用系统的删除命令直接删除某个文件而不是挪到垃圾箱怎么办？简单 —— 使用全路径，就是 <code>/bin/rm file</code> 。这就是为啥上面的脚本要使用全路径。</p><h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><p>其实这个脚本还是可写很多，例如我还实现了脚本的日志 —— 不过我看了一下现在字数非常多，没心思再写下去。此外，如果对自己写的脚本不满意，可以使用软件 trash-cli 。这是大佬实现的命令行垃圾箱，不过我没用过，应该比自己写的好一点。很多 Linux 发行版都可以直接安装。使用说明推荐使用 <code>man trash-cli</code> 或者 <code>trash-cli --help</code> 查看 —— 当然，我没用过，不知道怎么样，自己的够用了。</p><p>后面打算写写 VIM 语言 —— 分享分享 VIM 这个被说的神乎其神的编辑器怎么入门。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>脚本</tag>
      
      <tag>技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>好玩的命令行工具</title>
    <link href="/2022/04/24/%E5%A5%BD%E7%8E%A9%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"/>
    <url>/2022/04/24/%E5%A5%BD%E7%8E%A9%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>老习惯，前言牢骚不用看。4 月偷了懒，今天突然心血来潮，更更自己文章 —— 不然就过去一个月了。谈谈自己最近做的事，顺便分享一些好玩的命令行命令。自己做的事是闲事，所以直接放前言。</p><p>值得一提的一件事是，参与测试国内首个大型的编程语言。编程语言现在已经不是什么新鲜事 —— 当初自己就有一个非计算机系的学弟在只学了 C++ 的一些皮毛之后，纯手工造了一个新的语言。这种大佬咱没话可说。可惜他完全是新手上车，以初学者的方式理解高级语言，所以略有不足（如果他咨询咨询我的话可能会更好，不过也是，咱也没问人家）。既然如此，这门新的编程语言有何特点？其实不好说，因为人家还在内测，具体很多东西还待商榷。不过我们要知道，目前为止，几乎所有编程界的高级语言都依赖于 C&#x2F;C++，这让它们或多或少执行效率都不咋地 —— 比如 Python，堪称龟速。虽然有如 Lua 这类的小巧的语言，但是它们往往是大语言的伴生物，不能独当一面。这里就不多做介绍了。</p><p>目前为止，能在效率上和 C&#x2F;C++ 抗衡，又有自己优势的就是 Rust —— 更安全。其余的 Go 或者等等都有待商榷。不过了解 Rust 的应该知道，这门语言为了安全，语法变得非常复杂 —— 最近自己也试着学学这门语言，一言难尽。有此看来，我参与内测的编程语言的定位很明显了。个人觉得这门语言还是很优秀的，因为有很多先辈的经验。同样，因为作为“国货之光”，大家可能会对它抱有很大的期望 —— 如果它给你的感觉不大好，那很可能是你给它倾注的期望太大了。两边都没有错，希望要多一点理解。</p><p>另一个要说的，就是中文编程。我实在无法理解为什么很多人对中文编程那么执着？诚然，中文更符合我们的习惯 —— 可是中文的输入一直是个问题。历史传说的 26 键打不过九键，拼音打不过双拼，双拼打不过五笔…… 这种故事多了。如果要创造一个中文编程，最好的方式就是按照国人的思维创造。思维方式不同，照搬国外语言然后换一个中国字的结果就是 —— 文字游戏。比如易语言，这门语言确实是中文编程，咱也不深究，但是使用函数方法的时候，我们又需要输入半角符号 —— 基本等于 C 语言里的宏定义了，但是易语言至少做了一些创新。反观一些模仿者，就说前一阵子刚出现的某中文操作系统和创造者创造的“甲、乙”语言 —— 完全就是收割智商，可结果还是有一班信徒。至此，咱也没话可说了 —— 早知道智商税这么好赚……</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>今天要介绍的是一些命令行工具 —— 有些不仅仅是 Linux 系统才可以使用。</p><ol><li>cmus 命令行音乐播放器</li><li>FFmpeg 视频和音频工具</li><li>Telnet 远程登陆工具</li></ol><h2 id="cmus-命令行音乐播放器"><a href="#cmus-命令行音乐播放器" class="headerlink" title="cmus 命令行音乐播放器"></a>cmus 命令行音乐播放器</h2><p>使用 Linux 作为主系统之后，我很习惯直接使用命令行解决大多数问题 —— 说实在，我就没打开过自己的文件管理器几次。虽然我例行公事地下载了 VLC 媒体播放器 —— 一个非常优秀的跨平台多媒体播放器，但是自己很少使用。简而言之，咱基本只使用命令行。</p><p>敲命令怎么能让耳朵闲着？为了在使用命令行的时候可以听歌放松，我选择了 <a href="https://github.com/cmus/cmus" title="cmus">cmus</a> 播放器，一个纯 C 语言写的命令行播放器，内存和速度没得说 —— 贼低贼快。大多数的 Linux 发行版都可以直接用命令行安装，我用的是 Manjaro ，所以使用 <code>sudo pacman -S cmus</code> 安装。</p><p>安装完毕之后在命令行上输入 <code>cmus</code> ，回车打开，界面如下： </p><p><img src="http://101.200.84.36/images/2022/04/24/202204242119118.png" alt="cmus 界面"></p><p>现在的 cmus 还没有音乐，我们需要导入。确认进入 cmus 之后，直接在键盘上输入 <code>:a ~/Music</code> ，回车。眼尖的同学会发现，cmus 的命令和 VIM 很相似。<code>:</code> 是命令行模式的标志，所以一定要打出来；<code>a</code> 表示 add ，也可以直接使用 <code>add</code> 长指令；后面的 <code>~/Music</code> 是音乐路径，这是我放音乐的地方。刚刚的命令也可以写成这样 <code>:add ~/Music</code>。</p><p><img src="http://101.200.84.36/images/2022/04/24/202204242139772.png" alt="添加音乐"></p><p><img src="http://101.200.84.36/images/2022/04/24/202204242152627.png" alt="添加音乐后"></p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>因为和 VIM 差不多，所以使用 <kbd>j</kbd>、<kbd>k</kbd> 上下移动，<kbd>h</kbd>、<kbd>l</kbd> 向前向后调整播放进度， <kbd>z</kbd> 播放上 一首，<kbd>b</kbd> 播放下一首，<kbd>c</kbd> 暂停&#x2F;播放，<kbd>x</kbd> 从头播放，<kbd>v</kbd> 停止，<kbd>CTRL</kbd>+<kbd>r</kbd> 单曲循环&#x2F;歌单循环，<kbd>e</kbd> 添加下一首播放，<kbd>tab</kbd> 切换<strong>艺术家</strong>和<strong>音乐库</strong>两列等等。更多操作可以使用 <code>man cmus</code> 查看。 </p><p>此外，还有 <kbd>CTRL</kbd>+<kbd>l</kbd> 刷新缓存 —— 因为导入的音乐有些信息未必完整，最后需要手动修改。个人觉得 cmus 很适合命令行的极度爱好者 —— 还有我这类附庸风雅的。</p><h2 id="FFmpeg-音视频工具"><a href="#FFmpeg-音视频工具" class="headerlink" title="FFmpeg 音视频工具"></a>FFmpeg 音视频工具</h2><p>这个东东来历大了，现在市面上搞音视频的不认识这家伙都不好意思说自己不认识。我不喜欢什么东西都往自己电脑上装，所以之前没打算使用 cmus，而是想自己写一个命令行脚本播放音乐，当时盯上的后端就是这东西。后来是写了一点，但是惊奇地发现：原来我的电脑自己就带了 cmus ！果断中途放弃自己写脚本的想法。太讽刺了 —— 电脑自己安装就觉得心安理得……</p><p>我今天介绍 <a href="https://ffmpeg.org/" title="FFmpeg">FFmpeg</a> 主要是音视频的转化。使用 Windows 的时候，我基本不会选择命令行，而是直接使用格式工厂(当然，格式工厂也是靠 FFmpeg)，不过到了 Linux —— 时代就变了。简单来说，如果你有一个视频，而且你恰好想提取它的的音频，那么恭喜你， FFmpeg 可以满足你。FFmpeg 是跨平台的，所以也可以在 Windows 上找到。Linux 下直接使用自己发行版的包管理器就可以安装，我的使用 Manjaro : <code>sudo pacman -S ffmpeg</code>。</p><p><img src="http://101.200.84.36/images/2022/04/24/202204242216842.png" alt="FFmpeg 官网"></p><p><code>ffmpeg -i input_file.mp4 output_file.mp3</code>就可以提取视频的音频。当然，各种操作多了去了，咱不是搞音视频开发的，很多参数看不懂，基本的操作了解就行。通过 <code>man ffmpeg</code> 或者 <code>ffmpeg --help</code> 查看更多的命令。FFmpeg 通常会附带 FFplay ，可以进行音视频的播放，功能还是很强大的 —— 不过我使用它来听过歌 <code>ffplay -showmode 0 -loop -1 -i unput_file.mp3</code>。<code>-showmode 0</code> 后面的 <code>0</code> 表示不用打开播放界面，因为播放界面会打开一个 GUI. <code>-loop</code> 是循环次数，后面跟一个数字，我接的是 <code>-1</code> (负一)，表示无限循环，如果是 <code>1</code> 、<code>3</code> 等，那就是循环一次或者三次。<code>-i</code> 后面跟着播放的文件。 </p><h2 id="Telnet-远程登陆工具"><a href="#Telnet-远程登陆工具" class="headerlink" title="Telnet 远程登陆工具"></a>Telnet 远程登陆工具</h2><p>Telnet 是一个远古的工具，在现代生产生活中扮演无名小卒，但是人家也曾辉煌过。现在我要介绍的，是建立在 Telnet 上的两个好玩东西：</p><ol><li><ruby>字符艺术<rt>ASCII</rt></ruby>《星球大战》</li><li><ruby>字符艺术<rt>ASCII</rt></ruby> 世界地图。</li></ol><p>上古时代有个大佬把《星战》做成了字符艺术，现在我们只需要在命令行上输入 <code>telnet towel.blinkenlights.nl</code> 就可以快速过一遍《星战》了 —— 作为非《星战》迷，我表示忍受不了电影的画质，但是很喜欢<ruby>字符艺术<rt>ASCII</rt></ruby>。</p><p><img src="http://101.200.84.36/images/2022/04/24/202204242231346.png" alt="二十世纪福克斯"></p><p><img src="http://101.200.84.36/images/2022/04/24/202204242229855.png" alt="老故事会了"></p><p><img src="http://101.200.84.36/images/2022/04/24/202204242227215.png" alt="家政机器原型"></p><p><img src="http://101.200.84.36/images/2022/04/24/202204242227678.png" alt="牛魔王"></p><p>其次就是命令行版的“谷歌地图”了—— <code>telnet mapscii.me</code> ，响应速度贼快。键盘操作，基本是 <kbd>h</kbd>、<kbd>j</kbd>、<kbd>k</kbd>、<kbd>l</kbd>左上下右移动，<kbd>a</kbd>、<kbd>z</kbd>放大缩小。</p><p><img src="http://101.200.84.36/images/2022/04/24/202204242234230.png" alt="image-20220424223452168"></p><p><img src="http://101.200.84.36/images/2022/04/24/202204242236997.png" alt="我大南开"></p><p><img src="http://101.200.84.36/images/2022/04/24/202204242239603.png" alt="我大新开湖"></p><p>当然，每次输入这么长的命令很麻烦，所以直接在自己家目录的 Shell 配置文件添加一下代码，我用 VIM 打开自己的 ZSh 配置文件</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ vim ~/.zshrc<br><br><span class="hljs-built_in">alias</span> map=<span class="hljs-string">&quot;telnet mapscii.me&quot;</span><br><span class="hljs-built_in">alias</span> strwrs=<span class="hljs-string">&quot;telnet towel.blinkenlights.nl&quot;</span><br></code></pre></div></td></tr></table></figure><p>保存退出后输入 <code>source ~/.zshrc</code> 就可以输入 <code>map</code> 或者 <code>strwrs</code> 代替长长的指令了。这里说明一下，如果使用的是 Bash， 需要配置的是 <code>.bashrc</code> 文件。</p><h1 id="后语"><a href="#后语" class="headerlink" title="后语"></a>后语</h1><p>本来想再推荐几个命令行游戏的，不过自己玩玩之后发现没玩明白 —— 索性就不介绍了。其实今天介绍的都比较冷门 —— 网易云其实也有命令行版本、Telnet 都是上古的工具了。还有诸如 cowsay、sl、oneko 等等好玩的东西没介绍 —— 不过也没办法，很多人现在谈到好玩的命令行就提 cowsay 让我觉得这个东西没必要介绍。</p><p>这篇文章算是敷衍忪懒的四月吧，希望五月能再勤一点。(也许后面会更一些 Rust 的文章？)</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>命令行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Chevereto 配合 PicGo 搭建自己的图床</title>
    <link href="/2022/03/31/Chevereto%E9%85%8D%E5%90%88PicGo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9B%BE%E5%BA%8A/"/>
    <url>/2022/03/31/Chevereto%E9%85%8D%E5%90%88PicGo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前一阵子，自己的图床没了觉得很可惜，当时还想，要不要去租个网络存储服务？等到冷静下来之后才想起：我有一个服务器来着！真是神奇。</p><p>有了想法自然要付诸行动，准备搭建自己的图床。之前我曾试着手动搭过 <ruby>LNMP<rt>Linux Nginx MariaDB PHP</rt></ruby>，可惜失败了。此外我还在自己的服务器里装过 OpenResty，所以还得进行一些清理工作。不得不说，当初搭建环境都是一次性代过，没有给服务器来个快照或者备份什么的，导致可能乱装了点啥——不过大多数时候我都会选择卸载掉自己安装的东东，除非哪个配置文件我忘了。</p><blockquote><p>LNMP 原来是指 Linux、Nginx、MySQL 和 PHP。只不过我用的是 MariaDB，所以没带上 MySQL.</p></blockquote><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>搭建图床服务的环境如下：</p><ol><li>Linux 服务器，我用的是 Rocky Linux 8.5, 同等于 RHEL 8 和 CentOS 8。因为安装完成之后我才写的博客，所以这次用 Docker 下的 Rocky Linux 8.5 演示，勉强看作一个虚拟机吧。</li><li><a href="https://www.lnmp.org/" title="LNMP">LNMP</a>，一键安装环境脚本，比手动简单多。我手动搭建过，各种配置太麻烦。这里提供一键安装它不香吗？</li><li>Chevereto，一个图床自建程序。</li><li>PicGo, 选择性。</li></ol><p>下面我们慢慢介绍。</p><h2 id="LNMP-安装"><a href="#LNMP-安装" class="headerlink" title="LNMP 安装"></a>LNMP 安装</h2><p>LNMP 是一个网站服务器框架。简而言之，网络上很多东西都建立在这个框架基础之上。只要搭好这个框架，除了图床还可以快速搭建博客、网站等等。背景什么的咱就不介绍了——毕竟我也不是行家。</p><p>登陆自己的服务器，下载一个叫做 screen 的程序。简单说一下，使用 SSH 登陆服务器久不操作连接会自己断开。当然，为什么我们不操作呢，是吧？其实还是有可能的，比如安装软件，特别是 Linux 系统，有些时候编译某些东东的时间很长，长时间不操作 SSH 链接会自己断开。在 Linux 系统中，我们的操作基本都来自操作终端——就是我们的命令行——如果连接断开，终端就终止了。终端终止，我们的所有操作就都终止了。这样我们不得不重试，重试之后又断开，反反复复。</p><p>为了避免这种情况，我们使用 screen 命令创建一个独立于当前终端的空间，即使我们的连接突然断了，命令仍然被执行。这就是保命的东西。我们的操作基本都需要超级管理员权限，所以索性切换到超级管理员——root</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">su - root<br>yum install screen -y<br></code></pre></div></td></tr></table></figure><p>安装完成之后使用 <code>screen -S lnmp</code> 创建一个叫做 lnmp 的空间。下载 <a href="https://www.lnmp.org/" title="LNMP">LNMP</a> 一键安装脚本，然后解压，进入自己解压的文件夹：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">axel -n 32 http://soft.vpser.net/lnmp/lnmp1.8.tar.gz<br>tar zxf lnmp1.8.tar.gz<br>cd lnmp1.8<br></code></pre></div></td></tr></table></figure><p>你可以选择自己喜欢的下载方式，我喜欢用 Axel 。</p><p><img src="http://101.200.84.36/images/2022/03/31/202203311924121.png" alt="下载解压"></p><p>使用 <code>ls</code> 查看你的目录，输入 <code>./install.sh</code> 进行安装。如果你用的和我一样，都是 Rocky Linux, 那么恭喜你，你中奖了，喜提错误警告：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">Unable to get Linux distribution name, or do NOT support the current distribution.<br></code></pre></div></td></tr></table></figure><p>这是因为这个脚本没有为 Rocky Linux 准备。现在有两个选择：选择其他发行版，自己动手改脚本。我选择后者。</p><p>输入 <code>vim include/main.sh</code> 打开脚本，按 <kbd>/</kbd>，输入 Get_Dist_Name 找到目标函数，如下。回车。</p><p>在 <code>if</code> 后面添加</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">elif grep -Eqi &quot;Rocky Linux&quot; /etc/issue || grep -Eq &quot;Rocky Linux&quot; /etc/*-release ;then<br>    DISTRO=&#x27;CentOS&#x27;<br>    PM=&#x27;yum&#x27;<br></code></pre></div></td></tr></table></figure><p><img src="http://101.200.84.36/images/2022/03/31/202203311928363.png" alt="打开脚本"></p><p><img src="http://101.200.84.36/images/2022/03/31/202203311935014.png" alt="修改配置"></p><p>这其实是让脚本以为自己在 CentOS 系统上运行——我说过 Rocky Linux 兼容 CentOS ，所以没必要担心。按 <kbd>Esc</kbd> ，输入 <code>:wq</code> ，回车，保存退出。重新执行脚本。</p><p>重新执行之后脚本会让你选择自己的数据库，如果知道的话就选择，不懂的直接默认。我选择最新的 MariaDB 10.4.19，所以输入 10. 后面设置数据库密码。</p><p><img src="http://101.200.84.36/images/2022/03/31/202203311940652.png" alt="选择数据库类型"></p><p><img src="http://101.200.84.36/images/2022/03/31/202203311943548.png" alt="设置密码"></p><p>安装 PHP。这就不是版本越高越好了，暂且选择 7.1 吧，因为我现在的数据库和 Chevereto 支持的就是这个版本。后面的那个内存分配器随便选择，也可以默认不选，我选择 2 。然后回车安装。</p><p><img src="http://101.200.84.36/images/2022/03/31/202203311946674.png" alt="PHP版本"></p><p>到这里，基本可以洗洗睡了——会安装很久。我的服务器在安装过程中 CPU 使用率直接飙到 90% 以上，基本使劲浑身解数来解决编译问题，最后还是花了 126 分钟，简直慢到死。不过现在是在自己的电脑演示，速度还是挺快的。</p><p>如果在等待的过程中，你的 SSH 连接断开了，你可以再次登陆自己的服务器，然后用 <code>screen -r lnmp</code> 恢复原来的工作。如果你忘了自己给取的名字是啥，使用 <code>screen -list</code> 查看。等到运行结束之后，可以直接用 <code>exit</code> 退出 screen .</p><p>我们使用脚本的另一个好处是，如果自己的环境配错了，可以修改。比如我安装了 PHP 高版本，但是需要的是低版本，可以是使用 <code>./upgrade.sh</code> 进行修改。手动的话，比较麻烦。同理，如果想要卸载，也可以使用我们下载的 LNMP 中的脚本完成。也可以去 <a href="https://www.lnmp.org/" title="LNMP">LNMP</a> 脚本官网查看教程。</p><p><img src="http://101.200.84.36/images/2022/03/31/202203312009531.png" alt="安装完成"></p><p>安装完成，使用了 22 分钟，比服务器强多了。我没有域名，所以就不搞虚拟主机了，直接上 IP.</p><p>看最后几行，上面提示 nginx、php-fpm 等都没有运行——按理来说是应该运行的，不过我用的 Docker, 所以不行而已。如果使用虚拟机或者服务器，通常应该没问题。例行公事，给他们开机自启的权限：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">systemctl <span class="hljs-built_in">enable</span> nginx<br>systemctl <span class="hljs-built_in">enable</span> php-fpm<br>systemctl <span class="hljs-built_in">enable</span> mariadb<br><br>systemctl restart nginx<br>systemctl restart php-fpm<br>systemctl restart mariadb<br></code></pre></div></td></tr></table></figure><p>这时候，<code>/home</code> 目录下会多出几个 www 开头的用户，其中 wwwroot 目录下的 default 就是我们的图床位置——可以随意改变位置，但是我只按照这个目录演示。</p><p>可以看到 default 目录下有一个 phpmyadmin 文件夹，待会我们会访问它。</p><p><img src="http://101.200.84.36/images/2022/03/31/202203312027429.png" alt="phpmyadmin"></p><p>打开配置文件，找到 server  有 <code>listen 80</code> 的那一部分配置。在 <code>include enable-php.conf</code> 后面添加以下配置：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">vim /usr/local/nginx/conf/nginx.conf<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">location / &#123;<br>    try_files <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span>/ /index.php?<span class="hljs-variable">$query_string</span>;<br>&#125;<br><br>location ~ [^/]\.php(/|$) &#123;<br>    fastcgi_pass unix:/tmp/php-cgi.sock;<br>    fastcgi_index index.php;<br>    include fastcgi.conf;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="http://101.200.84.36/images/2022/03/31/202203312033765.png" alt="配置"></p><p>注意配置里的一些字段，例如后面有的图片格式后面的括号显示有效期 ( expires ) 是 30 天。你可以修改自己的。</p><p>可以把 servername 改为自己的服务器公网 IP。</p><p>修改完之后，在浏览器中输入 <code>http://ip/phpmyadmin</code> 登陆创建数据库，用户是 root, 密码是你刚刚创建的，我的是 chunshuyumao.</p><blockquote><p><a href="http://ip/phpmyadmin">http://ip/phpmyadmin</a> 中的 IP 是指你的服务器公网 IP，而不是这两个字符。</p></blockquote><p><img src="http://101.200.84.36/images/2022/03/31/202203312040197.png" alt="登陆选择数据库"></p><p><img src="http://101.200.84.36/images/2022/03/31/202203312043700.png" alt="创建图床数据库"></p><p>创建数据库的时候，编码选择 utf8_general_ci . 我对数据库不是很了解，不能给专业的解释，只能告诉你这样避免乱码。</p><h2 id="Chevereto"><a href="#Chevereto" class="headerlink" title="Chevereto"></a>Chevereto</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>准备安装 <a href="https://github.com/rodber/chevereto-free" title="Chevereto">Chevereto</a>. 到 GitHub 下载压缩包或直接使用 <code>git clone</code> ，<a href="https://chevereto-free.github.io/" title="Chevereto官网">官网</a>了解教程。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">cd /tmp<br>axel -n 32 https://github.com/rodber/chevereto-free/archive/refs/heads/1.6.zip<br></code></pre></div></td></tr></table></figure><p>下载完之后解压、移动到 default 目录：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">unzip chevereto-free-1.6.zip &amp;&amp; mv chevereto-free-1.6/* /home/wwwroot/default/<br></code></pre></div></td></tr></table></figure><p>我下载的是 1.6 版，解压的时候需要看自己下载的是第几版，不要照抄我的步骤。解压之后 default 目录应该长这样：</p><p><img src="http://101.200.84.36/images/2022/03/31/202203312106787.png" alt="default 目录"></p><p>现在可以到浏览器直接输入你的服务器公网 IP 了：</p><p><img src="http://101.200.84.36/images/2022/03/31/202203312107148.png" alt="登陆 Chevereto"></p><p>当然，你最初看到的不是这个，而是一个初始界面。我没办法演示，但是你知道要填写这类信息就行：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">Database host --&gt; 这个不用动<br>Database name --&gt; 这个是你刚刚新建的数据库名字，我记得是 picbed<br>Database user --&gt; 填 root <br>Database user password --&gt; 上面你创建的密码，我的是 chunshuyumao<br></code></pre></div></td></tr></table></figure><p>之后就是你的一些信息了，随便填写，其中那三个邮箱地址可以一样。最后的 <strong>Website mode</strong> 选择 <strong>Person</strong>，如果你用的是中文的话是<strong>个人</strong>的意思。最后登陆即可。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>登陆 Chevereto, 右上角选择 Dashbord –&gt; Settings –&gt; Website，修改 Website privacy mode 为 private, 这样你的网站就不会被别人接触到了。</p><p><img src="http://101.200.84.36/images/2022/03/31/202203312120424.png" alt="设置"></p><p><img src="http://101.200.84.36/images/2022/03/31/202203312121054.png" alt="设置"></p><p><img src="http://101.200.84.36/images/2022/03/31/202203312123309.png" alt="修改为Website privacy mode 为 priavte"></p><p><img src="http://101.200.84.36/images/2022/03/31/202203312127809.png" alt="上传的图片"></p><p>你点击右上角的上传按钮进行上传——这个应该可以调成中文，我只是不想调而已。</p><p><img src="http://101.200.84.36/images/2022/03/31/202203312129523.png" alt="上传"></p><p>图床安装完毕。你的服务器里，图床在 &#x2F;home&#x2F;wwwroor&#x2F;default&#x2F;images 下边。</p><h3 id="配合-PicGO"><a href="#配合-PicGO" class="headerlink" title="配合 PicGO"></a>配合 PicGO</h3><p>如果你愿意使用 PicGO, 我很乐意告诉你怎么做。</p><p>打开 PicGo 查找 Chevereto 插件并安装，配置的时候 Url 写 <a href="http://ip/api/1/upload">http://ip/api/1/upload</a> . 例如我的：</p><blockquote><p>这里的 IP 指的是你的服务器公网 IP ，不是两个字符。如果你选择了其他端口，请把端口带上：</p><p><a href="http://ip:port/api/1/upload">http://ip:port/api/1/upload</a></p><p>例如：</p><p><a href="http://888.777.666:8080/api/1/upload">http://888.777.666:8080/api/1/upload</a> 就是 IP 为 888.777.666 ，端口为 8080</p></blockquote><p><img src="http://101.200.84.36/images/2022/03/31/202203312135945.png" alt="搜索 Chevereto 插件"></p><p><img src="http://101.200.84.36/images/2022/03/31/202203312136390.png" alt="配置"></p><p>还缺一个 Key. 打开我们的 Chevereto –&gt; Dash Board –&gt; Settings –&gt; Website –&gt; API，把你的 Key 复制一份填写即可。</p><p><img src="http://101.200.84.36/images/2022/03/31/202203312139840.png" alt="Key"></p><p>最后你就可以使用 PicGo 开心地上传自己的图床了！</p><p>——当然，你得记得在 PicGo 中把 Chevereto 设置为默认图床。</p><h1 id="后语"><a href="#后语" class="headerlink" title="后语"></a>后语</h1><p>这次没有超过 3000 字，又是一次胜利！步骤其实很简单，只是我们不够专业，所以才会觉得难。搭建完之后我试了试，发现图床并没有被公众号屏蔽——妙啊！这样一来，我以后要做的就是使用自己的图床，然后找个时间上传到 GitHub. 因为我的服务器只有一年的时间，到期我也未必续费，所以肯定需要转移自己的图片。一年之后的事一年之后再思考吧，现在为以后打算——以后就没事可做了。</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图床</tag>
      
      <tag>Chevereto</tag>
      
      <tag>PicGo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>闲话</title>
    <link href="/2022/03/27/%E9%97%B2%E8%AF%9D/"/>
    <url>/2022/03/27/%E9%97%B2%E8%AF%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天只想说一些闲话。</p><h1 id="正经吐嘈"><a href="#正经吐嘈" class="headerlink" title="正经吐嘈"></a>正经吐嘈</h1><p>最近自己的<ruby>码云<rt>Gitee</rt></ruby>图床仓库因为外链访问过多被官方封了，当然，人家还是给了我备份的机会。其实当时还是觉得蛮奇怪的，毕竟我只是用于自己的博客和临时作为微信的图床——公众号屏蔽外链但没有屏蔽<ruby>码云<rt>Gitee</rt></ruby>。后来发现除我之外，其他人也有同样的情况。不知是该喜还是该忧。找时间把自己的东西记录下来已经是万幸了，如今再添加这么一层阻碍，公众号基本没戏了——除非公众号更新的都是没有图片的文章。</p><p>公众号没有强制使用<ruby>码云<rt>Gitee</rt></ruby>的意思，而是我写文章使用的是 Markdown. 写完之后通过其他途径复制到公众号，这样就省去了排版的时间。为了减少和平台相关，我的图片通常放到某些地方——例如图床。放到图床之后，在 Markdown 里只需要使用图片的链接就可直接看到图片。公众号屏蔽了很多的网络链接——所以顺带就把我的图床链接也给屏蔽了。之前我一直用 sm.ms 图床，后来发现公众号使用不了就改用<ruby>码云<rt>Gitee</rt></ruby>。</p><p>当初没有想过码云是不允许使用仓库作为图床的。最近可能因为自己的博客被浏览的次数比较多，至少<ruby>码云<rt>Gitee</rt></ruby>方面给的理由是外链访问过多，所以引起了别人的注意。为了安全起见，我把自己的图片转移到了 GitHub 平台——因为这个平台说过把它用作图床不违法。国外的平台访问较慢，不过加加速就可以了。</p><p>然而问题来了，公众号屏蔽 GitHub. 公众号不屏蔽的基本是国内付费的专用网络存储平台，例如 阿里云OSS 这类。用图床无非就是图简单，上传到公众号之后，公众号会保存备份。为了一个临时的存储去开通专用服务没多大必要——虽然也不贵，所以我就笃定使用 GitHub 了。这么一来，我的图片自然就转不了公众号了。当然，我可以选择手动上传，然后一个一个插入文章中。可惜我只是玩玩公众号，不想花大量的体力劳动在这些无意义的事。我本来就很懒，多一秒的事我都觉得烦，自然不愿意受这种罪。最后思来想去，觉得确实没必要为了公众号的图片上传大费周章。</p><p>其实我是有想过其他办法的，比如昨天我就几乎花了一天测试各种图床，希望有一个可以被公众号接纳——我最开始只是想写公众号，后来才去玩博客。可惜，国内被公众号接纳的图床都是不可能白嫖的。反正也是白嫖，我又有什么理由争辩？嫖不了只能说明我们需要回报社会了。</p><p>其实得知自己仓库被封的时候我刚写完一篇博客，寻思着这个时间检查错别字然后发公众号——因为公众号允许更改的错别字有限，我公众号的推送就一堆错别字。结果看看邮箱才发现麻烦大了。写了封信给管理员，人家好歹抽出时间看了我的信，给咱解了封——毕竟咱小喽罗，掀不起风浪。不过俗话说的好，一朝被蛇咬十年怕井绳。今天不知者被封 16 小时，后面就是再犯了，鬼知道封多久。果断卷铺盖走人。</p><p>迁移图片的时候还行，无非就是修改一下图片链接地址。然而 GitHub 毕竟访问慢，在不违法的情况下正常使用它有点吃力。迁移只需要修改博客也是一大幸——突然觉得公众号保留图片的备份真好，免得自己之前的推送图片全飞了。因为之前写过一篇把<ruby>码云<rt>Gitee</rt></ruby>变图床的推送和博客，博客是可以修改，公众号改不了了。这里还是说说，慎用<ruby>码云<rt>Gitee</rt></ruby>作为图床，至少对我来说，我已见识过惊吓带来的恐慌。</p><p>刚写完自己的文章，图床就被封着实有点神奇，迁移图片的时候走了很多弯路，无意中还删了自己刚写完的文章。不得不说，完全没有后悔药。好巧不巧，我的坚果云当时同步的位置恰好没改过来，Typora 的草稿恢复区也只有我写的第二篇，Linux 的 debugfs 我又不会用——毕竟之前没碰到过这种情况。等到了解 debugfs 之后发现实操和理想中的不一样。情急之下，下载 Pandoc 准备将自己的博客 HTML 文件转换为 Markdown。结果发现，转换成功是成功了，但是排版惨不忍睹。所有的补救措施都没有用，我只好纯手工把网页上的文字重新复制下来，重写一遍 Markdown 版本的文章。就这样，一天就在尝试寻找不被屏蔽的图床和恢复文章中过去了。</p><p>当时都想摆——毕竟博客保留了一份 HTML 版，又害怕自己上传博客的时候喜欢清除以前的文章，搞不好哪天就被自己手贱清掉了，最后才选择手动复制。因为是复制的，我也就懒得检查有没有错别字了——自己觉得还原度还行。</p><p>因为那两篇博客的图片都很多，如果不手动上传图片到公众号是没有办法直接发布的。既然这么麻烦，索性摆烂，直接不上传公众号了。如果以后再写有关的推送，可能会选择多一点的语言描述，尽量减少图片的使用。</p><p>这有点负能量，不过看看自己公众号，最近还是有几个人关注的，寻思着多半是觉得其中的某些推送写的还可以，选择了关注。不过照此看来，将来的推送少有图片，写的还可以的推送就不大可能了。这都什么年代了，谁还看文字？所以今天心血来潮，写写最近的状况，不想让自己关注的公众号晾着的小伙伴可以取关了。</p><h1 id="后语"><a href="#后语" class="headerlink" title="后语"></a>后语</h1><p>老规矩，有前言自然有后语，这叫例行公事。其实也没有写的那么悲观，只是觉得有点可惜。我之前选择公众号而不是博客就是因为公众号会保存我的文字和图片，玩博客还需要依靠图床。不架设自己的博客系统就得依赖别人的服务，靠别人的东西哪天别人收走了自己一无所有。综合来说，还是公众号好一点——至少只要自己不违法，那东西就在那里。可惜现在情况变了，在简便和稳定面前，我选择了简便——毕竟自己这么说也还保留着博客源文件，如果真的突然博客也不能用了，源文件在，哪里不能记录？但要为了保留自己的一份备份，花大把时间上传图片，然后再一个一个插入到文章当中，我可做不到。只希望公众号哪天可以解除一些不必要的外链屏蔽。</p><p>等因奉此。</p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图床</tag>
      
      <tag>公众号</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于百度翻译 API：手撸一个命令行翻译脚本--进阶</title>
    <link href="/2022/03/26/%E5%9F%BA%E4%BA%8E%E7%99%BE%E5%BA%A6%E7%BF%BB%E8%AF%91-API%EF%BC%9A%E6%89%8B%E6%92%B8%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BF%BB%E8%AF%91%E8%84%9A%E6%9C%AC-%E8%BF%9B%E9%98%B6/"/>
    <url>/2022/03/26/%E5%9F%BA%E4%BA%8E%E7%99%BE%E5%BA%A6%E7%BF%BB%E8%AF%91-API%EF%BC%9A%E6%89%8B%E6%92%B8%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BF%BB%E8%AF%91%E8%84%9A%E6%9C%AC-%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>正事从 2. 开始，前言只是发牢骚。</p><p>前面我们已经完成了翻译脚本的基本功能。所有的编程语言最大的问题一直是字符串，Shell 也一样。当我准备写下这一篇的时候还在想：要不要先出一篇介绍 Shell 编程的博客？Shell 语言和其他的编程语言也不太一样，我们更习惯叫它“脚本语言”，可惜这也不够准确。我觉得要真的做比较，可以看出做是高级的批处理语言。</p><p>前一阵子的翻译脚本，实际看来不复杂。原本打算一篇写完，结果还没写多少就突破三千字。不得不说，现在市面上各种叫嚣几分钟学会某种东西的声音太多，能有人抽出时间看完三千字不大可能，所以我直接断笔，把剩下的部分独立出来。这次尽量一篇写完。</p><h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><p>前一篇我们让脚本后面的参数直接充当 query 参数的值，也就是说我们只能这样使用我们的翻译脚本 <code>./mt.sh 翻译的文本</code>。可是看到 Linux 上的命令通常都有很多的命令参数，怎么看自己的脚本都太简单了。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203260911243.png" alt="简单脚本"></p><p>此外，我们的脚本如果被其他人使用，别人不知道怎么使用怎么办？我们还希望自己的脚本可配置翻译语言和目的语言。鉴于这些要求，我们需要扩展之前的命令行参数。</p><p>这里复习一下：所谓命令行参数，指的是脚本之后跟着的字符。举个例子：<code>./mt.sh chun shu yu mao</code> 的命令行参数是 <code>./mt.sh</code>、<code>chun</code>、<code>shu</code>、<code>yu</code>和 <code>mao</code>，其中参数使用<code>$n</code>表示，n 是阿拉伯数字，不能超过 9 。</p><p>先确定我们需要什么参数。根据之前的分析，我们知道：from 表示源语言，to 表示目的语言，q 表示翻译文本。那好，我们就设置这些参数。我们习惯在参数前面加 <code>-</code> 表示参数，其中长参数使用两个短杆，短参数用一个。所以我们的目标是这样：</p><table><thead><tr><th align="center">参数值</th><th align="center">短参数</th><th align="center">长参数</th></tr></thead><tbody><tr><td align="center">from</td><td align="center">-f</td><td align="center">–from</td></tr><tr><td align="center">to</td><td align="center">-t</td><td align="center">–to</td></tr><tr><td align="center">q</td><td align="center">-q</td><td align="center">–query</td></tr></tbody></table><p>以后我们希望这样调用脚本：<code>./mt.sh -f en -t zh -q Yeah</code>，这样写的好处是可以随意调换参数位置，例如可以这样写：<code>./mt.sh -q Yeah -t zh -f en</code></p><h1 id="解析参数"><a href="#解析参数" class="headerlink" title="解析参数"></a>解析参数</h1><p>要读取参数，我们需要一个循环。Shell 中的循环可以使用 while 。然后我们需要获取参数的个数，这样我们才能确定循环的次数。在 Shell 使用 <code>$#</code> 获取参数个数，所以我们的脚本框架是这样的：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">while [ $# -gt 0 ]; do<br>   <br>    echo $1<br>    <br>    shift<br>done<br></code></pre></div></td></tr></table></figure><p>在 Shell 中使用比较需要放到一个方括号<code>[]</code>里边，而且数值比较不能使用 <code>&lt;</code> 等符号，而是英语简写。</p><table><thead><tr><th align="center">中文</th><th align="center">简写</th><th align="center">英文</th></tr></thead><tbody><tr><td align="center">小于</td><td align="center">-lt</td><td align="center">less than</td></tr><tr><td align="center">大于</td><td align="center">-gt</td><td align="center">greater than</td></tr><tr><td align="center">等于</td><td align="center">-eq</td><td align="center">equal</td></tr><tr><td align="center">小于等于</td><td align="center">-le</td><td align="center">less than or equal</td></tr><tr><td align="center">大于等于</td><td align="center">-ge</td><td align="center">greater than or equal</td></tr><tr><td align="center">不等于</td><td align="center">-ne</td><td align="center">not equal</td></tr></tbody></table><p>我们的 while 循环就是表示：当参数个数大于 0 个的时候开始是循环。要注意，因为 <code>$0</code> 默认表示脚本的名字，<code>$#</code> 不把它算上。也就说，<code>./mt.sh chun shu yu mao</code> 的参数总数是 4 而不是 5.</p><p><code>shift</code> 表示偏移。这个有点难理解：还是拿 <code>./mt.sh chun shu yu mao</code> 来说，原本 <code>$1</code> 表示 <code>chun</code>，使用一个 <code>shift</code> 之后 <code>$1</code> 变成了 <code>shu</code>，再使用就是 <code>yu</code> 。<code>shift</code> 偏移之后参数个数就少了，所以我们处理完一个参数就用 <code>shift</code> 扔掉这个参数，直到所有参数都被处理完。</p><p>想要判断这个参数是 <code>-t</code> 还是 <code>-f</code> ，大家的想法可能是 <code>if</code> 语句。但是在这里， <code>if</code> 语句不好处理，推荐使用 <code>case</code> 语句。<code>case</code> 就像 C&#x2F;C++ 语言中的 <code>switch</code>，Python3.10 之后的 <code>match</code> 。<code>case</code> 还可以用 <code>|</code> 表示或者，例如 <code>ab|bc</code> 表示匹配 <code>ab</code> 或者 <code>bc</code> ，语法是：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">case 参数 in<br>匹配1) 处理<br>;;<br>匹配2) 处理<br>;;<br>匹配3|匹配4) 处理<br>;;<br>esac<br></code></pre></div></td></tr></table></figure><p>​既然如此，我们的脚本应该这样</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> [ <span class="hljs-variable">$#</span> -gt 0 ]; <span class="hljs-keyword">do</span><br><br>  <span class="hljs-keyword">case</span> <span class="hljs-variable">$1</span> <span class="hljs-keyword">in</span><br>    <span class="hljs-string">&#x27;-t&#x27;</span>|<span class="hljs-string">&#x27;--to&#x27;</span>) <br>    to=<span class="hljs-variable">$2</span><br>    <span class="hljs-built_in">shift</span><br>    ;;<br>    <span class="hljs-string">&#x27;-f&#x27;</span>|<span class="hljs-string">&#x27;--from&#x27;</span>)<br>    from=<span class="hljs-variable">$2</span><br>    <span class="hljs-built_in">shift</span><br>    ;;<br>    <span class="hljs-string">&#x27;-q&#x27;</span>|<span class="hljs-string">&#x27;--query&#x27;</span>)<br>    query=<span class="hljs-variable">$2</span><br>    <span class="hljs-built_in">shift</span><br>    ;;<br>  <span class="hljs-keyword">esac</span><br>  <span class="hljs-built_in">shift</span><br><span class="hljs-keyword">done</span><br></code></pre></div></td></tr></table></figure><p>我们判断了 <code>$1</code> 表示某个符号之后，直接读取它后边的参数，所以读取 <code>$2</code>，过程如下：</p><ol><li>执行脚本 <code>./mt.sh -f en -t zh -q text</code></li><li>进入 <code>case</code> ，判断 <code>$1</code> 是 <code>-f</code>，所以读取 <code>$2</code> 也就是 <code>en</code>。执行一次偏移，现在 <code>$1</code> 变成了 <code>en</code>.</li><li>跳出 <code>case</code>，执行一次 <code>shift</code> ，现在 <code>$1</code> 是 <code>-t</code> .</li><li>下一次循环，又回到第 2 步</li></ol><p>在 Shell 中，我们有一个简写：如果前一步执行成功，我们可以用 <code>&amp;&amp;</code> 执行下一步，所以上面可以写成这样：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">while [ $# -gt 0 ]; do<br><br>case $1 in<br>&#x27;-t&#x27;|&#x27;--to&#x27;) to=$2 &amp;&amp; shift ;;<br>&#x27;-f&#x27;|&#x27;--from&#x27;) from=$2 &amp;&amp; shift ;;<br>&#x27;-q&#x27;|&#x27;--query&#x27;) query=$2 &amp;&amp; shift ;;<br>esac<br>shift<br>done<br></code></pre></div></td></tr></table></figure><p>现在我们的脚本如下，顺便测试一下：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">encoding:utf-8</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">翻译 HTTPS 地址</span><br>declare -r basic_url=&quot;https://api.fanyi.baidu.com/api/trans/vip/translate&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">APPID</span><br>declare -r appid=&quot;xxxxxxxxxxxxxxxxxxxx&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">密钥</span><br>declare -r token=&quot;xxxxxxxxxxxxxxxxxxxx&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">random code</span> <br>declare salt=$(openssl rand -base64 18|cut -c 1-10)<br><br>decalre from<br>declare to<br>declare query<br><br>while [ $# -gt 0 ]; do<br>  case $1 in<br>    &#x27;-t&#x27;|&#x27;--to&#x27;) to=$2 &amp;&amp; shift ;;<br>    &#x27;-f&#x27;|&#x27;--from&#x27;) from=$2 &amp;&amp; shift ;;<br>    &#x27;-q&#x27;|&#x27;--query&#x27;) query=$2 &amp;&amp; shift ;;<br>  esac<br>  shift<br>done<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">翻译</span><br>sign=$(echo -n &quot;$appid$query$salt$token&quot; | md5sum | cut -c 1-32)<br><br>query=$(echo &quot;$query&quot; | tr -d &#x27;\n&#x27; | xxd -plain | sed &#x27;s/\(..\)/%\1/g&#x27;)<br>query=$(echo $query | sed &#x27;s/ //g&#x27; )<br><br>result=$(curl &quot;$basic_url?q=$query&amp;from=$from&amp;to=$to&amp;appid=$appid&amp;salt=$salt&amp;sign=$sign&quot; 2&gt;/dev/null)<br>result=&quot;$&#123;result##*dst\&quot;:\&quot;&#125;&quot;<br>echo -e $&#123;result%\&quot;\&#125;\]\&#125;&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203261002830.png" alt="中英互译"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203261006717.png" alt="中英互译"></p><p>大多数时候，我们都是从英文翻译到中文，每次都写这么多的参数实在麻烦，所以我们在 <code>while</code> 之后写参数默认值：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">while [ $# -gt 0 ]; do<br>  case $1 in<br>    &#x27;-t&#x27;|&#x27;--to&#x27;) to=$2 &amp;&amp; shift ;;<br>    &#x27;-f&#x27;|&#x27;--from&#x27;) from=$2 &amp;&amp; shift ;;<br>    &#x27;-q&#x27;|&#x27;--query&#x27;) query=$2 &amp;&amp; shift ;;<br>  esac<br>  shift<br>done<br><br>if [ -z $from ]; then <br>  from=&#x27;auto&#x27;<br>fi<br><br>if [ -z $to ]; then<br>  to=&#x27;zh&#x27;<br>fi<br><br>sign=$(echo -n &quot;$appid$query$salt$token&quot; | md5sum | cut -c 1-32)<br></code></pre></div></td></tr></table></figure><p><code>[ -z $from ]</code> 表示，如果 <code>$from</code> 是空( zero )的字符串，就执行 <code>if</code> 里边的语句。这样看起来有点不舒服，我们可以用上面学到的知识修改成下面的语句：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">[ -z $from ] &amp;&amp; from=&#x27;auto&#x27;<br>[ -z $to ] &amp;&amp; to=&#x27;zh&#x27;<br></code></pre></div></td></tr></table></figure><p>上面两种形式是等价的，大抵意思是说：源语言自动判断——百度翻译有这个功能，目标语言默认是中文。这样，如果我们可以简单使用 <code>./mt.sh -q 文本</code> 进行翻译。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203261018479.png" alt="测试"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203261021075.png" alt="阿拉伯语"></p><p>到这里，翻译部分基本讲完了。</p><h1 id="拓展功能"><a href="#拓展功能" class="headerlink" title="拓展功能"></a>拓展功能</h1><p>大多数的命令行工具都可以使用 <code>命令 --help</code> 查看帮助，所以我们也假模假样搞一个帮助的文本。我的文本如下：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">&#x27;-h&#x27;|&#x27;--help&#x27;)<br>  echo &quot;Usage: $0 [OPTION]&quot; <br>  echo &quot;Valid options are:&quot;<br>  echo -e &quot; -q, --query\t\ttext want to translate&quot;<br>  echo -e &quot; -f, --from\t\tsource language. auto detect default&quot;<br>  echo -e &quot; -t, --to\t\tdestinate language, Chinese default&quot;<br>  echo -e &quot; -l, --list\t\tlist all support languages&quot;<br>  echo -e &quot; -i, --interact\t\tenter interact mode&quot;<br>  echo -e &quot; -c, --clear\t\tclear the screen&quot;<br>  echo -e &quot; cmd\t\t\tonly on interact mode. use to set settings, same as above.&quot;<br>  echo &quot;&quot;<br>  echo &quot;example:&quot;<br>  echo &quot;$0 -f en -t zh -q &#x27;I like it.&#x27;&quot;<br>  echo &quot;$0 &#x27;I like it&#x27;&quot;<br>  echo &quot;&quot;<br>  echo &quot;when use &#x27;$0 -i&#x27; you can type such command to change settings&quot;<br>  echo &quot;    &gt;cmd -f zh -t en&quot;<br>  ;;<br></code></pre></div></td></tr></table></figure><p>把上面的文本放到 <code>while</code> 循环的  <code>case</code> 中。这里我还写了一些拓展，例如交互模式(interact mode)。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203261028368.png" alt="帮助"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203261030188.png" alt="使用帮助"></p><p>可以看到，列出帮助之后脚本仍旧执行翻译，所以后面出现报错。我们需要设置列出帮助之后直接退出脚本，在脚本中写下 <code>exit 0</code>。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">echo &quot;    &gt;cmd -f zh -t en&quot;<br>exit 0<br>;;<br></code></pre></div></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><code>case</code> 分支 <code>--help</code>  看起来占位置，还不好看。我们可以写一个函数，把里边的语句单独提出来，然后调用脚本，这样脚本就可以写成：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">function uasge()&#123;<br><span class="hljs-meta prompt_">   # </span><span class="language-bash">这里写 <span class="hljs-built_in">echo</span> ...</span><br>&#125;<br><br>while [ $# -gt 0 ]; do<br>  case $1 in<br>    &#x27;-t&#x27;|&#x27;--to&#x27;) to=$2 &amp;&amp; shift ;;<br>    &#x27;-f&#x27;|&#x27;--from&#x27;) from=$2 &amp;&amp; shift ;;<br>    &#x27;-q&#x27;|&#x27;--query&#x27;) query=$2 &amp;&amp; shift ;;<br>    &#x27;-h&#x27;|&#x27;--help&#x27;) usage &amp;&amp; exit 0 ;;<br>  esac<br>  shift<br>done<br></code></pre></div></td></tr></table></figure><p>Shell 中的脚本调用不用括号，直接列出函数名，如果有参数就直接放后面：<code>func para1 para2 para3</code>.</p><p>同理，完善 <code>--list</code> 列出支持的语言翻译的时候可以写成</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">function uasge()&#123;<br><span class="hljs-meta prompt_">   # </span><span class="language-bash">这里写 <span class="hljs-built_in">echo</span> ...</span><br>&#125;<br><br>function language_support()&#123;<br><br>  echo -e &quot;name\t\tid&quot;<br>  echo -e &quot;Chinese\t\tzh&quot;<br>  echo -e &quot;  --Traditional\tcht&quot;<br>  echo -e &quot;  --Classical\twyw&quot;<br>  echo -e &quot;  --Cantonese\tyue&quot;<br>  echo -e &quot;English\t\ten&quot;<br>  echo -e &quot;Japanese\tjp&quot;<br>  echo -e &quot;Spanish\t\tspa&quot;<br>  echo -e &quot;Russian\t\tru&quot;<br>  echo -e &quot;Italic\t\tit&quot;<br>  echo -e &quot;Polish\t\tpl&quot;<br>  echo -e &quot;Danish\t\tdan&quot;<br>  echo -e &quot;Romanian\trom&quot;<br>  echo -e &quot;Hugarian\thu&quot;<br>  echo -e &quot;Korean\t\tkor&quot;<br>  echo -e &quot;Thai\t\tth&quot;<br>  echo -e &quot;Portuguese\tpt&quot;<br>  echo -e &quot;Greek\t\tel&quot;<br>  echo -e &quot;Bulgarian\tbul&quot;<br>  echo -e &quot;Finnish\t\tfin&quot;<br>  echo -e &quot;Slovene\t\tslo&quot;<br>  echo -e &quot;French\t\tfra&quot;<br>  echo -e &quot;Arabic\t\tara&quot;<br>  echo -e &quot;German\t\tde&quot;<br>  echo -e &quot;Dutch\t\tnl&quot;<br>  echo -e &quot;Estonia\t\test&quot;<br>  echo -e &quot;Czech\t\tcs&quot;<br>  echo -e &quot;Swedish\t\tswe&quot;<br>  echo -e &quot;Vietnamese\tvie&quot;<br>  echo -e &quot;and so on&quot;<br>&#125;<br><br>while [ $# -gt 0 ]; do<br>  case $1 in<br>    &#x27;-t&#x27;|&#x27;--to&#x27;) to=$2 &amp;&amp; shift ;;<br>    &#x27;-f&#x27;|&#x27;--from&#x27;) from=$2 &amp;&amp; shift ;;<br>    &#x27;-q&#x27;|&#x27;--query&#x27;) query=$2 &amp;&amp; shift ;;<br>    &#x27;-h&#x27;|&#x27;--help&#x27;) usage &amp;&amp; exit 0 ;;<br>    &#x27;-l&#x27;|&#x27;--list&#x27;) language_support &amp;&amp; exit 0 ;;<br>  esac<br>  shift<br>done<br></code></pre></div></td></tr></table></figure><p>到这里，我们的脚本基本完善了，就差一个交互模式了。</p><h2 id="交互模式"><a href="#交互模式" class="headerlink" title="交互模式"></a>交互模式</h2><p>每次翻译我们都需要执行一次脚本太麻烦了，我们希望可以做到执行一次脚本后保留之前的设置继续翻译。此外，如果我们突然想改变翻译的一些设置，也可通过交互模式直接改变，而不用退出重新设置。这基本是交互模式的工作。</p><p>交互模式，顾名思义，我们就用 <code>-i</code> 和 <code>--interact</code> 代替。在你的 <code>case</code> 给交互模式赏一个分支：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">&#x27;-i&#x27;|&#x27;--interact&#x27;)<br>;;<br></code></pre></div></td></tr></table></figure><p>如果调用交互模式的指令是：<code>./mt.sh -i -f en -t zh</code>，我们希望脚本先分析完参数再执行交互模式。这样一来，<code>case</code> 的交互模式分支就不能用函数了。我们设置一个标志符，确认是不是交互模式。大概如下：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><br>declare -i interaction=0<br>while [ $# -gt 0 ]; do<br><span class="hljs-meta prompt_">  # </span><span class="language-bash">...</span><br>    &#x27;-i&#x27;|&#x27;--interact&#x27;) interaction=1 ;;<br><span class="hljs-meta prompt_">  # </span><span class="language-bash">...</span><br>done<br></code></pre></div></td></tr></table></figure><p>后面我们再判断是不是交互模式。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">[ -z $from ] &amp;&amp; from=&#x27;auto&#x27;<br>[ -z $to ] &amp;&amp; to=&#x27;zh&#x27;<br><br>[ $interaction -eq 1 ] &amp;&amp; interact &amp;&amp; exit 0<br></code></pre></div></td></tr></table></figure><p>这次就需要写一个 interact 函数了。可以把函数放到 <code>while</code> 循环之前。</p><p>我们的想法是，交互模式一行一行读取我们的输入，就像这样：</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203261109882.png" alt="交互模式"></p><p>上面我设置了 <code>cmd</code> 作为交互模式修改设置的关键字，也就是而已使用 <code>cmd + 参数</code> 修改语言翻译的设置。</p><p>交互模式的函数如下：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">function interact()&#123;<br><br>  while read -p &quot;&gt;&quot; query; do<br>    [[ -z &quot;$query&quot; ]] &amp;&amp; continue<br>    [[ &quot;$query&quot; =~ &quot;cmd &quot; ]] &amp;&amp; commands &amp;&amp; continue<br>    <br>    # translate<br>  done<br>&#125;<br></code></pre></div></td></tr></table></figure><p>一行一行解释，<code>read</code> 是 Shell 读取输入的方式，就像 Python 的 input()、C++ 的 std::cin 、C 语言的 scanf() 等。<code>-p</code> 表示不换行，后面跟着提示符 <code>&gt;</code> ，然后就是读取的字符。我们使用 <code>while</code> 读取循环，也就说，只有存在输入的时候才执行下面的语句，避免一直循环占用内存。</p><p>下一行表示，如果没有输入——例如我们直接回车——那继续循环，不执行命令。</p><p>再下一行表示，如果 <code>query</code> 包含 <code>cmd</code> 字符串，那就执行 commands 函数，然后继续循环，不执行后面的语句。</p><blockquote><p>Shell 中判断是否包含某一字符串使用 <code>=~</code> ，例如  A 字符串是否包含 B 字符串</p><blockquote><p>[[ A &#x3D;~ B ]]</p></blockquote></blockquote><p>再后面就是我们的翻译语句了。</p><p><strong>拷贝</strong>我们的翻译语句，放到 <code>#translate</code> 的位置，就像这样：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">function interact()&#123;<br><br>  while read -p &quot;&gt;&quot; query; do<br>    [[ -z &quot;$query&quot; ]] &amp;&amp; continue<br>    [[ &quot;$query&quot; =~ &quot;cmd &quot; ]] &amp;&amp; commands &amp;&amp; continue<br>    <br>    sign=$(echo -n &quot;$appid$query$salt$token&quot; | md5sum | cut -c 1-32)<br><br>    query=$(echo &quot;$query&quot; | tr -d &#x27;\n&#x27; | xxd -plain | sed &#x27;s/\(..\)/%\1/g&#x27;)<br>    query=$(echo $query | sed &#x27;s/ //g&#x27; )<br><br>    result=$(curl &quot;$basic_url?q=$query&amp;from=$from&amp;to=$to&amp;appid=$appid&amp;salt=$salt&amp;sign=$sign&quot; 2&gt;/dev/null)<br>    result=&quot;$&#123;result##*dst\&quot;:\&quot;&#125;&quot;<br>    echo -e $&#123;result%\&quot;\&#125;\]\&#125;&#125;<br>  done<br>&#125;<br><br>declare -i interaction=0<br>while [ $# -gt 0 ]; do<br>  case $1 in<br>    &#x27;-t&#x27;|&#x27;--to&#x27;) to=$2 &amp;&amp; shift ;;<br>    &#x27;-f&#x27;|&#x27;--from&#x27;) from=$2 &amp;&amp; shift ;;<br>    &#x27;-q&#x27;|&#x27;--query&#x27;) query=$2 &amp;&amp; shift ;;<br>    &#x27;-h&#x27;|&#x27;--help&#x27;) usage &amp;&amp; exit 0 ;;<br>    &#x27;-l&#x27;|&#x27;--list&#x27;) language_support &amp;&amp; exit 0 ;;<br>    &#x27;-i&#x27;|&#x27;--interact&#x27;) interaction=1 ;;<br>  esac<br>  shift<br>done<br><br>[ -z $from ] &amp;&amp; from=&#x27;auto&#x27;<br>[ -z $to ] &amp;&amp; to=&#x27;zh&#x27;<br><br>[ $interaction -eq 1 ] &amp;&amp; interact &amp;&amp; exit 0<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">翻译</span><br>sign=$(echo -n &quot;$appid$query$salt$token&quot; | md5sum | cut -c 1-32)<br><br>query=$(echo &quot;$query&quot; | tr -d &#x27;\n&#x27; | xxd -plain | sed &#x27;s/\(..\)/%\1/g&#x27;)<br>query=$(echo $query | sed &#x27;s/ //g&#x27; )<br><br>result=$(curl &quot;$basic_url?q=$query&amp;from=$from&amp;to=$to&amp;appid=$appid&amp;salt=$salt&amp;sign=$sign&quot; 2&gt;/dev/null)<br>result=&quot;$&#123;result##*dst\&quot;:\&quot;&#125;&quot;<br>echo -e $&#123;result%\&quot;\&#125;\]\&#125;&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到，有好多重复的语句，特别是翻译的部分，所以我们写一个翻译的函数，直接调用：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">function translate()&#123;<br><br>  sign=$(echo -n &quot;$appid$query$salt$token&quot; | md5sum | cut -c 1-32)<br><br>  query=$(echo &quot;$query&quot; | tr -d &#x27;\n&#x27; | xxd -plain | sed &#x27;s/\(..\)/%\1/g&#x27;)<br>  query=$(echo $query | sed &#x27;s/ //g&#x27; )<br><br>  result=$(curl &quot;$basic_url?q=$query&amp;from=$from&amp;to=$to&amp;appid=$appid&amp;salt=$salt&amp;sign=$sign&quot; 2&gt;/dev/null)<br>  result=&quot;$&#123;result##*dst\&quot;:\&quot;&#125;&quot;<br>  echo -e $&#123;result%\&quot;\&#125;\]\&#125;&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后脚本变成</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">function interact()&#123;<br><br>  while read -p &quot;&gt;&quot; query; do<br>    [[ -z &quot;$query&quot; ]] &amp;&amp; continue<br>    [[ &quot;$query&quot; =~ &quot;cmd &quot; ]] &amp;&amp; commands &amp;&amp; continue<br>    <br>    translate<br>  done<br>&#125;<br><br>declare -i interaction=0<br>while [ $# -gt 0 ]; do<br>  case $1 in<br>    &#x27;-t&#x27;|&#x27;--to&#x27;) to=$2 &amp;&amp; shift ;;<br>    &#x27;-f&#x27;|&#x27;--from&#x27;) from=$2 &amp;&amp; shift ;;<br>    &#x27;-q&#x27;|&#x27;--query&#x27;) query=$2 &amp;&amp; shift ;;<br>    &#x27;-h&#x27;|&#x27;--help&#x27;) usage &amp;&amp; exit 0 ;;<br>    &#x27;-l&#x27;|&#x27;--list&#x27;) language_support &amp;&amp; exit 0 ;;<br>    &#x27;-i&#x27;|&#x27;--interact&#x27;) interaction=1 ;;<br>  esac<br>  shift<br>done<br><br>[ -z $from ] &amp;&amp; from=&#x27;auto&#x27;<br>[ -z $to ] &amp;&amp; to=&#x27;zh&#x27;<br><br>[ $interaction -eq 1 ] &amp;&amp; interact &amp;&amp; exit 0<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">翻译</span><br>translate<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203261129188.png" alt="交互"></p><p>接下来写 <code>commands</code>. 编写 <code>commands</code> 函数之前我们知道，其内部的解析实际上和解析脚本参数基本一样，所以我们要做的就是去除 <code>cmd </code> 字符串，然后把后面的参数发给原本的参数解析函数——原本只是普通语句，我们也需要把它封装起来，所以就变成下面这样：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">...</span><br><br>function commands()&#123;<br><br>  local args=$(echo &quot;$query&quot; | sed &#x27;s/cmd\ //g&#x27;)<br>  query=&#x27;&#x27;<br>  settings $args<br>&#125;<br><br>function interact()&#123;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">...</span><br>&#125;<br><br>declare -i interaction=0<br><br>function settings()&#123;<br><br>  while [ $# -gt 0 ]; do<br>    case $1 in<br>      &#x27;-t&#x27;|&#x27;--to&#x27;) to=$2 &amp;&amp; shift ;;<br>      &#x27;-f&#x27;|&#x27;--from&#x27;) from=$2 &amp;&amp; shift ;;<br>      &#x27;-q&#x27;|&#x27;--query&#x27;) query=$2 &amp;&amp; shift ;;<br>      &#x27;-h&#x27;|&#x27;--help&#x27;) usage &amp;&amp; return 0 ;;<br>      &#x27;-l&#x27;|&#x27;--list&#x27;) language_support &amp;&amp; return 0 ;;<br>      &#x27;-i&#x27;|&#x27;--interact&#x27;) interaction=1 ;;<br>      *） query=$1 ;;<br>    esac<br>    shift<br>  done<br>&#125;<br><br>settings $@<br><br>[ -z $from ] &amp;&amp; from=&#x27;auto&#x27;<br>[ -z $to ] &amp;&amp; to=&#x27;zh&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">...</span><br></code></pre></div></td></tr></table></figure><p>鉴于放到了函数里，我们就不使用 <code>exit 0</code> 了，而是改成 <code>return 0</code> . 而且，我们的 <code>while</code>循环多了一个分支 <code>*</code> ，这个表示，如果没有任何标志的话，默认直接翻译无法解析的参数。其实就是一句话：脚本之前必须用 <code>-q</code> 指明翻译的文本，现在不用了，可以这样用 <code>./mt.sh text</code>。</p><p>至此，我们的脚本写完了。当然，眼尖的同志看到，我还没有实现 <code>clear</code> 指令呢！没事，这让你们自己探索。</p><h1 id="后语"><a href="#后语" class="headerlink" title="后语"></a>后语</h1><p>又超过三千字了，这使我不得不结束这篇文章。脚本可拓展的其实还很多，有兴趣可以试试。我附上两个脚本——mt1.sh 和 mt.sh. 前者是写这篇文章使用的脚本，后者是我之前写的完整的脚本。因为蓝奏云不支持 <code>sh</code> 格式，所以我重命名为 <code>mt1.sh.txt</code>  和 <code>mt.sh.txt</code>。下载之后只需要把扩展名中的 <code>.txt</code> 删掉就可以了。</p><h1 id="相关脚本"><a href="#相关脚本" class="headerlink" title="相关脚本"></a>相关脚本</h1><p>脚本: <a href="https://wwb.lanzoub.com/b017dhqaf">https://wwb.lanzoub.com/b017dhqaf</a><br>密码: chunshuyumao</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>翻译</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于百度翻译 API：手撸一个命令行翻译脚本</title>
    <link href="/2022/03/24/%E5%9F%BA%E4%BA%8E%E7%99%BE%E5%BA%A6%E7%BF%BB%E8%AF%91-API%EF%BC%9A%E6%89%8B%E6%92%B8%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BF%BB%E8%AF%91%E8%84%9A%E6%9C%AC/"/>
    <url>/2022/03/24/%E5%9F%BA%E4%BA%8E%E7%99%BE%E5%BA%A6%E7%BF%BB%E8%AF%91-API%EF%BC%9A%E6%89%8B%E6%92%B8%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BF%BB%E8%AF%91%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今 天费了九牛二虎之力，手撸了命令行翻译软件。原本是件好事，晚上准备记录的时候遇见了一件伤心事：我的 Gitee  图床仓库被屏蔽了。不大清楚为什么自己的图片外链访问过多？想想 PicGO 上是使用 Gitee  的不在少数，偏偏我遇上了。看来自己的博客每次都有成千上万人浏览。不过我本就没有准备在一棵树上吊死，我还有 sm.ms  图床，虽然慢了点。卑躬屈膝地给 Gitee 管理员写了封信，好歹让我能备份自己的图片吧，咱也没啥要求了。既然如此，大家还是好好考虑一下要不要用  Gitee，至少目前我是没办法用了。</p><p>闲话少叙，正事还没讲呢。</p><p>一直以来我都是用 translate-shell<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://github.com/soimort/translate-shell/">[1]</span></a></sup>，一个简单的命令行翻译软件，给自己翻译。最近想想，我好像之前申请过百度翻译开放平台的一个账号。那时候我还用 Windows，所以也使用<strong>知云文献翻译</strong><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="http://www.zhiyunwenxian.cn/">[2]</span></a></sup>。<strong>知云文献翻译</strong>还是很良心的，可惜没有 Linux 平台。<strong>知云</strong>允许自定义<ruby>百度翻译API<rt>Application Programming Interface</rt></ruby>，好奇心驱使下我就申请了百度翻译的账号。后来用了多少没看，文献也啥好翻译的，时不时查一个词还不错。</p><p>translate-shell<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://sourceforge.net/projects/translate-shell.mirror/">[3]</span></a></sup> 功能强大，如果使用 Linux，可以直接命令行安装，我用的 Manjaro Linux, 所以安装方式是：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo pacman -S translate-shell<br></code></pre></div></td></tr></table></figure><p>其他发行版就用你们熟悉的方式吧。安装完成之后使用 <code>trans</code> 进行翻译。具体可以参照<ruby>帮助<rt>man</rt></ruby>。</p><p>使用一阵子之后，我突然也想搞自己的翻译软件？当然，我打算用 shell&#x2F;bash 直接写个脚本。其实这样也有好处：好歹让我习惯 bash 的用法。话不多少，准备：</p><ol><li>百度翻译开发账号<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://fanyi-api.baidu.com/ ">[4]</span></a></sup></li><li>Linux 平台，可以是<ruby>适用于 Windows 的 Linux 子系统( WSL )<rt>Windows Subversion for Linux</rt></ruby>，Linux 虚拟机、主机、服务器，Cygwin<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.cygwin.com/">[5]</span></a></sup>，也许 Windows 上的 Git Bash 也可以？</li></ol><p>我使用的是 Manjaro 5.15 内核，bash 是 5.1。其实这些都不用在意：我列出来就是假装自己很懂而已，大多数情况下这些东东都是兼容的。</p><h1 id="申请百度翻译账号"><a href="#申请百度翻译账号" class="headerlink" title="申请百度翻译账号"></a>申请百度翻译账号</h1><p>开工之前，我们先去百度翻译官网申请一个账号：</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203/202203250946067.png" alt="申请账号"></p><p>申请完之后选择<strong>文档与支持–&gt;开发者文档</strong>，选择右边的<strong>开通链接</strong>，选择<strong>通用翻译</strong>。其他的服务以后有兴趣自己试试。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251000872.png" alt="开通链接"></p><p>填申请。因为我已经申请过通用翻译，所以这里开了一个其他翻译方式，对照着看就差不多了。填完之后直接申请，基本秒通过。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251002303.png" alt="申请"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251004510.png" alt="通过"></p><p>完成之后选择<strong>开发者信息</strong>，记住右边的 <strong>APP ID</strong> 和密<ruby>钥<rt>yuè</rt></ruby>。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251028435.png" alt="重要东东"></p><p>选择<strong>文档与支持</strong>，<strong>接入服务</strong>版块介绍了<strong>通用翻译</strong>的一些信息，基础的翻译而已，不用太较真——<strong>开发者文档</strong>有<strong>通用翻译</strong>使用的介绍。接下来我们基本都是看<strong>通用翻译</strong>的<strong>开发文档</strong>。很大程度上，大家可以自己动手造，用不着看我的演示。不过我还是介绍自己踩过的坑。百度的开发者文档做的还挺好，后面还有各种语言的事例，如果不使用 Bash 的话可以看看——我之前也用 Python 写过一个，觉得还可以。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251029605.png" alt="文档支持"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251031898.png" alt="通用翻译"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251032376.png" alt="使用方式"></p><h1 id="开始制作"><a href="#开始制作" class="headerlink" title="开始制作"></a>开始制作</h1><p>我后面基本是按照百度翻译的文档进行介绍，所以难免有抄袭的铁证。</p><p>首先是<strong>通用翻译</strong>的地址</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">https://fanyi-api.baidu.com/api/trans/vip/translate<br></code></pre></div></td></tr></table></figure><p>随便打开一个 Shell 脚本文件。我用 VIM 编辑器，所以使用 VIM 打开。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">vim mt.sh<br></code></pre></div></td></tr></table></figure><blockquote><p>因为 Bash 兼容性很强，现在的 Linux 基本都是配置 Bash，所以我可能会 Shell 和 Bash 混用，大家只要知道我讲的是 Bash 就行了。</p><p>Bash 是 Bourne Again Shell 的缩写，以前有个 Bourne Shell, 所以是 Again .</p><p>文件名叫做 mt.sh 是因为它是 My Translater，懒得写那么多字母，干脆就是 mt.</p></blockquote><p>在脚本最上面写下</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">encoding:utf-8</span><br></code></pre></div></td></tr></table></figure><p>​<img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251048397.png" alt="杀棒(shabang)"></p><blockquote><p><code>#！</code> 这个符号读作 shabang 或者 hashbang. 它的作用不用深究，例行公事写下来就行。</p><p>下面的 <code>encoding</code> 相信写过 Python 的人都比较习惯，例行公事，不写也没事。</p></blockquote><p>接下来就是写下自己的信息，HTTPS 地址和 APPID、密钥等。<code>declare -r</code> 声明这些是常量( Read Only )，可有可无，例行公事。文档中还提到 Salt 参数，说是一个随机码，既然是随机的，我们也随便给它一个。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">翻译 HTTPS 地址</span><br>declare -r basic_url=&quot;https://fanyi-api.baidu.com/api/trans/vip/translate&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">APPID</span><br>declare -r appid=&quot;20222231001673136&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">密钥</span><br>declare -r token=&quot;L4Jr77zOjy91cKx9_4oP&quot;<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251053579.png" alt="信息"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251055525.png" alt="Salt"></p><p>在 Linux 系统生成随机数的方式还是蛮多，我对 <code>openssl rand</code> 比较满意，所以就用它了，在自己的脚本中写入:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">declare -r salt=$(openssl rand -base64 18|cut -c 10)<br></code></pre></div></td></tr></table></figure><ol><li>先看内部， <code>openssl rand</code> 是一条指令，用于生成随机数，<code>-base64</code> 是使用 64 个可打印的字符，<code>18</code> 表示我要生成 18 个字符。</li><li><code>|</code> 在 Linux 中表示<strong>管道符</strong>，意思是把右边输出当作左边的输入。也就是说，<strong>管道符</strong>右边的输出是左边的输入。不了解也没事，知道这么一件事就可以了。</li><li><code>cut</code> 表示截断输入，通常是字符或者文件。<code>-c</code> 表示按照字符截断，<code>10</code> 表示截取第 10 个字符。如果想截取 10 个字符，需要用 <code>1-10</code>。原本我是想截取 10 个的，但是发现的时候已经截图了，那就算了。</li><li><code>$()</code> 表示获取括号里边计算的结果。简而言之就是，获取括号里指令的结果。</li></ol><p>上面的 <code>cut -c 10</code> 指令可有可无，一来文档没有说 Salt 有没有长度限制，二来其实管道符右边的式子也可以控制生成的长度。随便吧，最简单就是以下的表示：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">declare -r salt=$(openssl rand -base64 10)<br></code></pre></div></td></tr></table></figure><h2 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h2><p>接下来准备生成<ruby>签名<rt>sign</rt></ruby>。什么是<ruby>签名<rt>sign</rt></ruby>？其实就是我们翻译的请求信息。根据文档要求，签名应该长这样:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">MD5(appid+q+salt+token)<br></code></pre></div></td></tr></table></figure><p>其中，<code>q</code> 是 query 的缩写，就是我们想要翻译的文字，UTF-8 编码——不了解编码不用管，知道就行。</p><p>我们准备了 appid、salt 和 token 了，现在只差 q。为了方便调试，我们声明一个 q, 取名 query。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">delcare query=&quot;like&quot;<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251121224.png" alt="query"></p><p>首先拼接字符串，然后取 MD5 </p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">tmpStr=<span class="hljs-string">&quot;$appid$query$salt$token&quot;</span><br>sign=<span class="hljs-constructor">$(<span class="hljs-params">echo</span> -<span class="hljs-params">n</span> <span class="hljs-params">tmpStr</span> | <span class="hljs-params">md5sum</span> | <span class="hljs-params">cut</span> -<span class="hljs-params">c</span> 32)</span><br></code></pre></div></td></tr></table></figure><p>解释一下，我们用 <code>md5sum</code> 生成 MD5，然后只取 32 个字符——因为文档说我们只需要 32 位。Shell 语言和 Perl 语言很相似，可能在其他高级语言里想要获取某一个变量的值，我们可以直接使用这个变量名；但是在 Shell 里，我们需要用 <code>$</code> 符号获取变量值，最正规的方式是：<code>$&#123;appid&#125;</code>。因为要拼接成一个字符串，所以建议拼接的两边加上双引号。Shell 的字符串拼接也很有趣，直接把两个字符串放一起就行了。</p><blockquote><p><code>-n</code> 非常重要，别丢了</p></blockquote><p>举个例子，其他语言的语言拼接：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">python</span><br>str1 = &quot;Hello&quot;<br>str2 = &quot;World&quot;<br>str3 = str1 + str2<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">cpp</span><br>std::string str1&#123; &quot;Hello&quot; &#125;;<br>std::string str2&#123; &quot;World&quot; &#125;;<br>std::string str3&#123; str1 + str2 &#125;;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">lua</span><br>local str1 = &quot;Hello&quot;<br>local str2 = &quot;World&quot;<br>local str3 = str1..str2<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Shell/Perl</span><br>str1=&quot;Hello&quot;<br>str2=&quot;World&quot;<br>str3=&quot;$str1$str2&quot;<br></code></pre></div></td></tr></table></figure><p>闲话少叙，其实上面的两行可以写成一行：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sign=$(echo -n &quot;$appid$query$salt$token&quot; | md5sum | cut -c 32)<br></code></pre></div></td></tr></table></figure><h2 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h2><p>获取签名之后就可以使用百度翻译提供的 API 翻译了。在 Shell 脚本中，我们使用大名鼎鼎的 cURL 进行网路请求。首先声明，我对 cURL 不熟，一般我都不用它——因为学不会。</p><p>cURL 请求的命令是：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">curl url<br></code></pre></div></td></tr></table></figure><p>所以我们需要提供一个 url. 上面我们准备了百度翻译的 API, 现在开始拼接。在脚本中输入：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">url=&quot;$basic_url?q=$query&amp;from=en&amp;to=zh&amp;appid=$appid&amp;salt=$salt&amp;sign=$sign&quot;<br>curl &quot;$url&quot;<br></code></pre></div></td></tr></table></figure><p>或者直接一行</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">curl &quot;$basic_url?q=$query&amp;from=en&amp;to=zh&amp;appid=$appid&amp;salt=$salt&amp;sign=$sign&quot;<br></code></pre></div></td></tr></table></figure><p>如果使用 VIM，那就 <kbd>Esc</kbd>，然后输入 <code>:wq</code>，回车退出。在命令行上输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">chmod u+x mt.sh<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251220209.png" alt="给予可执行权限"></p><p>输入 <code>./mt.sh</code> 执行脚本。可以看到有返回了，结果就在 <code>dst</code> 里边。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251255943.png" alt="结果"></p><p>现在要做的就是取出我们的结果，使用 <code>-e</code> 进行转义输入：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">result=$(curl &quot;$basic_url?q=$query&amp;from=en&amp;to=zh&amp;appid=$appid&amp;salt=$salt&amp;sign=$sign&quot;)<br>echo -e &quot;$result&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者直接一行</span><br>echo -e &quot;$(curl &quot;$basic_url?q=$query&amp;from=en&amp;to=zh&amp;appid=$appid&amp;salt=$salt&amp;sign=$sign&quot;)&quot;<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251258949.png" alt="转义"></p><h2 id="字符串截断"><a href="#字符串截断" class="headerlink" title="字符串截断"></a>字符串截断</h2><p>在获取结果之前，我们先说说如何在 Shell 中截取字符串。就拿我们上面的字符串做例子。现在我们要做的是把“喜欢”取出来。使用下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">result=&quot;$&#123;result##*dst\&quot;:\&quot;)&quot;<br>echo -e $&#123;result%\&quot;\&#125;\]\&#125;&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251308513.png" alt="获取结果"></p><p>解释一下：</p><ol><li><p>首先，分割字符串使用 <code>#</code> 和 <code>%</code> ，前者表示从左往右删除，后者表示从右往左删除。举个例子 <code>str=&#39;chunshuyumao&#39;</code> 如果我想删掉 <code>chunshu</code>，就用 <code>$&#123;str#chunshu&#125;</code>。如果我懒了，不想写那么多个字母，那就写成这样 <code>$&#123;str#*shu&#125;</code>，用 <code>*</code> 表示任意字符，这样只要找到了 <code>shu</code>，就把 <code>shu</code> 和它之前的字符全删掉。同理，<code>%</code> 表示从右边开始算起。那两个 <code>#</code> 表示什么？在 Linux 中有个习惯，两个东西通常表示极端——例如在 VIM 中，<code>d</code> 表示删除，<code>dd</code> 就直接删除一行；<code>y</code> 表示复制，<code>yy</code> 就直接复制一行。<code>#</code> 表示从左边找的第一个符合条件的字符串，两个 <code>#</code> 就是从左边找的最后一个符合条件的字符串。举个例子</p><p><code>str=&quot;chunshuyumaoshuzhuang&quot;</code>，如果用 <code>$&#123;str#*shu&#125;</code> 就会得到 <code>yumaoshuzhuang</code> ,使用 <code>$&#123;str##*shu&#125;</code> 就会得到 <code>zhuang</code>。同理，<code>%%</code> 表示从右边数最后一个匹配的字符串。</p></li><li><p>因为引号( “ ) 是特殊的字符串，所以我们用 <code>\</code> 转义，所以第一行的原本想法是 <code>$&#123;result#*dst&quot;:&quot;&#125;</code>，加上转义字符之后就是 <code>$&#123;result##*dst\&quot;:\&quot;&#125;</code>。</p></li><li><p>括号也是特殊字符，所以一并转义</p></li></ol><p>这样就得到结果了。不过大家可能也看到下面的输出了，我们不希望有这个输出。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">  % </span><span class="language-bash">Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br>                                 Dload  Upload   Total   Spent    Left  Speed<br>100    76  100    76    0     0    301      0 --:--:-- --:--:-- --:--:--   301<br></code></pre></div></td></tr></table></figure><p>在脚本使用 cURL 的后面加上 <code>2&gt;/dev/null</code> 这个语句是把一些不重要的输出放到 <code>/dev/null</code> 这个文件。不用担心，这个文件没啥用。参看下面的结果：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">result=$(curl &quot;$basic_url?q=$query&amp;from=en&amp;to=zh&amp;appid=$appid&amp;salt=$salt&amp;sign=$sign&quot; 2&gt;/dev/null)<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251326986.png" alt="重定向输出"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251329558.png" alt="最后的结果"></p><p>截至目前，你的脚本看起来是这样的：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">encoding:utf-8</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">翻译 HTTPS 地址</span><br>declare -r basic_url=&quot;https://api.fanyi.baidu.com/api/trans/vip/translate&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">你的 APPID</span><br>declare -r appid=&quot;xxxxxxxxxxxxxxxxxxxx&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">你的密钥</span><br>declare -r token=&quot;xxxxxxxxxxxxxxxxxxxx&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">random code</span> <br>declare salt=$(openssl rand -base64 18|cut -c 1-10)<br><br>declare query=&quot;like&quot;<br><br>sign=$(echo -n &quot;$appid$query$salt$token&quot; | md5sum | cut -c 1-32)<br>result=$(curl &quot;$basic_url?q=$query&amp;from=en&amp;to=zh&amp;appid=$appid&amp;salt=$salt&amp;sign=$sign&quot; 2&gt;/dev/null)<br>result=&quot;$&#123;result##*dst\&quot;:\&quot;&#125;&quot;<br>echo -e $&#123;result%\&quot;\&#125;\]\&#125;&#125;<br></code></pre></div></td></tr></table></figure><p>既然已经成功了，我们开始修改 query 的内容。</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>第一个要解决的就是 query 的输入问题。我们希望这样使用自己的翻译器 <code>./mt.sh &quot;English&quot;</code>.  Shell 脚本和其他语言一样，可以获取它的命令行参数。听不懂没事，假设我这样调用自己的脚本：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">./mt.sh chun shu yu mao<br></code></pre></div></td></tr></table></figure><p><code>./mt.sh</code>、<code>chun</code>、<code>shu</code>、<code>yu</code>、<code>mao</code> 就是命令行参数。脚本中使用 <code>$n</code> 的方式获取参数，其中 <code>n</code> 表示阿拉伯数字。我下面输出一下参数</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251338985.png" alt="输出参数"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251338982.png" alt="输出参数"></p><p>知道这个之后，我们修改一下自己的脚本：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">declare query=&quot;$1&quot;<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251419011.png" alt="桉树输入"></p><p>单词可以输入了，我们试着输入句子如何？</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251419770.png" alt="句子"></p><p>失败了，很显然没有结果，我们试着打印 <code>result</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251420484.png" alt="打印结果"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251428364.png" alt="打印"></p><p>没有任何反馈。其实这是因为我们的句子有问题，看一下文档：</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251428097.png" alt="URL encode"></p><p>我们发送请求的时候需要进行编码。举个例子，上浏览器上搜 <code>I&#39;m so handsome</code> 的时候，地址栏显示是 <code>I&#39;m+so+handsome</code> . 类似这种就是编码——实际并非完全如此，知道大概就行。文档说使用 URL Encoding，直接使用我给的式子就行：</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251428869.png" alt="URL encode"></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">declare query=&quot;$1&quot;<br><br>sign=$(echo -n &quot;$appid$query$salt$token&quot; | md5sum | cut -c 1-32)<br><br>query=$(echo &quot;$query&quot; | tr -d &#x27;\n&#x27; | xxd -plain | sed &#x27;s/\(..\)/%\1/g&#x27;)<br>query=$(echo $query | sed &#x27;s/ //g&#x27; )<br><br>result=$(curl &quot;$basic_url?q=$query&amp;from=en&amp;to=zh&amp;appid=$appid&amp;salt=$salt&amp;sign=$sign&quot; 2&gt;/dev/null)<br>result=&quot;$&#123;result##*dst\&quot;:\&quot;&#125;&quot;<br>echo -e $&#123;result%\&quot;\&#125;\]\&#125;&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251437661.png" alt="翻译句子"></p><p>ok, 基本完成了。到这里，脚本实现翻译已经完成了。如果你觉得这已经不错了，那就可以结束这篇文章了。如果觉得还想要改进，那就继续阅读。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>我们用脚本和百度翻译 API 完成了自己的第一个翻译脚本。接下来进行多语言拓展。首先我们看一下百度支持的常用翻译：</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251441719.png" alt="支持的翻译"></p><p>翻译的语言信息要放哪里呢？来看看我们之前写的请求地址：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">result=$(curl &quot;$basic_url?q=$query&amp;from=en&amp;to=zh&amp;appid=$appid&amp;salt=$salt&amp;sign=$sign&quot; 2&gt;/dev/null)<br></code></pre></div></td></tr></table></figure><p>上面我们从哪种语言翻译过去，就使用 <code>from=代号</code>, 翻译成哪种语言就用 <code>to=代号</code>。好的，我们改改，改成翻译为文言文：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">result=$(curl &quot;$basic_url?q=$query&amp;from=en&amp;to=wyw&amp;appid=$appid&amp;salt=$salt&amp;sign=$sign&quot; 2&gt;/dev/null)<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251447688.png" alt="文言文翻译"></p><p>为了让使用者可以控制翻译的设置，我们可以添加一些参数，例如我已经做好的脚本：</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251500470.png" alt="help"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251509696.png" alt="列出支持的语言"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203@master/202203251513256.png" alt="中英翻译"></p><p>所以接下来，我们就要实现上面这些功能——不过不是现在。</p><h1 id="相关网址"><a href="#相关网址" class="headerlink" title="相关网址"></a>相关网址</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://github.com/soimort/translate-shell/">https://github.com/soimort/translate-shell/</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="http://www.zhiyunwenxian.cn/">http://www.zhiyunwenxian.cn/</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://sourceforge.net/projects/translate-shell.mirror/">https://sourceforge.net/projects/translate-shell.mirror/</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://fanyi-api.baidu.com/">https://fanyi-api.baidu.com/</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://www.cygwin.com/">https://www.cygwin.com/</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>翻译</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器安装 RStudio-Server</title>
    <link href="/2022/03/18/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85RStudio-Server/"/>
    <url>/2022/03/18/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85RStudio-Server/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>RStudio Server 是 RStudio 的服务器版。单机版其实也已经够用，可是有些时候我们需要进行迁移或者跨平台使用，重新安装一遍非常麻烦。我的服务器只有2G 内存，比不上我的电脑，没理由使用服务器不用自己的电脑。可惜服务器不用也是浪费，而且自己配置也是一种乐趣，所以就花了点时间。其实这也和我不愿意安装各种客户端有关。</p><p>折腾好一天才成功在服务器安装 RStudio Server。这里奉劝天下士，有事没事真别浪费时间在国内找网上的资料，要真的有问题不行了，去相关的技术论坛找问题或者好好跟着官网教程走，不然就是在浪费生命。</p><p>本次安装的平台和软件:</p><ol><li>Miniconda3 Linux 64-bit。使用 conda 管理多版本 R 语言和 Python。</li><li>RStudio Server v2022.02.0+443。RStudio 的服务器版本，可以通过浏览器接入。</li><li>ECS 共享型 n4 单核2G内存服务器，Rocky Linux 8.5 版，兼容 CentOS7&#x2F;8 和 RHEL8 及以上版本。</li></ol><p>我会带大家一步一步踩坑，所有按我教程走的时候遇到问题不用紧张——毕竟俺就是这么来的。</p><h1 id="Miniconda3"><a href="#Miniconda3" class="headerlink" title="Miniconda3"></a>Miniconda3</h1><p>R 语言是免费开源的编程语言，被广泛运用到科学计算领域，被称为科学家的编程语言。R 语言这年头最为人所知的能力就是画图和数据分析。大数据分析时代，R 与 Python 齐驱并进（虽然 Python 是后来者居上）。与 Python 相比，R 语言独有的特点是版本不兼容：R 语言一般不具有向前向后兼容性，低版本使用得了的<ruby>包<rt>package</rt></ruby>高版本一般使用不了。正因如此，你会看到很多学者的电脑安装各种版本的 R 语言。</p><p>在 Linux 上安装 R 语言可能直接安装到系统路径，想使用多个版本就容易起冲突。解决这个问题最普遍的思想是通过虚拟环境管理器管理 R 语言版本。</p><p>Python 我就不多说了。Python 最著名的包管理器是 PIP. 默认情况下只要安装了 Python 就会自带这个东西。PIP 提供了简单的包查询、下载、查找和卸载功能，一般不解决依赖问题。正常情况下不会有什么大毛病，一碰到科学计算包就不好看了。举个例子，如果我要安装 A 包，A 包里边使用了 B 包，PIP 安装就会出错。好心的话，PIP 会提醒你少了某种东西，可惜大多数时候它只会和你一样懵。</p><p>为了更好的解环境包依赖问题，有一群人开始思考某种新的包管理器，conda 由此而生。conda 成功解决了依赖问题——你没安装的东西它会帮你安装——并发展成 <ruby>包管理系统<rt>package management system</rt></ruby>、 <ruby>环境管理系统<rt>environment management system</rt></ruby>，而且还兼管多种语言的版本管理——当然最常用的就是 R 和 Python.</p><p>conda 一般不能单独安装，想要使用它需要安装 Anaconda。Anaconda 和 Python 同祖同宗，都是大蛇。Anaconda 预安装上百个科学包，基本不用愁。可惜大多数我们都用不上。用不上又得安装，动辄几个 G 的内存看起来很恶心。鉴于此，Miniconda 横空出世：它也使用 conda 解决包依赖问题，但不像 Anaconda 什么都安装，它只保留最少的软件包，剩下你需要啥就装啥。对于内存捉襟见肘的小伙伴来说，这简直是福音。因此我打算安装 Miniconda3.</p><h2 id="安装-Miniconda3"><a href="#安装-Miniconda3" class="headerlink" title="安装 Miniconda3"></a>安装 Miniconda3</h2><p>到官网<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://docs.conda.io/en/latest/miniconda.html">[1]</span></a></sup>下载对应系统的版本。我要安装到 Linux 服务器，所以选择 <a href="https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh">Miniconda3 Linux 64-bit</a> 。使用你喜欢的下载方式下载，我用 axel.</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">axel <span class="hljs-literal">-n</span> <span class="hljs-number">32</span> https://repo.anaconda.com/miniconda/Miniconda3<span class="hljs-literal">-latest-Linux-x86_64</span>.sh<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181615732.png" alt="选择版本"></p><p>下载完之后，使用 <code>ls</code>查看自己的目录下有没有以下脚本。如果没有需要继续下载。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181628572.png" alt="下载的脚本"></p><p>给予脚本可执行权限：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">chmod u+x Miniconda3-latest-Linux-x86_64.sh<br></code></pre></div></td></tr></table></figure><p>然后执行</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">./Miniconda3-latest-Linux-x86_64.sh<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181631221.png" alt="执行"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181631078.png" alt="一直 Enter 回车"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181632355.png" alt="选择 yes 确认安装"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181637069.png" alt="选择安装位置"></p><p>安装位置通常是你的家目录，例如我的家目录是 <code>/home/chunshuyumao</code>，所以安装位置是 <code>/home/chunshuyumao/miniconda3</code>，你也可以在 <code>&gt;&gt;&gt;</code>之后修改自己的路径。建议还是安装到自己的家目录下。</p><p>安装完毕它会问你是否激活 conda 环境，选择 yes 会在每次打开控制台时自动激活 conda 的默认环境 base。如果不想默认开启就选择 no. 如果无意中选择了 yes, 也可以通过输入 <code>conda config --set auto_activate_base false</code> 取消激活。一般我选择 yes，然后再输入命令取消。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181736554.png" alt="默认激活"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181740692.png" alt="选择 yes"></p><p>安装完之后重新登陆控制台可以看到 conda 命令可以使用了，或者不用重启登陆，只需输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">source ~/.bashrc<br></code></pre></div></td></tr></table></figure><p>其中 <code>~/.bashrc</code> 是你的 shell 的配置文件，我使用的是 zsh, 所以输入的是 <code>source ~/.zshrc</code>。输入 <code>conda -V</code> 查看安装是否成功。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181743461.png" alt="查看版本"></p><h2 id="配置国内源"><a href="#配置国内源" class="headerlink" title="配置国内源"></a>配置国内源</h2><p>conda 不配置国内源速度会很慢，输入以下代码配置国内源：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free<br>conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r<br>conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main<br>conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda<br>conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge<br></code></pre></div></td></tr></table></figure><p>配置国内源之后安装 mamba —— mamba 可以看作是更快的 conda. 由于 conda 没想到自己发展那么快，随着包越来越多，解析依赖的速度越来越慢，对于一些大型的包需要解决的依赖更多——这时候 conda 显得力不从心，于是诞生了 mamba 这个更快的包管理。不想了解这段历史的话直接安装 mamba 就对了。安装之后进行简单的升级，确认一下</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">conda install mamba -y<br>mamba update conda -y<br>conda update mamba -y<br></code></pre></div></td></tr></table></figure><h2 id="安装-R-语言"><a href="#安装-R-语言" class="headerlink" title="安装 R 语言"></a>安装 R 语言</h2><p>conda 通过创建多个<ruby>环境<rt>encironment</rt></ruby>管理语言的版本，要安装多版本需要创建环境。后面使用的 Seurat 包需要 R 语言的版本高于 4.0 ，所以创建一个高版本的 R 语言环境：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">conda create -n r4.1.2 -y<br></code></pre></div></td></tr></table></figure><blockquote><p><code>-n</code> 指定环境的名字，为了方便区分，我直接命名为 <code>r4.1.2</code> ，意思是要安装 4.1.2 版本。<code>-y</code> 是 yes, 就是直接确认创建，不用再询问。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181804758.png" alt="创建 R 语言环境"></p><p>激活环境，输入 <code>conda activate r4.1.2</code>。如下图，右边提示现在是 <code>r4.1.2</code> 环境</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181805983.png" alt="激活环境"></p><p>想使用哪个环境就激活那个环境。</p><blockquote><p>如果想关闭环境，使用 <code>conda deactivate</code></p></blockquote><p>安装 R 语言 4.1.2 版</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">mamba install r-base==4.1.2 -y<br></code></pre></div></td></tr></table></figure><p>安装完毕输入 <code>R</code> 回车，查看是否有问题。如果进入以下界面就说明安转成功，输入 <code>quit()</code> 退出 R 语言的交互界面。</p><p>同理，想要安装其他版本的 R 语言，需要创建一个新环境，然后激活它再安装版本——使用 <code>==</code> 指定语言版本，不指定的话默认安装最新版。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181842541.png" alt="检验安装是否成功"></p><p>退出的时候它会问是否保存工作环境，一般不用保存，输入 <code>n</code> 即可</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181843681.png" alt="不保存工作环境"></p><h2 id="安装-Python"><a href="#安装-Python" class="headerlink" title="安装 Python"></a>安装 Python</h2><p>创建新环境，安装最新版 Python：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">conda create -n py3.10 -y<br>mamba install -n py3.10 python==3.10 -y<br></code></pre></div></td></tr></table></figure><p>这里在 <code>install</code> 的时候没有激活 py3.10 环境，所以需要使用 <code>-n</code> 指定安装 Python3.10 的环境。</p><p>安装完之后输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">conda info --envs<br></code></pre></div></td></tr></table></figure><p>查看我们现有的环境</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181849999.png" alt="现有的环境"></p><p>可以看到，我们现在有三个环境: base, py3.10, r4.1.2。其中激活的是 py3.10。</p><blockquote><p>哪个环境是激活的会有一个 <code>*</code> 标注。</p></blockquote><h1 id="安装-RStudio-Server"><a href="#安装-RStudio-Server" class="headerlink" title="安装 RStudio Server"></a>安装 RStudio Server</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>接下来到官网<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.rstudio.com/products/rstudio/download-server/">[2]</span></a></sup>安装 RStudio Server. 选择你的系统，我用的是 RHEL 系列，点击第一个系统进入安装教程。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181852320.png" alt="选择系统"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181853918.png" alt="安装教程"></p><p>首先是下载安装包。使用 <code>wget</code> 就按照官网说的下载，使用 <code>curl</code> 就用 <code>curl</code> 下载，使用 <code>axel</code> 就用 <code>axel</code> 下载，下面三种下载方式选一种：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">wget https://download2.rstudio.org/server/centos7/x86_64/rstudio-server-rhel-2022.02.0-443-x86_64.rpm<br>curl -O https://download2.rstudio.org/server/centos7/x86_64/rstudio-server-rhel-2022.02.0-443-x86_64.rpm<br>axel -n 32 https://download2.rstudio.org/server/centos7/x86_64/rstudio-server-rhel-2022.02.0-443-x86_64.rpm<br></code></pre></div></td></tr></table></figure><p>确认下载成功：</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181856163.png" alt="确认下载成功"></p><p>安装：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo yum install rstudio-server-rhel-2022.02.0-443-x86_64.rpm -y<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181859478.png" alt="安装完毕"></p><p>允许自启动，并启动它：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo systemctl enable rstudio-server<br>sudo systemctl start rstudio-server<br>sudo systemctl status rstudio-server<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181900768.png" alt="一般会启动失败"></p><p>不用担心，启动失败很正常。输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo rstudio-server verify-installation</span><br><br>TTY detected. Printing informational message about logging configuration. Logging configuration loaded from &#x27;/etc/rstudio/logging.conf&#x27;. Logging to &#x27;/var/log/rstudio/rstudio-server/rserver.log&#x27;.<br>Path to R not specified, and no module binary specified; Invalid R module ()<br></code></pre></div></td></tr></table></figure><p>上面显示的错误是找不到 R 语言的路径，这个简单，我们配置一下 R 语言的路径。 </p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo vim /etc/rstudio/rserver.conf<br></code></pre></div></td></tr></table></figure><p>按 <kbd>Shift</kbd>+<kbd>g</kbd> 转到最后一行，按 <kbd>o</kbd> 输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">rsession-which-r=/home/chunshuyumao/miniconda3/envs/r4.1.2/bin/R<br></code></pre></div></td></tr></table></figure><p>其中，<code>/home/chunshuyumao</code>写你的家目录，这里是我的家目录， miniconda3 安装在哪里就使用哪个目录。我创建的 R 语言环境在 miniconda3  <ruby>虚拟环境目录<rt>envs</rt></ruby>下的 <code>r4.1.2</code>。如果你不确定你的 R 语言在哪里，可以激活环境之后使用 <code>which R</code> 查看，例如：</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181912027.png" alt="which R"></p><p>上面图中的 <code>~</code> 代表 <code>/home/chunshuyumao</code> 也就是你的家目录。</p><p>配置完之后，按一下 <kbd>Esc</kbd> 键，然后输入 <code>:wq</code> ，回车就可以了。再次输入 <code>sudo rstudio-server verify-installation</code> ，发现仍然有问题。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181914017.png" alt="修改路径"></p><p>配置库路径</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo vim /etc/rstudio/rserver.conf<br></code></pre></div></td></tr></table></figure><p>按 <kbd>Shift</kbd>+<kbd>g</kbd> 转到最后一行，按 <kbd>o</kbd> 输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">rsession-ld-library-path=/home/chunshuyumao/miniconda3/envs/r4.1.2/lib:/home/chunshuyumao/miniconda3/envs/r4.1.2/lib/R/lib<br></code></pre></div></td></tr></table></figure><p>把 <code>/home/chusnhuyumao</code> 改成你的家目录，<code>r4.1.2</code>改为你的 R 语言虚拟环境名即可。</p><p>按一下 <kbd>Esc</kbd> 键，然后输入 <code>:wq</code> ，回车退出。</p><p>重启试试:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo systemctl restart rstudio-server<br>sudo rstudio-server verify-installation<br></code></pre></div></td></tr></table></figure><p>出现下面提示说明你已经成功</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">Server is running and must be stopped before running verify-installation<br></code></pre></div></td></tr></table></figure><p>如果提示 <code>error while loading shared libraries: libssl.so.10</code>，请跳到 <a href="#prob">4</a>。</p><p>RStudio Server 默认监听 8787 端口，可以使用 <code>sudo netstat -an4p | grep 8787</code> 查看 rserver 是否启动</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181930508.png" alt="查看端口"></p><blockquote><p>如果提示没有 <code>netstat</code> 这个命令，请先安装 <code>sudo yum install -y net-tools</code></p></blockquote><p>开启防火墙的话，开放一下 8787 端口：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo firewall-cmd --add-port=8787/tcp --permanent<br>sudo firewall-cmd --reload<br></code></pre></div></td></tr></table></figure><h2 id="测试登录"><a href="#测试登录" class="headerlink" title="测试登录"></a>测试登录</h2><p>浏览器输入 <code>IP:8787</code>，这个 IP 是公网 IP 。登陆使用的是你服务器的帐号和密码。</p><blockquote><p>如果你在虚拟机上尝试，请使用虚拟机的 IP，使用 <code>ip addr</code> 查看， inet 之后就是你的 IP</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181940261.png" alt="登陆"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181941757.png" alt="登陆成功"></p><p>Rstudio Server 搭建完毕。</p><h1 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a><a name="prob">一些问题</a></h1><p>来到这里的都是因为这条错误：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">/usr/lib/rstudio-server/bin/rsession: error while loading shared libraries: libR.so: cannot open shared object file: No such file or directory<br></code></pre></div></td></tr></table></figure><p>这和 OpenSSL 有关。我在 Rocky Linux 8.5 遇到的问题，使用 CentOS7 虚拟机没有碰到。查看库目录存在 libssl 的各个版本，创建软链接想要骗过系统发现不行，最后使用 yum search 看到了<code>compat-openssl10</code> 包，看标签应该是兼容包，安装之后发现没问题，就此记录。</p><p>安装 <code>compat-openssl10.x86_64</code>后再次重启 RStudio Server 服务。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo yum install compat-openssl10.x86_64 -y<br>sudo systemctl restart rstudio-server<br>sudo systemctl status rstudio-server<br></code></pre></div></td></tr></table></figure><h1 id="安装-Scanpy-和-Seurat"><a href="#安装-Scanpy-和-Seurat" class="headerlink" title="安装 Scanpy 和 Seurat"></a>安装 Scanpy 和 Seurat</h1><p>Scanpy 和 Seurat 是数据分析使用的，个人安装，可以不用看。</p><h2 id="安装-Scanpy"><a href="#安装-Scanpy" class="headerlink" title="安装 Scanpy"></a>安装 Scanpy</h2><p>到 Scanpy 官网<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://scanpy.readthedocs.io/en/stable/installation.html">[3]</span></a></sup>查看下载 Scanpy 教程</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203181958423.png" alt="安装 Scanpy"></p><p>激活 Python 环境安装：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">conda activate py3.10<br>mamba install seaborn scikit-learn statsmodels numba pytables -y <br>mamba install python-igraph leidenalg -y<br>pip install scanpy -i https://pypi.tuna.tsinghua.edu.cn/simple<br></code></pre></div></td></tr></table></figure><blockquote><p>请注意，一定要使用 pip ，不是 pip3 。</p></blockquote><p>安装完毕，输入 <code>python</code>进入交互界面， <code>import scanpy</code> 成功就说明安装好了。</p><h2 id="安装-Seurat"><a href="#安装-Seurat" class="headerlink" title="安装 Seurat"></a>安装 Seurat</h2><p>安装 Seurat<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://satijalab.org/seurat/">[4]</span></a></sup> 比较简单，激活 R 语言环境:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">conda activate r4.1.2<br>R<br>install.packages(&#x27;Seurat&#x27;)<br>install.packages(&#x27;dplyr&#x27;)<br>install.packages(&#x27;patchwork&#x27;)<br></code></pre></div></td></tr></table></figure><p>提示选择镜像源，可以选择北京——我这里是 17。选完直接回车。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203182010716.png" alt="镜像源"></p><p>Linux 安装 Seurat 的时候会进行源码编译，用时较长，需要有耐性。如果是 Windows 安装就比较快，直接二进制安装。</p><p>编译 Seurat 到一半提示</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">x86_64-conda-linux-gnu-c++: fatal error: Killed signal terminated program cc1plus<br></code></pre></div></td></tr></table></figure><p>这是因为我的服务器只有 2G 内存，编译需要大量内存，显然内存不足。查看一下发现，我的服务器内存小就算了，还没有<ruby>交换分区<rt>swap</rt></ruby>，不卡死才怪。生成一个空文件，临时作为<ruby>交换分区文件<rt>swap file</rt></ruby>：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo dd if=/dev/zero of=/swaptmp bs=4M count=1024<br></code></pre></div></td></tr></table></figure><p>解释一下，<code>swaptmp</code> 是<ruby>交换分区<rt>swap</rt></ruby>的名字，随便取。位置在 <code>/</code> 根目录下。<br><code>bs</code>是 <code>blocksize</code>，就是区块大小，不用管。<br><code>count</code> 是写入的区块个数，我写入 1024 块。</p><p>通过上面的命令，我创造了 4x1024M( 也就是 4G ) 大的文件。 为什么是 4G ？因为我的内存为 2G, <ruby>交换分区<rt>swap</rt></ruby>最好不超过内存的 2 倍。</p><blockquote><p>内存指的是物理内存，不是硬盘空间，我的配置是 2G 内存 + 40G 硬盘空间</p></blockquote><p>完成之后格式化并启用<ruby>交换分区文件<rt>swap file</rt></ruby>：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo mkswap /swaptmp<br>sudo swapon /swaptmp<br></code></pre></div></td></tr></table></figure><p>继续编译 Seurat .</p><p>编译完不想保留<ruby>交换分区文件<rt>swap file</rt></ruby>可以卸载：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo swapoff /swaptmp<br>sudo rm -rf /swaptmp<br></code></pre></div></td></tr></table></figure><p>不过依我看，如果你的内存不够编译 Seurat，索性留着<ruby>交换分区<rt>swap</rt></ruby>也许更好。想要保留<ruby>交换分区文件<rt>swap file</rt></ruby>，请进行以下配置：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo vim /etc/fstab<br></code></pre></div></td></tr></table></figure><p>按 <kbd>Shift</kbd>+<kbd>g</kbd> 转到最后一行，按 <kbd>o</kbd> 输入</p><figure class="highlight avrasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs avrasm">/swaptmp <span class="hljs-keyword">swap</span> <span class="hljs-keyword">swap</span> defaults <span class="hljs-number">0</span> <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><p>按一下 <kbd>Esc</kbd> 键，然后输入 <code>:wq</code> ，回车退出。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>登陆你的 RStudio Server. 输入</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">library</span><span class="hljs-params">(Seurat)</span></span><br><span class="hljs-function"><span class="hljs-title">library</span><span class="hljs-params">(dplyr)</span></span><br><span class="hljs-function"><span class="hljs-title">library</span><span class="hljs-params">(patchwork)</span></span><br></code></pre></div></td></tr></table></figure><p>没有报错就说明成功了。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203182028913.png" alt="测试"></p><p><kbd>Ctrl</kbd>+<kbd>l</kbd>清空交互窗口，新建一个 R 文件，输入以下内容：</p><figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">data<span class="hljs-operator">=</span><span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span> <span class="hljs-number">4</span><span class="hljs-punctuation">,</span> <span class="hljs-number">8</span><span class="hljs-punctuation">)</span><br><span class="hljs-built_in">names</span><span class="hljs-operator">=</span><span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-string">&quot;C++&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;C&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;Python&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;R&quot;</span><span class="hljs-punctuation">)</span><br>cols<span class="hljs-operator">=</span><span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-string">&#x27;black&#x27;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&#x27;blue&#x27;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&#x27;red&#x27;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&#x27;green&#x27;</span><span class="hljs-punctuation">)</span><br><br>pie<span class="hljs-punctuation">(</span>data<span class="hljs-punctuation">,</span> labels<span class="hljs-operator">=</span><span class="hljs-built_in">names</span><span class="hljs-punctuation">,</span> col<span class="hljs-operator">=</span>cols<span class="hljs-punctuation">)</span><br></code></pre></div></td></tr></table></figure><p>全选，点击界面右上角的 <ruby>运行<rt>run</rt></ruby>。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203182033434.png" alt="新建文件"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203182035833.png" alt="运行"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203182035471.png" alt="效果"></p><p>点击 <ruby>工具<rt>Tools</rt></ruby> 选择 <ruby>全局选项<rt>Global Options</rt></ruby> ，选择 <ruby>包<rt>Packages</rt></ruby>，修改 <ruby>首要 CRAN 仓库<rt>Primary CRAN repository</rt></ruby> 为离你最近的地方。选择 Python 修改版本为你喜欢的版本——它会自动检测你服务器的 Python 版本。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203182036919.png" alt="设置"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203182037629.png" alt="修改镜像"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203182039945.png" alt="Python 版本"></p><p>到这里，我们安装完 RStudio Server 还进行了简单的配置，完美收工。</p><h1 id="后语"><a href="#后语" class="headerlink" title="后语"></a>后语</h1><p>原本我不想使用 RStudio Server，最开始的想法是安装 R 语言，然后 VS Code 远程连接。之前在自己的虚拟机玩过，可以完美运行。因为没有图形界面，运行之后会产生一个 PDF 文件，只需要在 VS Code 安装一个 PDF 预览插件就可以了。不料今天各种问题：PDF 预览不了，R 语言的提示用不了。最后我都要疯了。配置 RStudio Server 的时候上不去官网查看教程，于是上网搜。真是倒霉的一天，网上一群人不知所云。最后还是逛国外网站才解决问题。真是有事没事别用国内的搜索引擎——你永远找不到自己想要的答案，我都不想吐槽了。</p><p>VS code 的设置真的反人类——至少反我。我都不知道哪跟哪，最后直接放弃了 VS Code. 我还留着 VS Code 仅仅是因为它的智能提示。不过我已经不玩 C&#x2F;C++ 了，看来没必要留着这个东西。相比之下，我更愿意 VS Code 使用像 Sublime Text 那样的 JSON 配置格式——虽然我知道它也有，只是它的 JSON 格式让我感觉在写 C# ，真的不舒服。鬼知道，别人用都没问题就我有问题？</p><p>目前对我来说还有疑惑的是 Server 版不能安装包，只能使用控制台安装。我不是很了解，因为之前没有用过 RStudio. RStudio Server 的 Python 智能提示比较慢，可能和服务器有关吧，需要再鼓捣鼓捣。除此之外应该没啥大问题了。不清楚这个服务器顶不顶得住大规模运算——虽然未必有。我也听过 Jupter NoteBook 可惜自己玩不会。</p><p>内存不够用着实让我眼前一黑。当时正编译，远程控制台直接卡崩，其他控制台瞬间动不了。我以为是自动挂起，结果怎么都连不上服务器，赶忙上阿里云控制台，发现有一个严重警告，没看懂。当时以为是安装问题，登陆服务器再试安装 Seurat 两遍都是强行断连接。最后瞟了一眼才发现是内存不足被系统强行杀掉。一直以为内存不是大事的我才意识到，我的服务器只有 2G 内存。当初学的 <code>dd</code> 那点知识终于用上了，看来 swap 分区还是有必要的，特别是老旧、内存不大的机子。</p><p>安装 Seurat 的一些经历也奇怪。之前有一阵子安装 miniconda3 ，配置 Seurat 的时候一直安装不了 Stringi 包，差点没怀疑人生——因为之前安装都没问题。结果第二天又可以安装了。我就不信这个邪，当晚再试——果然又安装不了。最后估摸着发现，晚上安装不了，白天可以？有点意思，可能这个包昼出夜伏。开个玩笑，可能那时候服务器顶不住太多的请求，又或者 DNS 污染，反正就这么奇葩。</p><h1 id="相关网址"><a href="#相关网址" class="headerlink" title="相关网址"></a>相关网址</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://docs.conda.io/en/latest/miniconda.html">https://docs.conda.io/en/latest/miniconda.html</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.rstudio.com/products/rstudio/download-server/">https://www.rstudio.com/products/rstudio/download-server/</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://scanpy.readthedocs.io/en/stable/installation.html">https://scanpy.readthedocs.io/en/stable/installation.html</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://satijalab.org/seurat/">https://satijalab.org/seurat/</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RStudio</tag>
      
      <tag>Miniconda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何使用Markdown写论文</title>
    <link href="/2022/03/15/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Markdown%E5%86%99%E8%AE%BA%E6%96%87/"/>
    <url>/2022/03/15/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Markdown%E5%86%99%E8%AE%BA%E6%96%87/</url>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>Markdown 作为新兴的写作工具越来越受人的青睐，用 Markdown 写成的纯文本文件可以快速移植，省去再排版的烦恼。既然如此，能否使用 Markdown 进行论文写作呢？答案是肯定的。Markdown 可以直接使用 $L^AT_EX$ 的数学公式排版，同时还可以搭配 Mermaid 进行画图。使用 Markdown 写完自己的文章之后，可以通过 Pandoc 进行格式转换，轻松导出成各种格式。Markdown 还可以配合 R 语言进行专业绘图和排版。</p><p>本次我们将借助 Zettlr 编辑器完成论文的基本排版和写作。如果你会 $L^AT_EX$ 的话请往他处。</p><h1 id="2-工具准备"><a href="#2-工具准备" class="headerlink" title="2. 工具准备"></a>2. 工具准备</h1><p>要准备的工具主要有以下几种：</p><ol><li>Zettlr Markdown 编辑器<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.zettlr.com/">[1]</span></a></sup>。</li><li>pandoc-crossref 交叉引用软件<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://github.com/lierdakil/pandoc-crossref/release/">[2]</span></a></sup>。</li><li>Zotero 文献管理工具<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.zotero.org/">[3]</span></a></sup>。</li></ol><p>下面我们会逐一介绍这些工具的使用。</p><p> 2.1. Zettlr Markdown 编辑器</p><p>Zettlr 是一款专门面向写作者和研究者的 Markdown 编辑器，由德国学者 Hendrik Erz 创建。理由很简单：他对现在的文字处理软件感到不满，他想要一个可以让他“专注于写作和阅读”的编辑器。秉承着自己动手丰衣足食的理念，这位大佬开始了自己的编程之路，于是 Zettlr 这个“二十一世纪的 Markdown 编辑器”诞生了。由于是为了学者和写作者而作，Zettlr 自带各种强大的属性。这里就不探讨它的强大功能了，有需求请去官网<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.zettlr.com/">[1]</span></a></sup>。</p><p>现在的 Markdown 编辑器数不胜数，为什么要选择 Zettlr ？其实理由很简单：它支持文献引用。写论文的时候，我们需要对一些参考文献进行引用。大多数时候靠 Word 可以快速使用各类文献管理器的引用插件，然而我更偏向 WPS。去年把自己的文献管理器从 NoteExpress 迁到 Zotero，谁知道 Zotero 没有 WPS 的插件。看了看相关开发者的反馈，据说他们找金山公司，希望开发 WPS 的 Zotero 插件，结果被告知 WPS 的 <ruby>应用程序开发接口<rt>Application Programming Interface</rt></ruby>( API ) 和 Office 的是一样的。也就是说，金山公司认为如果 Zotero 的插件可以在 Office 中使用，自然也可以在 WPS 中使用。可惜事实并非如此。前一阵我发现国外的大佬们在探讨这件事的时候说，原来 WPS 有开发者文档，可只有中文没有英文，他们看不懂。太可惜了，我看得懂。</p><p>那一阵子还在使用 Windows，写论文还可以用 WPS 配合 NoteExpress。现在使用了 Linux 系统，只能硬着头皮使用 Markdown。</p><p>说了那么多废话，其实就是想说，接下来论文就在 Zettlr 编辑器上完成了。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203132034512.png" alt="Zettlr 官网"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203132036443.png" alt="Zettlr 编辑器界面"></p><p>Zettlr 是 <ruby>WYSIWYM<rt>What You See Is What You Mean</rt></ruby>(所见即所想) 的 Markdown 即时渲染编辑器，有别于 Office Word 和 WPS Word 的 <ruby>WYSIWYG<rt>What You See Is What You Get</rt></ruby>(所见即所得)。唯一的不同是，它保留了 Markdown 的原始格式。</p><p> 2.2. YAML Front-matter</p><p>我们可以看到 Zettlr 文档的头部有一部分由三条横杠分隔，它叫做 <ruby>YAML<rt>Yet Another Markup Language</rt></ruby>Front-matter，中文名不知道，暂且叫做“标头”。这一部分使用的是 YAML 语法，可以配置文档信息。这一部分可以在官网教程查看。简单说一些配置：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">标题</span><br><span class="hljs-attr">author:</span> <br><span class="hljs-bullet">-</span> <span class="hljs-string">作者1</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">作者2</span><br><span class="hljs-attr">keywords:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">关键字2</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">关键字2</span><br><span class="hljs-attr">abstract:</span> <span class="hljs-string">|</span><br><span class="hljs-string">这里写摘要</span><br><span class="hljs-meta">---</span><br></code></pre></div></td></tr></table></figure><p>注意，YAML 语法的特点是，冒号之后的文字与冒号有一个空格，还有缩进：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># 正确操作</span><br><span class="hljs-attr">key:</span> <span class="hljs-string">value</span><br><span class="hljs-attr">keys:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">value1</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">value2</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">value3</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">value4</span><br><br><span class="hljs-comment"># 错误示范</span><br><span class="hljs-string">key:value</span><br><span class="hljs-attr">keys:</span><br><span class="hljs-string">-value1</span><br><span class="hljs-string">-value2</span><br><span class="hljs-string">-value3</span><br>  <span class="hljs-string">-value4</span><br></code></pre></div></td></tr></table></figure><p>后面与 YAML 有关的操作，如果你发现自己的配置不起作用，请检查是不是少了一个空格，或者缩进不对。</p><p> 2.3. 引用文献</p><p>要引用文献，我们需要打开 Zotero 文献管理器，选择 Better CSL JSON 或者 Better BibTex 格式导出文献库：</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203132055432.png" alt="导出文献库"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203132056233.png" alt="选择 CSL JSON 或者 BibTex 格式"></p><p>记住勾选 Keep Updated 保持更新，保存到你喜欢的文件夹。</p><p>回到 Zettlr，选择 文件—&gt;<ruby>首选项(偏好)<rt>Preferences</rt></ruby>，或者直接快捷键 <kbd>CTRL</kbd>+<kbd>,</kbd> 打开首选项，选择 <ruby>引用<rt>Citation</rt></ruby> 模块，在 <ruby>引用库<rt>Citation Database</rt></ruby> 下选择你刚刚导出的库，下一行填写你的参考文献格式的路径。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203132101687.png" alt="首选项"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203132102458.png" alt="填写引用文献的路径和类型"></p><p>参考文献格式是我们论文最后写的文献的格式，国内通常使用 GB2005 。可以在 Zotero 中下载，然后在 Zotero 安装路径里边找 Styles 文件夹，找到你想使用的 <ruby>引用格式(CSL)<rt>Citation Style Language</rt></ruby> ，复制路径到上面需要填写的地方。Zotero 的使用可以参考我之前写的文章。</p><blockquote><p>Zotero 使用的文章</p><p><a href="https://chunshuyumao.github.io/2022/03/15/Zotero%E6%96%87%E7%8C%AE%E7%AE%A1%E7%90%86%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/">Zotero文献管理插件安装</a></p><p>还有一篇安装的文章，原始 Markdown 文件不见了，懒得再写，要看只能去公众号：椿树与猫 查看。</p></blockquote><p>到这里，我们的准备就完成了。Zettlr 中引用文献使用 <code>[@CiteKey]</code>，其中 <code>CiteKey</code> 就是我们之前在 Zotero 安装的 Better BibTex 提供的独一无二的标识，包含引用的文献的一些信息，例如文献标题或者作者、年限什么的。看下面，我只是输入了 <code>@</code> 它就自动弹出了文献库的文献，这时候你只需要再添加一些信息就可以快速查找自己想引用的文献。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203132110871.png" alt="尝试引用"></p><p>引用完之后， Zettlr 的右边会出现一个引用列表，如果没有，也可以点它出现，就像这样：</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203132112145.png" alt="引用列表"></p><p>如果想要修改自己的引用格式，就更改 CSL-Style 的路径。</p><p>这是最基础的使用，我们可以使用 <kbd>CTRL</kbd>+<kbd>E</kbd> 导出试试(也可以在 <ruby>文件<rt>File</rt></ruby> 中选择导出)：</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203132114242.png" alt="导出"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203132117406.png" alt="导出"></p><p>导出之后，它自己给我们标号和更改参考文献格式。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203132119048.png" alt="PDF 格式"></p><p> 2.4. 修改 Word 模板</p><p>有些时候，我们需要各种 Word 格式，可以通过修改 Pandoc<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://pandoc.org/">[4]</span></a></sup> 默认模板完成。首先你的电脑要安装 Pandoc ，并配置好环境变量。<kbd>Windows</kbd>+<kbd>R</kbd>输入 CMD ( 不可使用 Powershell ) 或者在 Linux 打开终端，输入一下代码</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">pandoc --print-default-data-file=reference.docx &gt; ref.docx<br></code></pre></div></td></tr></table></figure><blockquote><p>Zettlr 内置 Pandoc，但是我们要定义自己的 Word 模板需要下载 Pandoc。如果不想安装，可以从 Zettlr 安装目录找找有没有 Pandoc 可执行文件。我不知道 Windows 系统可不可以找到，无论如何，还是建议直接直接安装 Pandoc ——大不了用完再卸载。</p></blockquote><p>正常情况下，你所在的目录会出现一个 ref.docx 的文件，那就是你的 Word 模板文件。使用 WPS 或者 Office Word 打开，然后修改格式，不是在正文修改，而是类似下面这个模板修改</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203132129394.png" alt="修改格式"></p><p>修改的具体格式得看你自己了，因为没有万能的论文格式。</p><p>一般而言，三线图是不可以直接修改的：如果真的使用 Markdown 写论文，导出成 Word 格式之后还需要手动修改三线图。</p><p>修改完之后，打开 Zettlr 的<ruby>资源管理器<rt>Assets Manager</rt></ruby>，选择<ruby>导出<rt>Export</rt></ruby>中的 Word 设置，在末尾添加</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">reference-doc:</span> <span class="hljs-string">/home/chunshuyumao/Zotero/forzettlr/ref.docx</span><br></code></pre></div></td></tr></table></figure><p><code>reference-doc</code>后添加的是你的 ref.docx 所在路径，上面写的是我的路径，别抄。</p><p>默认情况下导出的参考文献的标题是英文 Reference。如果你想改成中文“参考文献”，可以在标头或者 Word 导出设置中添加：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">reference-section-title:</span> <span class="hljs-string">&quot;参考文献&quot;</span><br></code></pre></div></td></tr></table></figure><p>导出设置中的 <code>shift-heading-level-by</code> 需要注意一下：它的意思是修改标头的等级。一般来说，一个<code>#</code>表示一级标题，两个表示二级标题。如果你想让一个 <code>#</code> 表示三级标题，那就改成 <code>shift-heading-level-by: -3</code>；如果想让 <code>#</code> 表示一级标题，那就改成 <code>shift-heading-level-by: 3</code>。大家可能会奇怪：为什么会有这种神奇的语法？我想用一级标题就用一级标题，想用二级就用二级，为什么还搞得这么花里胡哨？其实不然，我们写 Word 的时候，通常是从一级标题开始，但是在网页上，一级标题太大了，网页上的最高一级的标题实际上是 Word 上的三级标题。所以在写的时候，我们可以使用三级标题，导出为 Word 的时候直接修改<ruby>偏移量<rt>shift-heading-level-by</rt></ruby>就免去了大量修改的麻烦。</p><p> 2.5. 交叉引用</p><p>我相信，本科生基本没有考虑过什么是交叉引用。很简单，即使是经常写论文的我们专业也很少会碰见大量的图片修改，或者论文存在大量图片。大多数情况下，我们写论文都是手动写索引，例如”图1””图2””图3””表1””表2””表3”。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203160936531.png" alt="手动写图片索引"></p><p>然而这种手动操作，存在一个很大的弊端：我不想手操。</p><p>好的，懒人兴致勃发，接下来就是如何偷懒：让 Markdown 自己给我们标号。先看看原始状态：</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Markdown">![<span class="hljs-string">我大南开</span>](<span class="hljs-link">file:///home/chunshuyumao/Pictures/signture.png</span>)<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203160944232.png" alt="效果如下"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203160945421.png" alt="导出为 Word 之后"></p><p>我们想让它自动标号，需要下载一个交叉引用的插件，叫做 pandoc-crossref <sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://github.com/lierdakil/pandoc-crossref/releases/">[5]</span></a></sup>，老规矩——上不去就去<ruby>码云<rt>Gitee</rt></ruby>找镜像。下载之后把它放到一个安全的地方，以免以后被你误删——建议和 Pandoc 可执行文件放一起，这样好找。</p><p>在自己的文件标头写</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Markdown">filters:<br><span class="hljs-bullet">-</span> /usr/bin/pandoc-crossref<br></code></pre></div></td></tr></table></figure><p>其中 <code>/usr/bin/pandoc-crossref</code> 是你的 pandoc-crossref 路径 。</p><blockquote><p>注意：Windows 系统使用的分隔符是 \ ，我现在在 Linux 系统，所以使用 &#x2F; 。希望使用时记得区别。</p></blockquote><p>然后在自己的图片以后这样写</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Markdown">![<span class="hljs-string">我大南开</span>](<span class="hljs-link">file:///home/chunshuyumao/Pictures/signture.png</span>)&#123;#fig:id&#125;<br></code></pre></div></td></tr></table></figure><p>其中 <code>id</code> 是一个<strong>没有空格</strong>的标识，我使用 <code>this</code> 作为标识：</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Markdown">![<span class="hljs-string">我大南开</span>](<span class="hljs-link">file:///home/chunshuyumao/Pictures/signture.png</span>)&#123;#fig:this&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>注意，&#96;</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
      <tag>Zettlr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zotero文献管理插件安装</title>
    <link href="/2022/03/15/Zotero%E6%96%87%E7%8C%AE%E7%AE%A1%E7%90%86%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    <url>/2022/03/15/Zotero%E6%96%87%E7%8C%AE%E7%AE%A1%E7%90%86%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>前面介绍了 Zotero<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.zotero.org/">[1]</span></a></sup> 等文献管理工具的安装和简单使用。今天讲讲 Zotero 插件的使用。早前我有说过，Zotero 具有丰富的插件支持。由于当时为了介绍其他的两款文献管理工具，避免篇幅过长，所以没有介绍 Zotero 的插件。</p><h1 id="2-安装插件"><a href="#2-安装插件" class="headerlink" title="2. 安装插件"></a>2. 安装插件</h1><p>在介绍安装插件之前，我们要知道，Zotero 插件通常都可以在官网<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.zotero.org/support/plugins/">[2]</span></a></sup>找到。好的我们继续。</p><p>首先看没有安装任何插件的 Zotero 中文界面:</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152053611.png" alt="原始中文界面"></p><p>推荐安装浏览器插件 Zotero Connector :</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152055785.png" alt="安装 Connector 插件"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152056245.png" alt="浏览器中的 Connector"></p><p>我使用火狐浏览器，所以插件推荐的是火狐。安装 Connector 插件为的是后面更好地下载论文。安装好之后，你的浏览器右上角应该出现这个标志。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152104923.png" alt="Connector"></p><p>现在打开任何一个可以查论文的东西——实际上，Zotero 不仅仅可以管理论文，还包括所有浏览器能嗅探的东西，例如网页——这里随便查找文献。右上角的图标变成了学者的帽子，点击之后会自动抓取。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152107569.png" alt="自动识别论文"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152109547.png" alt="自动抓取"></p><p>为了后面的示范。我还抓取了几篇论文。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152111974.png" alt="抓取的论文"></p><p>Zotero 抓到是抓到了，但是 PDF 文件似乎没有进行重命名。我们希望它可以对我们的论文 PDF 进行重命名。这里我们需要下载一个插件，叫做 Zotfile<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="http://zotfile.com/">[3]</span></a></sup>。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152114431.png" alt="Zotfile 官网网址"></p><p>下载完之后，打开 Zotero 的 <code>工具--&gt;插件</code>，选择 <code>Install Add-on From File</code>，然后进行安装，每次安装之后都需要重启。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152116952.png" alt="选择 install from file"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152117551.png" alt="安装"></p><p>重新打开之后，选择要修改的文件，<code>右键--&gt;根据父级元素重命名</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152120959.png" alt="重命名"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203160747860.png" alt="重命名"></p><p>修改完之后，我们看到，标签里的作者名字是分开的，我们不希望姓名分开，所以安装下一个插件：<ruby>茉莉花<rt>Jasminum</rt></ruby><sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://github.com/l0o0/jasminum/releases">[4]</span></a></sup>。这款插件不在官网，却不可或缺。到 GitHub 下载 <code>xpi</code> 文件。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152128362.png" alt="下载 xpi 文件"></p><p>下载之后安装重启。右键小工具，可以修改。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152129563.png" alt="右键小工具"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152130199.png" alt="名字已经正常了"></p><p>还可以在 <code>首选项</code> 中修改配置</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152132410.png" alt="茉莉花配置"></p><p>最后下载 Better BibTex<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://retorque.re/zotero-better-bibtex/">[5]</span></a></sup>。如其名，这个和 $L^AT_ET$有关。不过不用担心，先安装再说。重启配置，选择 <code>BBT default citekey format</code>，允许拖拽引用，最后一直 <code>next</code> 就行了。安装完之后，就会看到 <code>CiteKey</code>，这是你引用的时候查找的关键字。当然也可以更改。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152134383.png" alt="Better BibTex"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152144263.png" alt="重启配置，选择 BBT default citekey"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152145391.png" alt="允许拖拽引用"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152234217.png" alt="安装完成"></p><p>到 <code>首选项</code> 中选择 <code>重命名链接的文件</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152148519.png" alt="配置"></p><p>到这里，我们的插件基本安装完了，如果你还有什么想要安装的，可以到官网查找插件或者 GitHub 上面查找。</p><p>对我而言，Zotero 还可以用来做文献阅读笔记，所以习惯性添加 MarkdownHere<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://github.com/adam-p/markdown-here">[6]</span></a></sup> 插件。如果上不去，可以用 Gitee<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://gitee.com/mirrors/markdown-here">[7]</span></a></sup>。同理，上面的插件如果上不了 GitHub ，可以搜索 <code>插件名 Gitee</code>，一般都有镜像。进入下载的文件夹或者解压的文件夹中的 src ，压缩 <code>common</code>、<code>firefox</code>、<code>chrome.manifestr</code>、<code>install.rdf</code>到随便一个文件夹，建议仍然使用 <code>MarkdownHere</code>，修改后缀为 <code>xpi</code>，然后进行安装。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152221183.png" alt="压缩"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152223699.png" alt="MarkdownHere 插件"></p><p>安装完之后可以使用 Markdown 做笔记，做完笔记之后全选使用 <kbd>CTRL</kbd>+<kbd>ALT</kbd>+<kbd>M</kbd>进行格式转化。选择一篇论文，单击下边的笔记 ( Notes ) –&gt; 添加 ( add )，做笔记。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152232204.png" alt="全选原始格式"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152232962.png" alt="MarkdownHere渲染的格式"></p><p>哈哈，果然简单是吧？其实蛮喜欢 Markdown Here 的，我的邮箱客户端就安装了它。</p><p>如果想更改你的导出格式，可以到 <code>首选项---&gt;引用---&gt;更多样式</code> 查找你的参考文献格式。默认国内使用 GB2005 。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152241815.png" alt="添加格式"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203152242873.png" alt="国标"></p><p>Zotero 的引用格式会安装到自己目录的 <code>Styles</code> 文件夹，所以别忘了你的 Zotero 安装到哪里——后面我们会用到。</p><h1 id="3-后语"><a href="#3-后语" class="headerlink" title="3. 后语"></a>3. 后语</h1><p>Zotero 对与一个经常看文献的人来说确实是一个好东西。我现在还是要感慨，为什么 WPS 没有相应的 Zotero 插件？这是逼我使用 Markdown 写论文呀——所以下一篇就打算写写如何用 Markdown 写论文。</p><h1 id="相关网址"><a href="#相关网址" class="headerlink" title="相关网址"></a>相关网址</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.zotero.org/">https://www.zotero.org/</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.zotero.org/support/plugins/">https://www.zotero.org/support/plugins/</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="http://zotfile.com/">http://zotfile.com/</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://github.com/l0o0/jasminum/releases">https://github.com/l0o0/jasminum/releases</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://retorque.re/zotero-better-bibtex/">https://retorque.re/zotero-better-bibtex/</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span><a href="https://github.com/adam-p/markdown-here">https://github.com/adam-p/markdown-here</a><a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:7" class="footnote-text"><span><a href="https://gitee.com/mirrors/markdown-here">https://gitee.com/mirrors/markdown-here</a><a href="#fnref:7" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zotero</tag>
      
      <tag>文献管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FTP服务进阶</title>
    <link href="/2022/03/12/FTP%E6%9C%8D%E5%8A%A1%E8%BF%9B%E9%98%B6/"/>
    <url>/2022/03/12/FTP%E6%9C%8D%E5%8A%A1%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>上次搭建的 FTP 服务满足基本的要求，但是还有一些情况我们没有考虑。这次主要针对两种情况进行优化：</p><ol><li><ruby>被动模式<rt>passive mode</rt></ruby>(PASV)。</li><li><ruby>虚拟用户<rt>virtual users</rt></ruby>。</li></ol><h1 id="2-被动模式"><a href="#2-被动模式" class="headerlink" title="2. 被动模式"></a>2. 被动模式</h1><p> 2.1. FTP 服务的两种模式</p><p>FTP 服务端和客户端的通信有两种模式，一个是<ruby>主动<rt>PORT</rt></ruby>模式，另一种是<ruby>被动<rt>PASV</rt></ruby>模式。两种模式的主要区别是相对于服务端而言。</p><ol><li>主动模式。客户端通过随机端口 X 连接到服务器 21 端口，告诉服务器：用你的 20 端口连接我的 Y 端口。随后 Y 端口和 20 端口进行数据传输。</li><li>被动模式。客户端通过随机端口 X 连接到服务器 21 端口，服务器告诉客户端：连接到我的 Z 端口。随后客户端通过自己的另一个随机端口 W 连接到服务器的 Z 端口。</li></ol><p>这样看来，被动模式似乎更麻烦，实际确实如此，但这种麻烦是有原因的。大多数人的电脑使用的是 Windows 系统， Windows 系统的防火墙一般默认开启。防火墙通常会阻止各种端口的接入。主动模式下，服务器用 20 端口连接客户端的 Y 端口，如果防火墙开启，就会阻止 20 端口和 Y 端口连接。下面演示一下：</p><p>首先关闭我的防火墙，也就是没有防火墙干扰的情况下的连接。下面查看防火墙状态之后发现是<ruby>未激活的<rt>inactive</rt></ruby>。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203121023625.png" alt="没有防火墙"></p><p>没有防火墙的时候，可以正常使用 ls 命令列出登陆目录下的文件。</p><p>接下来打开防火墙再次进行连接：</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203121026609.png" alt="激活防火墙之后连接"></p><p>这次防火墙处于激活状态，我们可以正常登陆 FTP 服务端，但是无法发送指令。因为登陆使用的随机端口 X 可以被服务器接收，服务器收到连接 Y 端口的指令并用 20 端口连接到客户端的 Y 端口的时候被防火墙挡住了。客户端再次发送指令，服务器的所有反馈都没有办法进入客户端。这样，服务器和客户端也就无所谓连接。</p><p>想要继续连接有两个办法：</p><ol><li>关闭防火墙。</li><li>服务端开启<ruby>被动<rt>PASV</rt></ruby>模式。</li></ol><p>方法一简单粗暴，但是有些人不希望自己的防火墙关闭，为了一劳永逸只能选择开启被动模式。</p><p>服务端开启被动模式。我们查看防火墙一直开着，登陆 FTP 使用主动模式的指令还是失败，使用 <code>passive</code>进入被动模式，然后输入指令，发现可以正常操作。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203121038954.png" alt="开启被动模式"></p><p>这样，被动模式就成功在客户端存在防火墙的情况下仍然可以和服务端连接。</p><blockquote><p>默认情况下防火墙只会阻止某些端口的进入，客户端端口可以正常向外访问，所以被动模式的服务器给了客户端一个端口，让客户端去连接服务器，主动模式下则是服务器连接客户端。因此，主动和被动是相对服务器而言的：主动模式下服务器连接，被动模式下客户端连接。</p></blockquote><p> 2.2. 开启被动模式</p><p>连接服务器，使用你喜欢的编辑器打开 vsFTPd 配置文件</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo vim /etc/vsftpd/vsftpd.conf<br></code></pre></div></td></tr></table></figure><p>直接转到最后一行，添加以下配置</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">pasv_enable=YES<br>pasv_addr_resolve=YES<br>pasv_address=101.200.84.36<br>pasv_min_port=41001<br>pasv_max_port=42010<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203121049175.png" alt="修改配置文件"></p><p>解释一下，<code>pasv_enable</code> 配置<ruby>被动模式 <rt>passive</rt></ruby>( PASV) 是否开启。默认情况下被动模式是开启的，但是不起作用。</p><p><code>pasv_addr_resolve</code> 配置的是域名解析。虽然不一定用到，但是还是写下吧。</p><p><code>pasv_address</code> 配置返回的 IP 。如果你的 vsFTPd 服务器是安装在局域网，例如自己家庭使用、虚拟机练习，那这个 IP 就填你的局域网 IP ；如果 vsFTPd 部署在自己服务器，那就使用服务器公网 IP 。</p><blockquote><p>公网 IP 是你购买服务器后，云服务商手机告诉你的公网 IP。如果忘了，可以到服务商提供的控制台查看。</p><p>局域网 IP 简单，就是你使用  <code>ip addr</code> 或者 <code>ifconfig</code>看到的 IP 。</p></blockquote><p>如果不填写 <code>pasv_address</code> 而且你的服务器是云服务器，即使你的被动模式开启了，其他人也连接不上，会出现这样的提示：</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203121100091.png" alt="取消公网 IP "></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203121059035.png" alt="没有配置公网 IP "></p><p>因为被动模式开启但没有配置公网 IP ，服务器就使用局域网 IP 作为被动模式的 IP，例如我服务器的局域网 IP  <code>172.27.163.6 </code>。因此使用云服务器一定要改 <code>pasv_address</code>。</p><p><code>pasv_min_port</code> 和 <code>pasv_max_port</code> 是服务器开放的端口范围，什么意思？就是服务器可能也要开防火墙——总不能让它冒险吧——因此保留这些端口不挡住，可以给客户端在被动模式时连接。范围可大可小——但是注意，由于一个端口一般只能连接一台客户端，如果 FTP 服务器使用人数比较多可以把端口范围放大，否则可以调小。建议使用高端口，但是也不要超过五位数。</p><p>设置完成之后保存退出，重启 vsFTPd 服务</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo systemctl restart vsftpd<br></code></pre></div></td></tr></table></figure><p>到这里，被动模式已经开启。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203121111379.png" alt="再次测试"></p><p>一般来说，被动模式和主动模式可以同时开启：以备不时之需。</p><p>Windows 的 FTP 客户端一般都会选择被动模式登陆，如果服务端没有开启被动模式，客户端就无法获取服务端的文件。这种时候可以查看客户端的设置，通常可以选择连接模式。如果是 Linux ,一般都是手动操作。保不准自己进入了被动模式，那怎么退出？大多数的 FTP 客户端会提供一些指令，可以使用 <code>help</code> 或者 <code>?</code>进行查询：</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203121115309.png" alt="FTP 客户端命令"></p><p>这么来说，我的客户端退出被动模式就很简单了:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">passive off<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203121117065.png" alt="退出被动模式"></p><h1 id="3-虚拟用户"><a href="#3-虚拟用户" class="headerlink" title="3. 虚拟用户"></a>3. 虚拟用户</h1><p>刚搭建的 FTP 服务器开启了匿名模式，即可以使用 ftp 作为用户名无密码登陆；还允许本地用户登陆，即允许服务器上的用户登陆。这样有一定风险的：本地用户拥有的权限，登陆后仍然拥有。比如我进行登陆，可以直接看到整个服务器的目录结构：</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203121123862.png" alt="服务器目录结构"></p><p>这就产生了权限漏洞。如果我们即想要分享，又不希望别人对自己的文件进行不必要的干扰，最好的办法就是创建虚拟用户，然后进行权限限制。</p><p> 3.1. 添加服务器用户</p><p>首先我们需要在服务器创建一个映射虚拟用户的不可登陆的用户帐号：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo useradd vuser -d /var/ftp -s /sbin/nologin<br></code></pre></div></td></tr></table></figure><p>解释一下，<code>-d</code> 是指定虚拟用户的家目录，我们之前已经创建过这个目录作为匿名用户的家目录，现在我们不打算使用匿名帐户，直接把家目录划给虚拟用户。</p><p>虚拟用户只是一个系统权限映射的用户，没有必要让它登陆服务器，所以设置使用 <code>-s</code> 指定它不可登陆。</p><blockquote><p><code>-s</code>一般是创建用户时指定使用的 <code>shell</code> ， Linux 中通过把 <code>shell</code> 指定到 <code>nologin</code> 实现禁止登陆</p></blockquote><p>创建之后可以使用</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">cat /etc/passwd | grep vuser<br></code></pre></div></td></tr></table></figure><p>查看用户信息</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203121143056.png" alt="查看虚拟用户信息"></p><p> 3.2. 添加虚拟用户</p><p>进入 <code>/etc/vsftpd</code> 添加一个文件，我这里是 <code>vuser.cfg</code> ，在里边填入虚拟用户的信息。注意，单行是用户名，双行是用户密码：</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203121148543.png" alt="添加虚拟用户"></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">lileilei<br>20220202<br>hanmeimei<br>20220303<br></code></pre></div></td></tr></table></figure><p>保存退出。</p><p><code>cfg</code>文件不能被 vsFTPd 读取，需要转化格式，变成可读的 <code>db</code> 格式：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo db_load -T -t hash -f /etc/vsftpd/vuser.cfg /etc/vsftpd/vuser.db<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203121153783.png" alt="转化为 db 格式"></p><p>把 <code>db</code> 改为只有 root 用户可以读写</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo chmod 600 vuser.db<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203121253782.png" alt="修改权限"></p><p>让 vsFTPd 读取自己配置的 <code>db</code> ，需要配置<ruby>可插入认证模块<rt>Pluggable Authentication Modules</rt></ruby>( PAM )文件。</p><p>创建 PAM 文件：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo vim /etc/pam.d/vsftpd.vuser<br></code></pre></div></td></tr></table></figure><p>输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">auth sufficient /lib64/security/pam_userdb.so db=/etc/vsftpd/vuser<br>account sufficient /lib64/security/pam_userdb.so db=/etc/vsftpd/vuser<br></code></pre></div></td></tr></table></figure><p><code>db</code> 之后的配置文件是我们上面写的 vuser.db 文件。</p><p> 3.3. 修改 vsFTPd 配置文件</p><p>进入 <code>/etc/vsftpd</code> 目录，如果没有 <code>vuserconfig</code>目录，则创建一个新的目录。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">cd /etc/vsftpd/<br>sudo mkdir vuserconfig<br></code></pre></div></td></tr></table></figure><p>然后进入 vuserconfig 目录，目录里边是我们的虚拟用户的权限文件。想要限制谁的权限，就在这个目录创建同名的文件。我配置一个用户的权限：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo vim lileilei<br></code></pre></div></td></tr></table></figure><p>配置权限</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">local_root=/var/ftp<br>write_enable=YES<br>anon_umask=022<br>anon_world_readable_only=NO<br>anon_upload_enable=YES<br>anon_mkdir_write_enable=YES<br>anon_other_write_enable=YES<br>download_enable=YES<br></code></pre></div></td></tr></table></figure><p>修改 &#x2F;etc&#x2F;vsftpd&#x2F;vsftpd.conf 文件：注释掉 pam_service_name&#x3D;vsftpd，这是默认的用户配置文件，我们添加了虚拟用户，所以改成我们自己的 vsftpd.vuser ，这里的 guest_username&#x3D;vuser 的 vuser 与我们在服务器建立的 vuser 用户名字一样。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">guest_enable=YES<br>guest_username=vuser<br>user_config_dir=/etc/vsftpd/vuserconfig<br>allow_writeable_chroot=YES<br>pam_service_name=vsftpd.vuser<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203121327337.png" alt="修改 vsFTPd 配置文件"></p><p>最后重启 vsFTPd 服务</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo systemctl restart vsftpd<br></code></pre></div></td></tr></table></figure><p>客户端尝试本地用户登陆，发现失败了；使用虚拟用户 lileilei 登陆成功。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203121332066.png" alt="尝试本地用户登陆"></p><p>虚拟用户，创建完毕！如果要继续添加新用户，可以往 vuser.cfg 添加，然后生成 <code>db</code> 文件就可以了。</p><h1 id="4-后语"><a href="#4-后语" class="headerlink" title="4. 后语"></a>4. 后语</h1><p>上面就是我们 FTP 的进阶配置。可以看到，虽然 FTP 显得很古老，但是仍然具有很强大的功能。通过一些配置可以实现虚拟用户登陆、配置登陆用户的权限等等，所以 FTP 仍然可以在现在这个互联网时代保持其优异的分享功能。</p><p>实际上，如果是在家庭中，我们可以自己搭建一个局域网内的 FTP 服务器，让自己的家庭成员可以分享自己的文件，这比使用公有云更安全，对隐私的保护更出色。</p><p>FTP 可探索的配置还是很多的，所以好好探索吧！</p>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Manjaro 双系统引导修复</title>
    <link href="/2022/03/05/manjaro%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC%E4%BF%AE%E5%A4%8D/"/>
    <url>/2022/03/05/manjaro%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC%E4%BF%AE%E5%A4%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>人在江湖飘，哪有不挨刀。我装双系统之前，电脑只安装了 Manjaro ，后来以防万一装了 windows 。因为引导  Windows11 一直失败，所以我先安装了  Windows10 。后来把所有的问题都搞定之后，我就给我的  Windows10 升级。升到  Windows11 本来是好事，结果启动 Manjaro 的时候，直接进入了 grub rescue 模式。</p><p>在此之前，我完全不相信双系统会出现这种问题。毕竟我给我的硬盘分好了区，两个系统井水不犯河水。当时觉得别人出现问题是因为他们没有正确处理这些问题。当我的 linux 系统的 grub 被 Windows 弄坏的时候，我知道我也中招了。</p><p>这种问题按理来说不是难事，可是当我跑到网上去查的时候，发现能查出来的都是不知所云的。果然百度不能信。求天求地不如求己，因此又有了这篇引导修复的文章。</p><hr><h1 id="引导修复"><a href="#引导修复" class="headerlink" title="引导修复"></a>引导修复</h1><p>我的 Manjaro 系统出现故障的时候，只要一选择 Manjaro 启动就会跑到 grub rescue 界面，所以如果你可以进入正常的引导界面，只是启动后黑屏的话，多半是驱动问题，这篇文章自然就不用看了。</p><p>引导修复有两种办法：</p><ol><li>Live CD修复</li><li>手动修复</li></ol><p>第一种方法对于 Windows 玩机大家来说很简单了，就是各类的 PE机 做的事。不过我还是说说。</p><h2 id="Live-CD修复"><a href="#Live-CD修复" class="headerlink" title="Live CD修复"></a>Live CD修复</h2><p>这种方式要求你有一个 Manjaro 启动盘或者和你系统一样的启动盘。为什么使用 Manjaro Live CD ？因为 Manjaro 本身支持 LiveCD 。启动盘不难制作，按我之前说，直接用 Ventoy <sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://ventoy.net/">[1]</span></a></sup>制作即可。</p><p>启动电脑进入 BIOS 或者 UEFI 界面，选择U盘启动，就像安装 Manjaro 一样直到进入图形界面。</p><p>进入图形界面之后，打开控制台，输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo fdisk -l<br></code></pre></div></td></tr></table></figure><p>查看你的硬盘分区，通常你是可以知道自己的硬盘分区的。例如分区如下，我的 Manjaro 安装在 Windows 之后，所以倒数一二块分区应该就是我的 Manjaro 的 EFI 和 根(root) 分区:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">Disk /dev/nvme0n1: 476.94 GiB, 512110190592 bytes, 1000215216 sectors<br>Disk model: INTEL SSDPEKNW512G8                     <br>Units: sectors of 1 * 512 = 512 bytes<br>Sector size (logical/physical): 512 bytes / 512 bytes<br>I/O size (minimum/optimal): 512 bytes / 512 bytes<br>Disklabel type: gpt<br>Disk identifier: 2CBB82D2-DA15-824E-A9B0-AF96C6143278<br><br>Device             Start        End   Sectors   Size Type<br>/dev/nvme0n1p1      2048     616447    614400   300M EFI System<br>/dev/nvme0n1p2    616448     649215     32768    16M Microsoft reserved<br>/dev/nvme0n1p3    649216  159879167 159229952  75.9G Microsoft basic data<br>/dev/nvme0n1p4 159879168  161349631   1470464   718M Windows recovery environmen<br>/dev/nvme0n1p5 161351680  161966079    614400   300M EFI System<br>/dev/nvme0n1p6 161966080 1000215182 838249103 399.7G Linux filesystem<br></code></pre></div></td></tr></table></figure><p>接下来是挂载我的 Manjaro 两个分区，同时转换到挂载的目录：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo mount /dev/nvme0n1p6 /mnt<br>sudo mount /dev/nvme0n1p5 /mnt/boot/efi<br>manjaro-chroot /mnt<br></code></pre></div></td></tr></table></figure><p>转换之后，命令提示符应该从原本的 Manjaro 格式变成其他格式，我的变成了这样</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sh-5.1#<br></code></pre></div></td></tr></table></figure><p>这时候，我们需要更新我们的 grub ，然后再次安装它：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">update-grub<br>grub-install /dev/nvme0n1p5<br></code></pre></div></td></tr></table></figure><p>当然，你要是不放心，还可以再次生成 grub ：</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">grub-mkconfig -o <span class="hljs-regexp">/boot/g</span>rub/grub.cfg<br></code></pre></div></td></tr></table></figure><p>然后退出，卸载，然后重启</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">exit<br>sudo umount -R /mnt<br>reboot<br></code></pre></div></td></tr></table></figure><p>正常情况下，你的系统应该可以启动了。</p><h2 id="手动修复"><a href="#手动修复" class="headerlink" title="手动修复"></a>手动修复</h2><p>这种情况是你手中没有 Live CD ，或者没有合适的 Live CD 。这种就很难受了。</p><p>首先你会看到这个提示</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">eorror: unkown filesystem<br>Entering rescue mode...<br>grub rescue &gt; <br></code></pre></div></td></tr></table></figure><p>如果没有这个提示，很好，你的问题我不能解决，你可以另往它处了。</p><p>第一步，我们先看一下自己的 Manjaro 系统在哪里，使用<code>ls</code>。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">ls<br></code></pre></div></td></tr></table></figure><p>我的提示如下</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">(hd0) (hd1) (hd1,gpt4) (hd1,gpt3) (hd1,gpt2) (hd1,gpt1) (hd2,gpt6) (hd2,gpt5) (hd2,gpt4) (hd2,gpt3) (hd2,gpt2) (hd2,gpt1) <br></code></pre></div></td></tr></table></figure><p>你的分区可能不会这么多，所以不用担心。</p><p>接下来就是烦人的操作了，使用<code>ls</code>一个个查看这些分区，例如</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">ls (hd0)/<br>ls (hd1,gpt4)/<br>...<br></code></pre></div></td></tr></table></figure><p>注意，hd1和gpt4之间除了逗号，什么也没有，括号之后还需要加上<code>/</code>，除此之外不要添加别的东西。</p><p>一个一个地试，你可以会得到这类消息</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">error: unkown filesystem<br></code></pre></div></td></tr></table></figure><p>恭喜你，你成功排除了一个选项，请继续排除。</p><p>等到你找到类似下面这个</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">ls (hd2,gpt6)<br>./ ../ lost+found/ boot/ dev/ home/ opt/ proc/ run/ sys/<br></code></pre></div></td></tr></table></figure><p>的提示的时候，这说明你找对了，只要看到<code>boot/</code>就说明已经正确了。记住你的卷标，我的是<code>(hd2,gpt6)</code></p><p>接下來输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">set root=(hd2,gpt6)<br>set prefix=(hd2,gpt6)/boot/grub<br>insmod normal<br>normal<br></code></pre></div></td></tr></table></figure><p>至此，你的引导系统算是正确了。它会自己重启。</p><p>不急，等你进入系统之后打开控制台(终端),输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">fdisk -l<br></code></pre></div></td></tr></table></figure><p>查找你的 Manjaro 的 EFI 在哪里，我的是<code>/dev/nvme0n1p5</code>，我知道，上面我就试过了。然后输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo update-grub<br>sudo grub-install /dev/nvme0n1p5<br></code></pre></div></td></tr></table></figure><p>重启一下，你的系统又变好！！</p><hr><h1 id="后语"><a href="#后语" class="headerlink" title="后语"></a>后语</h1><p>只要不乱搞，你的系统是不会有问题的。所以当你的系统有问题的时候，别急着责怪电脑，毕竟你比电脑还不负责。</p><hr><h1 id="相关网址"><a href="#相关网址" class="headerlink" title="相关网址"></a>相关网址</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://ventoy.net/">https://ventoy.net/</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>引导修复</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Manjaro 安装常用软件</title>
    <link href="/2022/03/05/manjaro%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/"/>
    <url>/2022/03/05/manjaro%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面我们已经安装好  Manjaro 系统了，现在就是安装一些常用的软件。此外，自己并非工科生，使用的 Windows 专有软件不多。</p><hr><h1 id="配置国内源以及更新系统"><a href="#配置国内源以及更新系统" class="headerlink" title="配置国内源以及更新系统"></a>配置国内源以及更新系统</h1><p>  Manjaro 是国外的系统，服务器往往在国外。想要使用  Manjaro 官方软件包需要配置。以前使用 Arch 需要手动配置国内源，然而  Manjaro 更加简单：它把世界各地的软件源镜像组合到官方的文件源系统，可以使用简单的工具自动为你筛选速度最快的软件源。</p><p>首先打开你的终端，输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo pacman-mirrors -c China -m rank<br></code></pre></div></td></tr></table></figure><p>其中，<code>sudo</code>允许你行使管理员的命令，<code>pacman-mirrors</code>是选择最快源的命令；<code>-c</code>是指定地区，这是使用中国；<code>-m</code>是方法，我们选择<code>rank</code>，就是把速度最快的挪到前面。它会要求你输入你的密码，注意，输入密码的时候你是看不到反馈的——也就是说，你看不到自己输入的密码，那里黑漆漆的一片。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051124391.png" alt="配置国内源"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051126408.png" alt="配置完成"></p><p>好的，现在你已经有了对你来说最快的软件源。接下来我们先更新系统：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo pacman -Syyu<br></code></pre></div></td></tr></table></figure><p>当它询问是否安装的时候，我们选择 是 。等它继续更新系统，再次选择 是 。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051127397.png" alt="更新系统，选择y"></p><p>在它安装这个阶段，我先介绍一下我们的指令是什么意思。</p><p>  Manjaro 使用的是 pacman 包管理器，记住 pacman 的一些指令即可：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">这是安装一个包</span><br>sudo pacman -S 包名<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这是查询一个包</span><br>pacman -Ss 包名<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这是删除一个包</span><br>sudo pacman -R 包名<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这是删除一个包和它的依赖包</span><br>sudo pacman -Rs 包名<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这是删除系统不使用的、多余的包</span><br>sudo pacman -Rs $(pacman -Qtdq)<br></code></pre></div></td></tr></table></figure><p>如果你还想知道<code>pacman</code>的更过用法，你可以使用：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">man pacman<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者</span><br>pacman --help<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者</span><br>pacman -h<br></code></pre></div></td></tr></table></figure><p>好的，我这边的安装已经完成了。</p><hr><h1 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h1><h2 id="安装官方应用"><a href="#安装官方应用" class="headerlink" title="安装官方应用"></a>安装官方应用</h2><h3 id="安装截图软件-Flameshot"><a href="#安装截图软件-Flameshot" class="headerlink" title="安装截图软件 Flameshot"></a>安装截图软件 Flameshot</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo pacman -S  Flameshot<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051234925.png" alt=" Flameshot效果"></p><p>  Flameshot 功能非常强大，可惜我的电脑一直运行不了。</p><p>  Flameshot 没有全局快捷键，可以去 设置 里设置快捷键。这些教程可以到网上查。</p><h3 id="安装多线程下载器"><a href="#安装多线程下载器" class="headerlink" title="安装多线程下载器"></a>安装多线程下载器</h3><p> axel 是优秀的多线程下载工具——命令行。如果你习惯使用命令行下载， axel 绝不能被错过；如果你不想使用命令行，那就下载 XDM ：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo pacman -S axel<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者</span><br>sudo pacman -S xdm<br></code></pre></div></td></tr></table></figure><p> axel 的使用：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">axel -n 15 address<br></code></pre></div></td></tr></table></figure><p>其中<code>-n</code>后面紧跟的是连接数，理论上连接数越多越好，但是不建议太高。<code>addrss</code>是下载地址。</p><p> XDM 的使用：</p><p> XDM 和 NDM 、 IDM 一样，都可以嵌入浏览器，然后自己嗅探下载的东西。</p><h3 id="安装邮件客户端雷鸟-Thunderbird"><a href="#安装邮件客户端雷鸟-Thunderbird" class="headerlink" title="安装邮件客户端雷鸟(Thunderbird)"></a>安装邮件客户端雷鸟(Thunderbird)</h3><p>如果使用邮件客户端，建议使用雷鸟，毕竟它还是很优秀的。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo pacman -S thunderbird<br></code></pre></div></td></tr></table></figure><p>安装完雷鸟之后，还可以在它的插件中安装 Markdown Here 插件，实现 Markdown 写邮件。</p><h3 id="安装virtualBox虚拟机"><a href="#安装virtualBox虚拟机" class="headerlink" title="安装virtualBox虚拟机"></a>安装virtualBox虚拟机</h3><p>首先查看你的内核版本：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">uname -r<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051257678.png" alt="内核版本"></p><p>然后选取和自己内核版本一样的虚拟机，我这里的内核是 15 ，所以选择<code>6</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051258261.png" alt="安装指定版本虚拟机"></p><h3 id="安装视频播放器VLC"><a href="#安装视频播放器VLC" class="headerlink" title="安装视频播放器VLC"></a>安装视频播放器VLC</h3><p> VLC 就像 Windows 下的 PotPlayer ，所以建议安装。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo pacman -S vlc<br></code></pre></div></td></tr></table></figure><h3 id="安装-Markdown-编辑器-选择性"><a href="#安装-Markdown-编辑器-选择性" class="headerlink" title="安装 Markdown 编辑器(选择性)"></a>安装 Markdown 编辑器(选择性)</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo pacman -S zettlr<br></code></pre></div></td></tr></table></figure><h3 id="安装vim-选择性"><a href="#安装vim-选择性" class="headerlink" title="安装vim(选择性)"></a>安装vim(选择性)</h3><p> Linux 下，谁人不知 VIM 编辑器？</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo pacman -S vim<br></code></pre></div></td></tr></table></figure><h3 id="安装中文输入法"><a href="#安装中文输入法" class="headerlink" title="安装中文输入法"></a>安装中文输入法</h3><p>输入以下命令后，直接回车，默认选中所有的输入设置。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo pacman -S fcitx5-im fcitx5-chinese-addons<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051336705.png" alt="安装中文输入法"></p><p>安装完毕，开始配置中文输入法。输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo vim /etc/environment<br></code></pre></div></td></tr></table></figure><p>回车，按住<kbd>Shift</kbd>+<kbd>g</kbd>跳到文件末尾。按下<kbd>o</kbd>在末尾添加以下配置</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">INPUT_METHOD=&quot;fcitx&quot;<br>GTK_IM_MODULE=&quot;fcitx&quot;<br>QT_IM_MODULE=&quot;fcitx&quot;<br>XMODIFIERS=&quot;@im=fcitx&quot;<br></code></pre></div></td></tr></table></figure><p>然后按<kbd>Esc</kbd>键，输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">:wq<br></code></pre></div></td></tr></table></figure><p>回车，保存退出VIM。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203162212673.png" alt="保存退出VIM"></p><p>输入<code>reboot</code>重启系统。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051318337.png" alt="重启"></p><p>重启之后，我们可以看到右上角多出一个输入法配置。点击它进行配置。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051339358.png" alt="输入法"></p><p>切换中文和英文输入法的快捷键是<kbd>Shift</kbd>或者<kbd>ctrl</kbd>+<kbd>space</kbd>。当然也可以改。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051340640.png" alt="尝试使用中文输入法"></p><h3 id="安装其他应用"><a href="#安装其他应用" class="headerlink" title="安装其他应用"></a>安装其他应用</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Steam</span><br>sudo pacman -S steam<br><span class="hljs-meta prompt_"># </span><span class="language-bash">peek GIF制作</span><br>sudo pacman -S peek<br></code></pre></div></td></tr></table></figure><h2 id="安装AUR应用"><a href="#安装AUR应用" class="headerlink" title="安装AUR应用"></a>安装AUR应用</h2><h3 id="安装yay"><a href="#安装yay" class="headerlink" title="安装yay"></a>安装yay</h3><p> yay 是  Manjaro 一个非官方的包管理器，使用方法和 pacman 一样，它们的区别是 pacman 是官方的产品。前面提到了，  Manjaro 拥有强大的社区支持。官方的软件虽然安全，但是毕竟能力有限。社区就发展出一个自己的软件源 AUR(Arch User Repository，Arch用户仓库) <sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://aur.archlinux.org/">[1]</span></a></sup>。 yay 就是从 AUR 安装软件的工具。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo pacman -S yay base-devel<br></code></pre></div></td></tr></table></figure><p>安装完 yay 之后，由于我们下载的软件可能会在 GitGub 上(例如后面的 WPS 的配件)，所以配置一下 GitGub 的 DNS ，毕竟国内上网不容易。</p><p>输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo vim /etc/hosts<br></code></pre></div></td></tr></table></figure><p>回车，按住<kbd>Shift</kbd>+<kbd>g</kbd>跳到文件末尾。按下<kbd>o</kbd>在末尾添加以下配置</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">140.82.114.4 github.com<br>199.232.69.194 github.global.ssl.fastly.net<br></code></pre></div></td></tr></table></figure><p>然后按<kbd>Esc</kbd>键，输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">:wq<br></code></pre></div></td></tr></table></figure><p>回车，保存退出VIM。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051354253.png" alt="设置DNS"></p><h3 id="安装QQ"><a href="#安装QQ" class="headerlink" title="安装QQ"></a>安装QQ</h3><p> QQ 原生的 Linux 版太古老，看起来像是上古时期的东西，所以我们安装国产系统 Deepin 基于 WINE 的 TIM ，安装的时候可以选择仓库或者直接回车：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">yay -S deepin-wine-qq<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者</span><br>yay -S deepin-wine-tim<br></code></pre></div></td></tr></table></figure><p>遇到对比，可以直接选择不显示( N ):</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051230824.png" alt="选择N"></p><p>下载完成之后启动并配置：</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051240756.png" alt="TIM安装"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051241358.png" alt="TIM登陆"></p><h3 id="安装微信"><a href="#安装微信" class="headerlink" title="安装微信"></a>安装微信</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">yay -S deepin-wine-wechat<br></code></pre></div></td></tr></table></figure><p>安装微信和 TIM 差不多。由于基于 WINE ，这些应用的体验和在 Windows 上没多大区别。</p><h3 id="安装WPS"><a href="#安装WPS" class="headerlink" title="安装WPS"></a>安装WPS</h3><p>办公软件我还是习惯 WPS 。 WPS for Linux 还没有广告。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">yay -S wps-office wps-office-mui-zh-cn ttf-wps-fonts<br></code></pre></div></td></tr></table></figure><h3 id="安装typora"><a href="#安装typora" class="headerlink" title="安装typora"></a>安装typora</h3><p>正常情况下，使用 yay 是没有办法安装 Typora 的。如果你安装成功了，那就跳过这步；否则，请继续往下阅读。</p><p>请确保你已经安装了 debtap 。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">debtap格式软件转换器</span><br>yay -S debtap<br></code></pre></div></td></tr></table></figure><p>下载 Typora <sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.123pan.com/s/gqA9-X7YB">[5]</span></a></sup>。</p><p>下载完成之后，我们使用<code>ls</code>查看当下目录的软件：</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051422846.png" alt="查看typora"></p><p>输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo debtap -u<br>sudo debtap -q *.deb<br></code></pre></div></td></tr></table></figure><p>这里我们使用匹配模式，使用<code>*</code>代替了<code>typora</code>。<code>-u</code>是更新 debtap ，<code>-q</code>是静默模式。如果不出意外，你的目录下会出现一个压缩包：</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051432479.png" alt="重建之后的压缩包"></p><p>输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo pacman -U *zst<br></code></pre></div></td></tr></table></figure><p>安装 typora 。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051434525.png" alt="安装完成"></p><h3 id="安装坚果云"><a href="#安装坚果云" class="headerlink" title="安装坚果云"></a>安装坚果云</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">yay -S nautilus-nutstore<br></code></pre></div></td></tr></table></figure><p>其中选择<code>nutstore-experimental</code></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051445504.png" alt="坚果云"></p><h3 id="安装其他软件"><a href="#安装其他软件" class="headerlink" title="安装其他软件"></a>安装其他软件</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">网易云音乐</span><br>yay -S netease-cloud-music<br><span class="hljs-meta prompt_"># </span><span class="language-bash">vscode 文本编辑器，编程使用，选择性</span><br>yay -S visual-studio-code-bin<br><span class="hljs-meta prompt_"># </span><span class="language-bash">谷歌浏览器，随意</span><br>yay -S google-chrome<br><span class="hljs-meta prompt_"># </span><span class="language-bash">zotero文献管理器</span><br>yay -S zotero<br><span class="hljs-meta prompt_"># </span><span class="language-bash">百度网盘 安装百度网盘之前先使用 sudo pacman -S patch</span><br>yay -S baidunetdisk-bin<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装picgo</span><br>yay -S picgo-appimage<br><span class="hljs-meta prompt_"># </span><span class="language-bash">腾讯会议，如果下载不了，建议按照Typora的方式，到官网下载deb格式之后转化安装</span><br>yay -S wemeet<br></code></pre></div></td></tr></table></figure><p>至此，我们所有的需要的软件都安装完了。</p><hr><h1 id="美化桌面"><a href="#美化桌面" class="headerlink" title="美化桌面"></a>美化桌面</h1><p>先看一下我的主题</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051526958.png" alt="亮色"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051525247.png" alt="暗色"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051526518.png" alt="图标"></p><p>首先，在自己家目录下创建文件夹<code>.themes</code>和<code>.icons</code></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">mkdir .themes<br>mkdir .icons<br></code></pre></div></td></tr></table></figure><p>安装主题有两种方法</p><p>方法一、自己下载</p><ol><li>首先下载 WhiteSur Gtk Theme <sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.gnome-look.org/p/1403328">[2]</span></a></sup>主题， McMojave-circle <sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.pling.com/s/Gnome/p/1305429">[3]</span></a></sup>图标， macOS Big Sur <sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://github.com/ful1e5/apple_cursor">[4]</span></a></sup>光标</li><li>把主题挪到<code>.themes</code>，图标和光标挪到<code>.icons</code></li></ol><p>方法二、使用我提供的压缩文件</p><ol><li><p>登陆 ftp </p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">ftp 101.200.84.36<br></code></pre></div></td></tr></table></figure></li><li><p>用户名是<code>ftp</code>，没有密码直接回车。然后下载我提供的压缩包：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">get themes.tar.gz<br>get icons.tar.gz<br></code></pre></div></td></tr></table></figure></li><li><p>解压缩</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">tar zxf themes.tar.gz -C ~/.themes<br>tar zxf icons.tar.gz -C ~/.icons<br></code></pre></div></td></tr></table></figure></li></ol><p>然后结束准备，开始安装。</p><p>查看自己的  Manjaro 是否有 gome-tweaks (图标显示为 tweaks 或者 优化 )，如果没有就下载：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo pacman -S gnome-tweaks<br></code></pre></div></td></tr></table></figure><p>打开软件，按下面配置：</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051614226.png" alt="tweaks配置"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203051615629.png" alt="tweaks配置"></p><p>如果使用 firefox 浏览器，安装 firefox 主题</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">cd ~/.themes/WhiteSur-gtk-theme/<br>./tweaks.sh -f<br></code></pre></div></td></tr></table></figure><p>完结！！</p><hr><h2 id="后语"><a href="#后语" class="headerlink" title="后语"></a>后语</h2><p>  Manjaro 作为我的主力系统已经有一段时间了，感觉并非得使用 Windows 。通过一些烈的美化之后，其实  Manjaro Gnome 还是很好看的。虽然与  Manjaro KDE 的高度定制性相比有点小巫见大巫，但是我喜欢的本来就是它的简洁。</p><p>使用这些软件也并非一帆风顺，例如我的电脑及使用不了  Flameshot ，可能因为分辨率太高导致字体怎么调都怪怪的等等，但是最终都克服了这些问题。我的电脑没有安装QQ或者微信，因为我感觉自己用不上它们。</p><p>腾讯会议不能使用 聊天 ，也看不到 弹幕 。</p><hr><h1 id="相关网站"><a href="#相关网站" class="headerlink" title="相关网站"></a>相关网站</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://aur.archlinux.org/">https://aur.archlinux.org/</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.gnome-look.org/p/1403328">https://www.gnome-look.org/p/1403328</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://www.pling.com/s/Gnome/p/1305429">https://www.pling.com/s/Gnome/p/1305429</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://github.com/ful1e5/apple_cursor">https://github.com/ful1e5/apple_cursor</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://www.123pan.com/s/gqA9-X7YB">https://www.123pan.com/s/gqA9-X7YB</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>应用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Manjaro + Windows11双系统安装</title>
    <link href="/2022/03/04/manjaro-windows11%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"/>
    <url>/2022/03/04/manjaro-windows11%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么要用Linux系统"><a href="#为什么要用Linux系统" class="headerlink" title="为什么要用Linux系统"></a>为什么要用Linux系统</h1><p>实际上，使用哪一个系统是没有理由的，个人电脑上基本没有能和  Windows 过招的系统。然而对我来说，  Windows 太麻烦了：8G 内存跑  Windows 还只是勉强流畅，特别是当我微信和QQ一起打开的时候，内存占用到我都怀疑人生了。我确实尝试过重装系统，但是对我来说怎么重装，最后还是会走到讨厌它的那一步。</p><p> Windows11 出来之后，  Windows 系统给我的印象就好了很多，特别是它的搜索功能，虽然它早就存在了，毕竟我不喜欢在桌面上放图标。使用它一阵子之后，我还是萌生了换系统的想法。可能这种想法一直存在脑海里，我才不喜欢  Windows 系统。</p><p>既然要换系统，那我得找到一个令我满意的系统。我把目光放到了 Linux ，毕竟 MacOS 可望不可及。然而问题是，开源而且免费的 Linux 系统还是有很多分支，多到一只手根本数不过来。此外，这些系统虽然都叫做 Linux ，但是彼此之间差别还是不小。</p><p>我最开始接触的 Linux 是 CentOS 。所以当时打算换到 CentOS8 ，虽然它似乎更合适做服务器。然而天有不测风云，谁知道 CentOS Linux 不再更新了。虽然 CentOS Stream 仍然被维护，但是我觉得 CentOS 已经等于被宣判了死刑，因此只能再找出路。</p><p>在虚拟机里安装了各种版本的 Linux 之后，我对 Manjaro Linux 和 Arch Linux 有非常大的好感。 Arch Linux 自由度非常高，可定制性强，官方 wiki 也很丰富，是探索 Linux 极好的选择。我花了好一阵子重温命令行安装 Linux 的知识，还给它安装了各种桌面。然而 Arch 总给我一种怪怪的感觉，可能对我来说，它吸引人的方面是拿来把玩，而不是作为主力系统。</p><p>但是我很喜欢 Arch ，于是各种搜罗有关 Arch 系统的信息，最后发现了 Manjaro 。 Manjaro 是 Arch 的衍生版，但是和 Arch 又有一定的区别。例如同样作为滚动发行的 Linux ， Manjaro官方包 相比而言比 Arch 更安全一点——因为它不是直接发布的，而是要经过一定的测试。 Manjaro 的另一特点是基本做到开箱即用，而 Arch 本身需要的配置很繁琐——这也是它吸引人的地方。</p><p> Manjaro 满足了我懒得折腾的心愿，同时作为 Arch 的衍生品，它与 Arch 共享很多的包。众所周知， Arch 拥有非常强大的社区支持。</p><p> Manjaro官网 <sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://manjaro.org/">[1]</span></a></sup>提供了三种版本的 Manjaro 桌面：</p><ol><li>XFCE ，轻量级桌面。</li><li>KDE ，重量级桌面，实际上现在和 GNOME 也差不多，可定制性高，桌面漂亮。</li><li>GNOME ，中量级桌面，简约高效。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042022699.gif" alt="Manjaro官网"></p><p>我选择了 GNOME ，因为它给我的感觉正像 Arch ，非常简单，没有多余的软件，没有负担。实际上 KDE 也为人称道，特别是它的高定制性，几乎可以定制所有的细节。然而我还是选择 GNOME ，我要的就是简单。既然要简单，自然选择<ruby>最小安装<rt>Minimal</rt></ruby>， LTS 是长期支持版，我没有选择。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042028792.png" alt="最小安装"></p><hr><h1 id="制作启动盘"><a href="#制作启动盘" class="headerlink" title="制作启动盘"></a>制作启动盘</h1><p>下载 Manjaro 镜像之后，我们需要制作启动盘，这里推荐使用国人的 Ventoy <sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.ventoy.net">[2]</span></a></sup>。这个小工具看起来小，但是可以引导多个系统。只需要把镜像放到它制作的启动盘里就可以引导多个系统。这有什么好处？通常情况下，我们制作启动盘的方式是格式化U盘，然后使用启动盘制作软件制作启动盘(格式化是必须的，有时是自己手动，有时是启动盘软件格式化)。这样，一个U盘无论多大，一次只能引导一个系统，要引导新系统时都需要格式化。一来麻烦，二来对U盘的使用寿命也不好。当然，最重要的是， Ventoy 引导多个系统的能力听起来就很厉害。</p><p>有一个教训是我直接给自己的电脑装了 Manjaro 之后，由于某些需要想要装回  Windows ，此时所有的启动盘制作软件制作的启动盘都没有用。制作启动盘之前必须格式化U盘，所以当我把系统搞坏之后连原本的 Linux 系统也装不了。最后只能手动制作启动盘，纯手工给U盘分区，因为我要安装的系统超过了 fat32 文件系统的最大上限。</p><p>因此使用 Ventoy 是一项保险的举措，至少等你后悔的时候，它不会让你失望。</p><h2 id="下载Ventoy"><a href="#下载Ventoy" class="headerlink" title="下载Ventoy"></a>下载Ventoy</h2><p>我们可以到官网下载 Ventoy 。如果不想安装，可以下载 便携版 ，开箱即用。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042039980.png" alt="Ventoy官网"></p><h2 id="开始制作"><a href="#开始制作" class="headerlink" title="开始制作"></a>开始制作</h2><p>制作启动盘很简单，打开 Ventoy ，然后选择U盘即可。通常情况下， Ventoy 会自动识别你的U盘。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042050020.png" alt="启动Ventoy"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042051376.png" alt="制作启动盘"></p><p>安装完之后，把你的 ISO 镜像复制到 U盘。你会发现 U盘 仍旧是空的，实际上只是你看不见其他文件而已。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042057885.png" alt="复制ISO镜像"></p><hr><h1 id="电脑分区"><a href="#电脑分区" class="headerlink" title="电脑分区"></a>电脑分区</h1><p>对我来说， Linux 够用了，但是谁也不知道可能又需要  Windows 专有的软件。既然要安装双系统，而且是 Linux 作为主系统，那只需要给  Windows 保留一小部分的空间。</p><p>  Windows 分区比较简单，系统就自带了。我们只需要搜索“分区”就会弹出需要的软件，选择就好了。搜索使用 <kbd> Windows</kbd>+ <kbd>s</kbd>。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042058958.png" alt="搜索分区软件"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042059442.png" alt="查看硬盘"></p><p>分区的时候，固态硬盘(C盘)分出一部分，待会安装 Manjaro ；机械硬盘也要分，主要作为存储区。我是在已经安装完毕的电脑演示的，所以可以看到，实际上我的电脑已经分成了很多的区。</p><p>要分区，先压缩一定的空间，通常是你想要分配多少就要所多少。记住， 1G&#x3D;1024M 。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042102453.png" alt="演示分机械硬盘"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042104626.png" alt="压缩"></p><p>压缩完之后新建 卷 。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042104738.png" alt="压缩完之后"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042106771.png" alt="继续选择"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042106229.png" alt="分配驱动号"></p><p>新建卷标，最好是有意义的卷标。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042107720.png" alt="设置卷标，建议设成有意义的卷标"></p><p>分区完成。按照这个方式给固态硬盘分区。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042108967.png" alt="分区完成"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042109229.png" alt="成果"></p><p>至此，我们已经分区完成了。注意，后面我们要做的就是把 Linux 安装到我们分出來的 新盘 。</p><hr><h1 id="进入BIOS或者UEFI引导界面"><a href="#进入BIOS或者UEFI引导界面" class="headerlink" title="进入BIOS或者UEFI引导界面"></a>进入BIOS或者UEFI引导界面</h1><p> BIOS 和 UEFI 是系统安装的引导界面，也就是我们给老电脑开机的时候，看到的黑乎乎的界面。每个厂商的引导界面的快捷键都不一样，最常见的是 <kbd>F2</kbd> 和 <kbd>F12</kbd>。例如我的是华硕电脑，使用 <kbd>F2</kbd>。通常这些东西都是可以在网上查到的。</p><p>那什么时候按呢？简单，就是重启电脑的，等到刚刚出现厂商标志的时候，以迅雷不及掩耳之势按住你电脑的按键。当然，最傻的方式是电脑重启黑屏之后就一直按你的快捷键。</p><p>进入 BIOS 或者 UEFI 之后，先去高级模式( Advance Mode )把 Boot 的 Security 改成 disable(关闭) 。然后选择 Boot Mode 中的U盘启动。当然，如果你的界面和我的一样，你也可以选择调整右手边的 Boot Priority ，把U盘调到最前面。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042120262.jpg" alt="选择BootMode"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042125263.jpg" alt="选择U盘启动"></p><p>选择想要安装的系统。我这里有两个系统，一个 Arch ,一个 Manjaro ，选择 Manjaro ，回车。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042126910.jpg" alt="Ventoy引导界面"></p><p>这里可以进行简单的配置。然后选择 open source drivers 。 open source 是开源，通常等于使用 Intel 显卡； proprietary drivers 就是闭源，自然就是 Nvidia 了。我的电脑是双显卡，所以使用哪一个都差不多。不过说实话，我使用闭源的 Nvidia 的时候出现了比较大的问题：开机容易卡在黑黢黢的界面。修改之后直接回车。实际上也不用修改，后面还是可改的。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042132829.png" alt="这里简单配置一下"></p><p>如果你的电脑出现一堆的文字，那是正常现象，不用担心。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042137953.png" alt="启动"></p><p>等到进入这个界面就说明没问题了。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042139339.png" alt="Live 界面"></p><p>这里可以体验一下 Manjaro ，因为所做的修改都不会保留下来。</p><hr><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>记得连接网络，点击 右上角 ，连接网络。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042141928.png" alt="记得连接WIFI"></p><p>连接网络之后开始安装，点击 右下角 的安装软件——最右下角，开始安装。</p><p>选择语言等基本配置。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042145530.png" alt="开始安装"></p><p>一直回车到分区界面，选择 手动分区 (manual partitioning)。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042146756.jpg" alt="选择手动分区"></p><p>选择磁盘，找到我们之前的分区，通过 标签 (卷标)可以查看我们的分区——所以分区的时候一定要给一个有意义的卷标。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042150337.jpg" alt="(选择我们的分区)"></p><p>点击我们分出的区域——注意，一定要选择我们的分区，例如我的分区 Linux ，然后选择 创建(Create) ，给大小 300M 就可以了， 文件系统 (file system)是 fat32 ，挂载点是<code>/boot/efi</code>，给一个卷标，标识为<code>boot</code>，选择<code>OK</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042157081.png" alt="分区"></p><p>选择 空闲空间 (free space)，继续新建。这里有两种情况：</p><h2 id="你有两块硬盘，一块固态硬盘，一块机械硬盘，并且分别分出了两个分区给Linux"><a href="#你有两块硬盘，一块固态硬盘，一块机械硬盘，并且分别分出了两个分区给Linux" class="headerlink" title="你有两块硬盘，一块固态硬盘，一块机械硬盘，并且分别分出了两个分区给Linux"></a>你有两块硬盘，一块固态硬盘，一块机械硬盘，并且分别分出了两个分区给Linux</h2><p>分区布局：</p><ol><li>EFI 分区，固态硬盘，300M足矣。</li><li>&#x2F;分区(root)，固态硬盘，剩余的空间。</li><li>swap 分区，机械硬盘，和自己的内存一样大。</li><li>&#x2F;home 分区，机械硬盘剩下的三分之二以上。</li><li>&#x2F;opt 分区，机械硬盘最多三分之一。</li></ol><p>固态硬盘剩余的所有空间新建一个分区，作为 根 (root)挂载点，文件系统是<code>ext4</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042203158.png" alt="根分区"></p><p>然后点击顶部的存储器，选择机械硬盘。同理选择自己分出來的那一部分——说过了，看自己的卷标识别，千万不要在固态硬盘和机械硬盘上使用 Windows系统的分区，不然没人救得了你。</p><p>分出一部分的空间，新建一个 swap 分区， swap 大小是你的内存大小。我的是 8G 内存，所以选择 8G 。文件系统选择<code>linuxswap</code>，标记<code>swap</code>，卷标自定义，最好有意义。不用选择挂载点。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042211258.png" alt="swap分区"></p><p>最后，把你机械硬盘的剩余空间分成两部分——四六或者三七分，少的部分作为<code>/opt</code>挂载点，文件系统选择<code>ext4</code>，没有标记：</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042215243.png" alt="opt分区"></p><p>最后剩余的空间放到<code>/home</code>分区，文件系统还是<code>ext4</code>，无标签，卷标可以给个名字</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042217101.png" alt="home分区"></p><p>至此，你的分区差不多了。最后你的分区看起来像这样(注意，原本还有 windrows 系统的分区，这里演示不了。下面是固态硬盘分区和机械硬盘的分区)：</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042220498.png" alt="固态分区"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042222826.png" alt="机械硬盘分区"></p><h2 id="你只有一块分区"><a href="#你只有一块分区" class="headerlink" title="你只有一块分区"></a>你只有一块分区</h2><p>参照两块硬盘的分区，只不过不用分出<code>/opt</code> 和<code>/home</code>分区而已。</p><p>分区布局：</p><ol><li>EFI 分区，同上。</li><li>swap 分区，同上。</li><li>&#x2F;分区(root)，剩余的所有空间。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042229457.png" alt="分区如下"></p><p>分区一直是一个见仁见智的话题，如果你有自己的想法，可以不参照我的方案。</p><hr><h1 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h1><p>最后填写一些信息，然后就安装，重启。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042226386.png" alt="配置"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203042227959.png" alt="安装"></p><p>至此， Manjaro 安装完毕。</p><hr><h1 id="后语"><a href="#后语" class="headerlink" title="后语"></a>后语</h1><p>安装完毕之后，我们还需要安装一些常用的软件、使用中文拼音等，但是一篇写不完，所以后面我会再详细介绍怎么安装常用软件以及美化自己的系统。</p><hr><h1 id="相关网址"><a href="#相关网址" class="headerlink" title="相关网址"></a>相关网址</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://manjaro.org/">https://manjaro.org/</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.ventoy.net/">https://www.ventoy.net</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里云服务器搭建 FTP 服务</title>
    <link href="/2022/03/04/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAftp%E6%9C%8D%E5%8A%A1/"/>
    <url>/2022/03/04/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAftp%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="FTP协议"><a href="#FTP协议" class="headerlink" title="FTP协议"></a>FTP协议</h1><p>FTP 协议，全称 文件传输协议(File Transfer Protocol) ，是简单、高速的网络文件传输协议，支持 TCP&#x2F;IP 。早期的网络共享通常都是使用这个协议，现在也仍然有。当然，在其他的系统上有更好的选择，例如 samba 等，但是在实操方面我只接触过 FTP 。</p><p> FTP 可以搭建家庭内部的文件共享(局域网)和互联网文件共享(公网)。因为自己有了一台云服务器，所以打算在部署自己的 FTP 服务器。如果有想法，可以以后搭建一个家庭的 FTP 它不香吗？</p><hr><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>在开始之前，我们先准备需要的东西：</p><ol><li>一台云服务器。</li><li>SSH 客户端。</li><li>FTP 服务端，我使用 vsFTPd ； FTP 客户端，我选择 FTP 。</li></ol><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><p>我用的是阿里云 ECS共享型4n ， Rocky Linux<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://rockylinux.org">[1]</span></a></sup> 系统，兼容 CentOS7&#x2F;8 和 RHEL 。由于 CentOS6 我没用过，所以不知道区别如何。配置什么的不重要。</p><p>如果不使用云服务器而是使用虚拟机的话，那就什么都不重要了。</p><h3 id="SSH-客户端"><a href="#SSH-客户端" class="headerlink" title="SSH 客户端"></a>SSH 客户端</h3><p>使用 SSH 是为了连接服务器，当然，也可以使用服务器官方提供的 VPC 。如果没有这些概念，那就使用 SSH 。<br>对于虚拟机用户，我还是建议使用 SSH ，因为 VMware 和 Virtual Box 的剪贴板共享功能不大好使，特别是不同操作系统之间互通。</p><hr><h1 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h1><h2 id="配置安全组规则"><a href="#配置安全组规则" class="headerlink" title="配置安全组规则"></a>配置安全组规则</h2><p>在获得自己的服务器之后，到阿里云帐号的 控制台-&gt;云服务器ECS-&gt;实例-&gt;管理-&gt;安装组 。如果之前配置过自己的安全组，就在安全组的 配置规则 中选择 快速添加 ，然后设置选择全部， 添加 。这一步很重要，因为我之前在修改 SSH 端口和配置 FTP 时忘了这一步，导致一直在和防火墙进行斗争，最后发现是这里的端口没开放。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203040956159.png" alt="添加规则"></p><h2 id="SSH连接"><a href="#SSH连接" class="headerlink" title="SSH连接"></a>SSH连接</h2><p>默认情况下，服务器的 SSH 服务端( SSHd )是开放的，如果想查看是否开放，可以使用<code>sudo systemctl status sshd</code>查看。老版本使用 init.d 我不熟悉，所以使用 systemctl 。如果你使用的是 CentOS6 ，那只能网上查资料了。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo systemctl status sshd<br></code></pre></div></td></tr></table></figure><p>如果打开了，就会出现 active 的提示：</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203041006651.png" alt="sshd服务端已打开"></p><p>如果是 inactive ，那就打开 SSHd ，先使用<code>sudo systemctl enable sshd</code>设置开机自启动，然后再<code>start</code>：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">enable</span>设置自启动，start启动</span><br>sudo systemctl enable sshd <br>sudo systemctl start sshd<br></code></pre></div></td></tr></table></figure><p>客户端连接使用<code>ssh username@ip -p portnumber</code>。其中，如果你修改了 SSH 端口，就加上<code>-p 端口</code>，正常情况下可以省略这个参数。<code>username</code>是你的服务器用户名，不建议使用 root 登陆，<code> ip</code>是你的服务器 公网IP ，注意不是 局域网IP ，通过<code>ifconfig</code>和<code>ip addr</code>查到的是 局域网IP ， 公网IP 可以在阿里云控制台查找，通常服务器开通之后也会有手机短信告知你的服务器地址。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">ssh chunshuyumao@192.168.0.10 -p 1234<br></code></pre></div></td></tr></table></figure><p>连接上之后，输入密码就行了。如果想使用无密码登陆，可以在客户端使用<code>ssh-keygen</code>生成公私钥。<code>-t</code>是加密的类型，<code>-C</code>是注释，也可以不使用<code>-C</code>和之后的参数。回车三下，然后到自己的的家目录下就找到<code>.ssh</code>文件夹，里面有生成的公私钥。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203041022580.png" alt="生成公私钥"></p><p>然后通过<code>ssh-copy-id username@ip</code>传输自己的公钥，不断确定即可。如果有多个公钥，可以使用参数<code>-i file.pub</code>指定使用哪一个。这里不过多描述。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">ssh-copy-id -i ~/.ssh/id_rsa.pub chunshuyumao@192.168.0.10<br></code></pre></div></td></tr></table></figure><p>登陆成功的提示。如果觉得记住自己的 公网IP 困难，可以写一个脚本自动登陆。例如我下边就是写了一个叫做<code>swc</code>(switch)的函数，快速切换服务器——如果你使用的是其他 SSH客户端 ，那算我没说。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203041031461.png" alt="登陆成功"></p><hr><h2 id="开始配置-FTP"><a href="#开始配置-FTP" class="headerlink" title="开始配置 FTP"></a>开始配置 FTP</h2><p>我们花了太多时间在 SSH 的连接上了。</p><h2 id="下载-FTP-客户端和服务端"><a href="#下载-FTP-客户端和服务端" class="headerlink" title="下载 FTP 客户端和服务端"></a>下载 FTP 客户端和服务端</h2><p>服务端和客户端我使用的是<code>vsftpd</code>、<code>ftp</code>，在服务器中可以两个都下载，用于调试：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo yum install -y vsftpd ftp<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203041043259.png" alt="安装FTP客户端和服务端"></p><p>当然，你也可以只在自己的电脑下载<code>ftp</code>，服务器只下载<code>vsftpd</code>。其他系统下载可以网上查教程，或者先用自己的系统查找。例如我的 Manjaro系统 ，但是它没有<code>ftp</code>这个单独的软件包，而是自带了。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">pacman -Ss vftpd<br>pacman -Ss ftp<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203041040266.png" alt="查找ftp服务端和客户端软件包示例"></p><h2 id="配置服务端"><a href="#配置服务端" class="headerlink" title="配置服务端"></a>配置服务端</h2><p>输入<code>sudo vim /etc/vsftpd/vsftpd.conf</code>，编辑配置，可以参考官网的介绍<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="http://vsftpd.beasts.org/vsftpd_conf.html">[2]</span></a></sup>。当然，<code>vim</code>可以修改成你喜欢的任何编辑器——重点是你的服务器得下载了，例如<code>nano</code>。一定要用<code>sudo</code>不然你无法修改配置。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo vim /etc/vsftpd/vsftpd.conf<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203041045484.png" alt="编辑配置"></p><p>修改<code>anonymous_enable=YES</code>,这个配置是允许匿名登陆，匿名登陆表示任何人只要知道你的服务器 公网IP 就可以登陆，默认的文件夹保存在<code>/var/ftp</code>中。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203041048745.png" alt="image-20220304104811696"></p><h2 id="开启FTP服务"><a href="#开启FTP服务" class="headerlink" title="开启FTP服务"></a>开启FTP服务</h2><p>首先，查看你的防火墙是否打开。<code>firewalld</code>通常是 RedHat 高版本系统( CentOS7&#x2F;8、RockyLinux )的默认防火墙，<code>iptables</code>是 Debian 系列( Ubuntu 等)默认的防火墙。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo systemctl status firewalld<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者</span><br>sudo systemctl status iptables<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203041051462.png" alt="防火墙"></p><p>如果是开启( active )的，解决办法有两个： 关闭 和 开放指定端口和服务 。</p><ol><li><p>关闭防火墙。输入命令<code>sudo systemctl stop firewalld</code>。关闭自启输入命令<code>sudo systemctl disable firewalld</code>。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo systemctl stop firewalld<br></code></pre></div></td></tr></table></figure></li><li><p>开放指定服务和端口。输入<code>sudo firewall-cmd --add-port=21/tcp --permanent </code>和<code>sudo firewall-cmd --add-service=ftp --permanent</code>。如果想让服务器保持开放这个端口，可以加<code>--permanent</code>，否则不用加。然后重新启动防火墙。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo firewall-cmd --add-port=21/tcp --permanent<br>sudo firewall-cmd --add-service=ftp --permanent<br>sudo firewall-cmd --reload<br></code></pre></div></td></tr></table></figure><p>查看防火墙规则:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo firewall-cmd --list-all<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203041104495.png" alt="规则"></p></li></ol><p>开启 vsFTPd 服务和自启动:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo systemctl enable vsftpd<br>sudo systemctl start vsftpd<br></code></pre></div></td></tr></table></figure><p>检查 vsftpd 服务是否打开：</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203041110173.png" alt="检查是否打开"></p><h2 id="客户端连接"><a href="#客户端连接" class="headerlink" title="客户端连接"></a>客户端连接</h2><p>在服务器登陆 FTP 服务，由于是服务器登陆，所以可以使用<code>localhost</code>作为 IP 。登陆 匿名用户 ，帐号是<code>ftp</code>，密码直接回车。然后就可以使用 FTP 服务了。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">ftp localhost<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203041114988.png" alt="服务器客户端登陆"></p><p>本地客户端登陆，使用<code>ftp 公网IP</code>,一样进行登陆。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">ftp 101.200.84.36<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203041117349.png" alt="本地客户端登陆"></p><p>至此， FTP 服务搭建完成。下载一个文件试试:</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202203041120475.png" alt="下载文件"></p><p>看到，由于我们使用的是 FTP主动模式 ，所以从服务器下载的时候，服务器也建议使用 被动模式 。不过目前的 主动 和 被动 对我而言没有区别，所以没有开启被动模式。如果不希望别人登陆自己的 FTP ，可以在配置文件中( &#x2F;etc&#x2F;vsftpd&#x2F;vsftpd.conf )把<code>anonymous_enable</code>改成<code>NO</code>。</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本来搭建 FTP 是很简单的，但是自己的安全组规则没配好，导致一直有问题。我不是很清楚安全组规则和防火墙的区别——所以也许在一些人的操作中，不用控制防火墙也能够使用 FTP 。懒了，所以不想去探究，也许有时间的话我会试试，不过不是现在。</p><p>配置 SSH 端口的时候也出现了无法使用指定端口的问题。网上查了一堆博客，发现大家基本是在调试 SELinux 和 防火墙 。一个也解决不了问题，最后还是通过阿里云控制台修改了安全组规则，所以这个也很迷。我的服务器 SELinux 默认是关闭的，实际上开启的话，配置 SSH 端口更麻烦，但是自然也更安全。</p><hr><p>##相关网址</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://rockylinux.org/">https://rockylinux.org</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="http://vsftpd.beasts.org/vsftpd_conf.html">http://vsftpd.beasts.org/vsftpd_conf.html</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建博客</title>
    <link href="/2022/01/03/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2022/01/03/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>开始阅读之前我希望你已经看过我写的前两篇文章，因为它们具有一定的连贯性。</p><p><a href="https://chunshuyumao.github.io/2022/01/03/Markdown%E4%B8%8ETypora/">Markdown与Typora</a></p><p><a href="https://chunshuyumao.github.io/2022/01/03/Typora-picgo%E5%86%99%E4%BD%9C%E5%B9%B3%E5%8F%B0%E7%9A%84%E6%90%AD%E5%BB%BA/">Typora+picgo写作平台的搭建  </a></p></blockquote><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>搭建个人博客是一件细活，得有自己的服务器、域名，甚至一点前端基础，因此很多搭建个人博客的都是程序员。然而今天我要做的就是借助 Hexo<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://hexo.io/">[1]</span></a></sup> 和 GitHub<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://GitHub.com/">[2]</span></a></sup> 搭建免费的个人博客。下面是我们用到的工具：</p><ul><li>Git<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://Git-scm.com/">[3]</span></a></sup></li><li>GitHub 账号</li><li>文本编辑器(最好是 Markdown 编辑器，例如 Typora)</li><li>Fluid<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://hexo.fluid-dev.com/">[4]</span></a></sup> 主题</li><li>PicGo</li><li>一台电脑</li></ul><p>先展示自己的博客封面和文章内部。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/image-20220103223925111.png" alt="我的博客封面(白昼模式), 主题改自fluid" title="我的博客封面(白昼模式), 主题改自fluid"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201041457314.png" alt="文章内容(暗夜模式)"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201041541080.jpg" alt="手机展示"></p><hr><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>在真正搭建自己的博客之前，我们需要 GitHub 账号和 Git。</p><blockquote><p>Git 是著名的分布式版本管理器。简而言之，Git 可以为自己写的文本(文章、代码等)管理历史版本。Git 可以对文本文件进行版本控制，使用 Markdown 可以配合Git进行管理。</p><p>GitHub 是世界上最大的开源代码管理平台，通过 Git 进行版本控制，只需要一个邮箱即可申请注册。GitHub 通过一个个仓库(repository)管理代码，免费用户的总仓库空间是 500M。这个空间看起来太小了，但是对于写博客和代码来说够了——大不了再审请一个。虽然国内也有码云(Gitee)平台，并且提供 2G 空间，但是用来搭建的 Pages 需要实名认证。</p></blockquote><p>国内访问 GitHub 时常出现连不上或者访问速度慢，所以要有耐心。</p><h2 id="GitHub账号及仓库准备"><a href="#GitHub账号及仓库准备" class="headerlink" title="GitHub账号及仓库准备"></a>GitHub账号及仓库准备</h2><p>通过后面提供的链接进入GitHub<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://GitHub.com/">[2]</span></a></sup>申请一个新的账号。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051555670.png" alt="注册"></p><p>像 Gitee 一样新建一个仓库，仓库名字一定是<code>&#123;你的id&#125;.github.io</code>。</p><blockquote><p>注意：</p><p>如果你的 id 是 <code>wangxiaoming</code>，那仓库名字必须是 <code>wangxiaoming.github.io</code>，这样就可以通过 <code>wangxiaoming.GitHub.io</code> 访问你的博客了。如果你选择了中文名，那就注意了，你需要在浏览器的地址栏中找出你的名字的英文名是啥，所以推荐直接使用拉丁字母。</p><p>关于Gitee建立仓库，可以查看另一篇文章 <a href="https://chunshuyumao.github.io/2022/01/03/Typora-picgo%E5%86%99%E4%BD%9C%E5%B9%B3%E5%8F%B0%E7%9A%84%E6%90%AD%E5%BB%BA/">Typora+picgo写作平台的搭建</a></p></blockquote><p>Public 是公开你的仓库，实际上就是公开自己的博客。添加一个 readme 文件为的是简单——它会自己帮你建立一个 <code>main</code> 分支。这个分支 <code>main</code> 以前叫作 <code>master</code>，但是现在 <code>master</code> 成了<code>亚美利加</code>政治不正确的代名词，所以——你懂的。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051623158.png" alt="建立pages"></p><p>接下来选择 <code>settings-&gt;Pages</code>，查看是否建立了自己的网站。你甚至可以打开看看：</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051634474.png" alt="查看是否建立成功" title="查看是否建立成功"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051635946.png" alt="打开后自己的网站，这里显示的是readme.md中的文字" title="打开后自己的网站，这里显示的是readme.md中的文字"></p><p>接下来是准备 Git<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://Git-scm.com/">[3]</span></a></sup> 和 hexo<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://hexo.io/">[1]</span></a></sup>。</p><h2 id="Git准备"><a href="#Git准备" class="headerlink" title="Git准备"></a>Git准备</h2><p>首先去 Git<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://Git-scm.com/">[3]</span></a></sup> 官网下载：</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051643214.gif" alt="Git下载"></p><p>下载完成之后就可以安装了。安装的时候，一键确定到头即可。</p><p>连接 Git 和 GitHub</p><p>任意位置鼠标右键，打开<code>git bash</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051720620.gif" alt="打开Git bash"></p><p>分别键入</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;你的GitHub ID&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;你的GitHub注册邮箱&quot;</span><br>ssh-keygen -t rsa<br></code></pre></div></td></tr></table></figure><p>最后一段代码 <code>ssh-keygen -t rsa</code> 用于生成公<ruby>钥<rt>yuè</rt></ruby>和私<ruby>钥<rt>yuè</rt></ruby>。公钥和私钥使用 <code>rsa</code> 方式生成。这是一种保密方式——公钥你可以公开，但是拿不到你的私钥是没法破译你的信息的。</p><p>配置公、私钥的时候，连续回车 <kbd>Enter</kbd> 三下，记住保存路径</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051911093.png" alt="配置信息和生成公钥和私钥"></p><p>打开保存路径，复制公钥文件内容：</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051907768.png" alt="打开路径，复制公钥"></p><p>打开浏览器进入 GitHub ，登陆自己的账号，点击头像进入 <code>settings-&gt;ssh and GPG keys</code>。选择 <code>New SSH</code></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051938150.png" alt="ssh and GPG keys"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051940072.png" alt="配置公钥"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051940453.png" alt="输入密码确认"></p><p>至此，Git 准备完成。休息一下就可以开启下一章了。</p><h2 id="配置-Hexo"><a href="#配置-Hexo" class="headerlink" title="配置 Hexo"></a>配置 Hexo</h2><p>在自己的文件管理器里准备一个文件夹，放置自己的博客文件。我建立一个 Notes 文件夹，准备在里边放置自己的文件。</p><p>进入该文件夹，鼠标右键，打开 <code>git bash</code>。注意，此时默认你已经安装过 PicGo，并且安装了 <code>node.js</code>。如果没有，请先按照 <a href="https://chunshuyumao.github.io/2022/01/03/Typora-picgo%E5%86%99%E4%BD%9C%E5%B9%B3%E5%8F%B0%E7%9A%84%E6%90%AD%E5%BB%BA/">Typora+picgo写作平台的搭建</a> 安装好 Typora 和 PicGo ——或者简单安装 Node.js也可以。Node.js 安装包也在后面给出了。</p><p>安装<code>hexo-cli</code>，键入</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npm install hexo-cli -g<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051757071.png" alt="安装hexo-cli"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051758857.png" alt="安装成功"></p><p>初始化这个文件夹，键入</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">hexo init<br></code></pre></div></td></tr></table></figure><blockquote><p>如果你的文件在C盘(系统盘), 建议挪到非系统盘,</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051759674.png" alt="初始化"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051801892.png" alt="等待安装"></p><p>安装完毕。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051809431.png" alt="完毕"></p><p>可以看到，安装完成之后，Notes 里边出现了很多文件夹。后面我再解释这些文件夹是什么。</p><p>键入<code>hexo generate</code>或者<code>hexo g</code>，产生<code>public</code>文件夹，这就是你博客公布的文件夹。<code>generate</code>是<code>生成</code>。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">hexo generate<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051811903.png" alt="image-20220105181126819"></p><p>键入<code>hexo server</code>或者<code>hexo s</code>，打开服务器，然后点击按住<kbd>ctrl</kbd>+<kbd>鼠标右键</kbd>点击给出的网址<code>https://localhost:4000</code>，或者直接在浏览器中输入也行：</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051838511.png" alt="打开服务器"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051840878.png" alt="浏览博客"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051841974.png" alt="你的博客"></p><p>本节终。</p><hr><h2 id="部署博客到GitHub-Page"><a href="#部署博客到GitHub-Page" class="headerlink" title="部署博客到GitHub Page"></a>部署博客到GitHub Page</h2><p>如上，我们已经在本地配置好自己的博客。然而，我们的博客只能在自己的电脑查看，现在要做的是让它在任何网络下都可以查看。</p><p>用文本编辑器(记事本、Sublime Text、Notepad++、VS Code 等)打开你的本地文件根目录的<code>_config.yml</code>配置文件。修改配置，英文都看得懂，主要看<code>url</code>一栏，填入你的 GitHub Pages 地址，就是<code>https://&#123;你的ID&#125;.github.io</code>。</p><blockquote><p>_config.yml 称为“博客配置文件”</p><p>_config.landscape.yml 称为“博客主题配置文件”，简称“主题配置文件”</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051918393.png" alt="本地文件根目录"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051932467.png" alt="修改配置"></p><p>复制要部署的位置，一般为<code>https://github.com/&#123;你的id&#125;/&#123;你的id&#125;.github.io.git</code>，从仓库主页的 <code>code</code> 中选 <code>http</code> 或者 <code>ssh</code> 复制粘贴到博客配置文件最后一行，保存退出。</p><blockquote><p>注意：2022 年之后，repo 选项只能填写 SSH 的内容，也就是 <a href="mailto:&#103;&#x69;&#x74;&#x40;&#x67;&#105;&#x74;&#x68;&#117;&#98;&#x2e;&#99;&#111;&#x6d;">&#103;&#x69;&#x74;&#x40;&#x67;&#105;&#x74;&#x68;&#117;&#98;&#x2e;&#99;&#111;&#x6d;</a>:{你的id}&#x2F;{你的id}.github.io.git</p><p>否则无法进行部署。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201082037858.png" alt="复制要部署的地址"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051957072.png" alt="粘贴"></p><p>如果刚刚的<code>git bash</code>没关，那键入<code>clear</code>清屏。如果关了，那就重新在你的本地文件根目录打开，键入<code>npm install hexo-deployer-git --save</code>，安装部署软件：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npm install hexo-deployer-Git --save<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201052007899.png" alt="安装部署"></p><p>键入<code>hexo deploy</code>或者<code>hexo d</code>进行部署。接下去控制台会打印很多文件，不用在意。由于 GitHub 访问速度很慢，部署的时候可能会失败，不要放弃——多试几遍就行。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">hexo deploy<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201052008492.png" alt="部署"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201052012619.png" alt="失败了再试"></p><p>如果对一次次地失败感到不耐烦的话，可以使用 Gitee 作为 Pages 部署，但是 Gitee 需要实名认证，三思。</p><p>坐等部署的时候，先去要一个私人令牌，待会有用。<code>主页头像-&gt;settings-&gt;development settings</code></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201052029387.png" alt="获取私人令牌"></p><p>生成一个 Token，一样这东西复制一遍之后就会消失，所以最好记下，不然就得重新申请了。<code>expiration</code>可以选择过期时间。建议如果不保存 Token 的话设置时间短一点。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201052034012.png" alt="选填"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201052035981.png" alt="生成"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201052036129.png" alt="复制token保存"></p><p>ok，部署弹出登录框了。我们选择 Token 登录，因为其他方式加载实在太慢了，直接使用 Token 它不香吗？要细心，因为我刚刚就写错了自己的网址，多了一个<code>a</code>，谁知道在哪张图出现的？</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201052038375.png" alt="选择token登录"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201052055903.png" alt="成功！！"></p><p>部署成功，手机查看试试：</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201052100233.jpg" alt="手机展示"></p><p>至此，我们的博客已经做完了！！</p><hr><h2 id="优化主题"><a href="#优化主题" class="headerlink" title="优化主题"></a>优化主题</h2><p>Hexo 也有自己的主题网站，大家可以去逛。不过我这里就推荐我使用的fluid主题就行。照常，本地文件夹根目录打开<code>git bash</code>，键入</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npm install hexo-theme-fluid --save<br></code></pre></div></td></tr></table></figure><p>下载主题。下载完成之后，去<code>node_modules</code>中复制一份到<code>themes</code>文件夹，重命名为<code>fluid</code>。把 Fuild 主题配置文件(_config.yml)复制一份，重命名为<code>_config.fluid.yml</code>，移动到本地文件根目录。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201052050860.png" alt="下载重命名移动"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201052054624.png" alt="重命名"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201052059610.png" alt="复制" title="复制"></p><p>打开本地文件根目录下的博客配置文件，修改主题为我们下载的 Fluid。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201052105142.png" alt="修改主题"></p><p>重新部署</p><p>由于我们修改了主题，所以打开<code>git bash</code>，分别键入<code>hexo clean; hexo d -g</code>(这是缩写，下面是一次写一个命令)。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">hexo clean<br>hexo generate<br>hexo deploy<br></code></pre></div></td></tr></table></figure><p>部署成功之后，浏览器查看自己的主题是否成功应用。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201052113427.png" alt="重新部署"></p><p>Fluid<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://hexo.fluid-dev.com/">[4]</span></a></sup> 主题的文档非常丰富，大家想要让自己的主题更个性化可以查阅文档。</p><hr><h2 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h2><p>接下来就是写博客了。使用 Markdown 写博客，因此我们先生成一个 MD 文件。在本地文件根目录打开<code>git bash</code>，键入</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">hexo new post 文章名字<br></code></pre></div></td></tr></table></figure><p>然后到本地文件根目录下的<code>source</code>文件夹下的<code>_post</code>查看md文件</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201052118645.png" alt="新文档"></p><p>然后就开始使用Typora等Markdown编辑器编辑了。</p><p>写完要发布的话，键入</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">hexo clean<br></code></pre></div></td></tr></table></figure><p>清除旧文件(选择性，也可以不清除)。然后键入<code>hexo server -generate</code>或者<code>hexo s -g</code>生成，<code>s</code>可以在本地预览，就是点击<code>https://localhost:4000</code>进行预览。如果觉得可以了，就用<code>hexo deploy</code>或者<code>hexo d</code>进行部署。也可以直接写完后键入<code>hexo deploy -generate</code>或者<code>hexo d -g</code>生成与部署。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">hexo s -g<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">hexo d<br></code></pre></div></td></tr></table></figure><p>然后你的文章就可以分享给其他人了！虽然如此，但是博客往往是一个人的快乐，分不分享倒无所谓。</p><blockquote><p>注意：</p><p>生成md文件不一定要使用 hexo new post，也可以直接修改扩展名，使用hexo命令只是为了按照模板生成文件而已，模板在本地文件根目录 scaffold 文件夹中，可以自己修改模板，具体可以参照 Hexo<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://hexo.io/">[1]</span></a></sup> 官网和 Fluid<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://hexo.fluid-dev.com/">[4]</span></a></sup> 官网。</p></blockquote><hr><h1 id="后语"><a href="#后语" class="headerlink" title="后语"></a>后语</h1><p>搭个人博客是一件快乐的事情，现在的社交软件很发达，博客已经成了过去式。现在还在写博客的是有两种人：</p><ul><li>大佬，日浏览成百上千，把知识反哺社会。</li><li>菜鸡，日浏览只有自己，把记不住的堆放。</li></ul><p>很多人都是后者，例如我。然而奇葩的是，程序员也写博客，而且频率远高于其他职业。为什么呢？</p><p>程序员工作中会碰到各种各样的问题，如果只是百度是解决不了问题的。百度上面没几个人能回答技术性问题，所以程序员搭建个人博客：碰到问题，如果解决了就记下，以后忘了可以再来看。日积月累也就成了一个知识库。</p><p>这，这不就是学习吗？我们很多时候都会有问题，所谓<code>人非生而知之者，孰能无惑</code>，也许查一下<code>wiki</code>、<code>百度</code>就解决了，但是问题来得快忘得也快。那为什么不记下来，以便以后复习呢？</p><p>在我们的刻板印象里，程序员是不食人间烟火的技术大佬，除了<code>0101010</code>什么都不知道，但是他们却做着最文艺的事——用文字记录生活点滴。反过来看，我们才除了能生成刻板印象什么都不知道。</p><p>所以，为什么不记录自己的生活呢？</p><blockquote><p>Node.js</p><p>链接: <a href="https://www.123pan.com/s/gqA9-blYB">https://www.123pan.com/s/gqA9-blYB</a></p></blockquote><hr><h1 id="相关网址"><a href="#相关网址" class="headerlink" title="相关网址"></a>相关网址</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://hexo.io/">https://hexo.io/</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://github.com/">https://GitHub.com/</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://git-scm.com/">https://Git-scm.com/</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://hexo.fluid-dev.com/">https://hexo.fluid-dev.com/</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fluid</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typora+PicGo写作平台的搭建</title>
    <link href="/2022/01/03/typora%E4%B8%8Epicgo%E5%86%99%E4%BD%9C%E5%B9%B3%E5%8F%B0%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <url>/2022/01/03/typora%E4%B8%8Epicgo%E5%86%99%E4%BD%9C%E5%B9%B3%E5%8F%B0%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<blockquote><p>前前言：</p><p>2022 年 03 月 24 日</p><p>这天我的  Gitee 图床被屏蔽了，所以后面的这些教程，把它看作  GitHub 就行了。如果真个想使用  Gitee ，建议自己的图片做个备份，经常换仓库。不然要死直接全死。这里也要说明一下，写了封邮件之后，16 个小时左右仓库就解封了。不过解封归解封， Gitee 再见！</p><p>子曰：资本家的羊毛不可薅。</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> Typora 是优秀的本地写作软件，但是我们的文章可能不仅仅是保留在本地。有些时候我们会进行数据迁移，例如换一台电脑，或者发表到网上，我们会希望自己的图片只有一份，因为这样迁移的麻烦少了一个。图床是解决图片问题的最好方式。</p><blockquote><p>所谓 图床 ，就是把你的图片放到一个固定的地方(常指网络)，然后通过连接访问，这样要使用图片的时候，只需要知道图片的链接就行，不需要再保留一份。在   Markdown 写作中我们知道，使用图片的方式是<code>[图注](链接)</code>。因此，当用 Markdown 进行写作的时候，我建议配合图床使用——把图片保留在网络上而不是本地。</p></blockquote><p>现在可选的的图床很多，免费的、不免费的、国内的、国外的，但稳定的、普适的图床却很少。我用过的有 sm.ms 图床和  Gitee 。鉴于例如公众号这类平台有屏蔽外链的风险，我选择长期使用  Gitee 作为图床。  Gitee 是国内最大的代码托管平台，内部提供仓库 2g (2021年)。这存储空间够用了。当然，  GitHub 也可以作为选择，但是访问可能慢一点，而且空间也少一点。</p><p>闲话少叙，准备好工具：</p><ul><li>Gitee <sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://Gitee.com/">[1]</span></a></sup>账号</li><li>Typora <sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://Typora.io/">[2]</span></a></sup>编辑器，Markdown 写作</li><li>GicGo <sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://PicGo.GitHub.io/PicGo-Doc/zh/">[3]</span></a></sup>图床配置工具</li></ul><p>以上所需的工具都是免费的。</p><hr><h1 id="PicGo准备"><a href="#PicGo准备" class="headerlink" title="PicGo准备"></a>PicGo准备</h1><p> PicGo 是开源免费的图床配置工具，我一直在用。官网的介绍很清楚，如果有不清楚的可以看官网的文档。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051328651.png" alt="下载PicGo"></p><p>点击下载之后一直往下拉，找到最新版的下载软件，</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051335431.png" alt="找到最新版(就是最上面的一版)"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051337609.png" alt="下载指定版本"></p><p>下载之后就是简单的安装，安装完之后打开。</p><blockquote><p> 注意： </p><p> PicGo 打开的时候只在任务栏出现，所以去任务栏点击打开。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051338760.png" alt="打开PicGo"></p><p>因为 PicGo 没有内置  Gitee ，所以去插件设置查找  Gitee 的插件安装。这三种都差不多，选择第一个就像我这样。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051339134.png" alt="查找插件并下载"></p><p>插件安装的时候，系统会提示你安装 Node.js ，同意安装就行了。安装之后效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051756804.gif" alt="安装"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051755069.png" alt="安装node.js"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051344742.png" alt="安装插件效果"></p><p>好了， PicGo 准备好了，接下来准备白嫖  Gitee 的 2G 空间。</p><hr><h1 id="Gitee账号"><a href="#Gitee账号" class="headerlink" title="Gitee账号"></a>Gitee账号</h1><p>以下为申请  Gitee 账号，如已有，请跳至 仓库配置 。</p><h2 id="申请账号"><a href="#申请账号" class="headerlink" title="申请账号"></a>申请账号</h2><p>首先去  Gitee 官方网站，点击注册。注册使用的是邮箱，可以临时申请一个邮箱——但是必须可以接受消息，因为后面需要验证。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051319152.png" alt="官网注册"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051350833.png" alt="注册"></p><p>注册时需要用邮箱接收验证码，完成之后，登录进入主界面，创建新仓库：</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051352300.png" alt="创建仓库"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051354452.png" alt="创建仓库"></p><p>创建完成。</p><hr><h2 id="仓库配置"><a href="#仓库配置" class="headerlink" title="仓库配置"></a>仓库配置</h2><p>为了让 PicGo 行使生杀大权，我们需要给它一个令牌( token )，大概类似于一种权限。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051359935.png" alt="打开设置"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051401471.png" alt="私人令牌"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051401541.png" alt="生成新的令牌"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051402140.png" alt="描述可以写上一些信息"></p><p>注意，令牌生成的时候复制下来保管好，因为它只生成一次，忘了就得重新申请。这里我就不重新申请了。把令牌粘贴到 PicGo 的  Gitee 图床的 token 框。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051405605.png" alt="粘贴令牌"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051410924.png" alt="看图写话"></p><p>然后设置为默认图床，确定，万事大吉！！</p><hr><h3 id="配置Typora"><a href="#配置Typora" class="headerlink" title="配置Typora"></a>配置Typora</h3><p>默认已经安装了 Typora 了。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201051415186.png" alt="配置Typora"></p><p>至此，你完成了所有的配置。点击 验证图片上传选项 验证是否成功。如果出现问题，最好检查你的 PicGo 中的 repo 写对没有。</p><h1 id="验证写作"><a href="#验证写作" class="headerlink" title="验证写作"></a>验证写作</h1><p>我们验证一下效果：</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201031746951.gif" alt="上传图片" title="上传图片"></p><p>完成！</p><hr><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>借助图床，   Markdown 式的写作更加轻松，也节约了图片管理的时间。然而需要注意的是， PicGo 上传的图片大小最好不要超过 1M ，因为这会影响加载的速度。而且有些时候，你的图片可能会被  Gitee 吞掉，原因不明，也许是版权问题。</p><blockquote><p>PicGo 和 Typora 的安装包提供(无需登录，直接复制链接输入提取码即可):<br>链接: <a href="https://www.123pan.com/s/gqA9-llYB">https://www.123pan.com/s/gqA9-llYB</a>提取码:csym</p></blockquote><h1 id="相关网址"><a href="#相关网址" class="headerlink" title="相关网址"></a>相关网址</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://gitee.com/">https://Gitee.com/</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://typora.io/">https://Typora.io/</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://picgo.github.io/PicGo-Doc/zh/">https://PicGo.GitHub.io/PicGo-Doc/zh/</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图床</tag>
      
      <tag>Makrdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown与Typora</title>
    <link href="/2022/01/03/Markdown%E4%B8%8ETypora/"/>
    <url>/2022/01/03/Markdown%E4%B8%8ETypora/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="何为-Markdown？"><a href="#何为-Markdown？" class="headerlink" title="何为 Markdown？"></a>何为 Markdown？</h2><p>  Markdown(MD) 是一种轻量级的标记语言( markup language )。什么是标记语言？就是通过一些 标记 ，让你的文章具有一定的格式。让你专注于写字，而不是纠结于各种格式，它和 txt 文件都是纯文本格式，只要有一个文本编辑器。</p><h2 id="Markdown-编辑器"><a href="#Markdown-编辑器" class="headerlink" title="Markdown 编辑器"></a>Markdown 编辑器</h2><p> MD 只是给文字做标签，所以要写 MD 建议使用合适的编辑器。这里首推国产的 Typora 。理由如下：</p><ul><li>成熟。 Typora 已经存在六七年了，发展很快，支持很多功能。截至目前为止，除了不能插入文献以外，我找不到它的任何缺点。</li><li>可定制化。现在很多的 MD 编辑器也在往这方面发展， Typora 自然不例外。我不确定它是不是第一个把浏览器搬到笔记里的产品，但是它确实是我认识的第一个在笔记软件里可以使用浏览器功能的产品。</li><li>完美支持 MD 。甚至拓展 MD 。 MD 为了简便被设计得非常简单，有时也因此存在其不足。对此很多平台都对 MD 进行了拓展， Typora 也不例外。</li><li>所见即所得。 Typora 可以通过 MD 的标记，轻轻松松渲染文本。让你的文章看起来更加舒服。</li><li>配合 Pandoc 可导成各种格式。 Pandoc 是一个简单的文件格式转换器，支持几十种格式转换，特别是 MD 。我们的文章写完之后可以借助它导出成各种格式。</li></ul><p>下面是 Typora 中文网站<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.typora.io">[1]</span></a></sup>的 GIF 动图，这个网站和 Typora 一样简洁大方。可以通过文章给出的网址下载 Typora 。虽然现在的稳定版已经开始收费了，但是作者很良心，仍然提供beta版免费下载。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112211557226.gif" alt="Typora中文官网"></p><p> MD 的文件扩展名是”md”，你想写 MD 时只需把拓展名改成”md”即可。废话不多说，我们先来看  Markdown 的语法。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202201032015265.png" alt="文件名"></p><hr><h1 id="Markdown语法入门"><a href="#Markdown语法入门" class="headerlink" title="Markdown语法入门"></a>Markdown语法入门</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p> Word 通常支持1~6级标题， MD 也一样。 MD 的标题使用<code>#</code>作为标记。例如：</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Markdown"><span class="hljs-section"># 一级标题</span><br><span class="hljs-section">## 二级标题</span><br><span class="hljs-section">### 三级标题</span><br></code></pre></div></td></tr></table></figure><h3 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h3><p> MD 支持最高六级标题。在 Typora 中，标题的级数可以通过快捷键记忆：<code>ctrl+数字</code>，数字从 0 到 6 ，0 是正文，1~6 是标题。下面是演示：</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112211621673.gif" alt="标题输入"></p><p>如果只是单纯想要输入<code>#</code>怎么办？很简单，你只需要把<code>#</code>输入到反引号(“`“)之间即可,如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">`#`<br></code></pre></div></td></tr></table></figure><p>我使用暗主题，所以 GIF 才是黑色的， Typora 内置几种主题都非常好看：</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112211627694.png" alt="Github主题"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112211627315.png" alt="newprint主题"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112211628105.png" alt="我自己的主题"></p><hr><h2 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h2><p>加粗很简单，文字左右各放一个<code>**</code>即可：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">**加粗**<br></code></pre></div></td></tr></table></figure><h3 id="效果如下"><a href="#效果如下" class="headerlink" title="效果如下"></a>效果如下</h3><p><strong>加粗</strong></p><p>快捷键是 <code>ctrl+b</code>。</p><hr><h2 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a><em>斜体</em></h2><p>斜体和加粗很相似，只需文字左右各放一个<code>*</code>即可：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">*斜体*<br></code></pre></div></td></tr></table></figure><h3 id="效果如下-1"><a href="#效果如下-1" class="headerlink" title="效果如下"></a>效果如下</h3><p><em>斜体</em></p><p>快捷键是<code>ctrl+i </code>(斜体是 italic)，所以快捷键是<code>i</code>)</p><h3 id="动图演示-1"><a href="#动图演示-1" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112211643630.gif" alt="斜体演示"></p><hr><p> <em>斜体</em> <strong>加粗</strong>叠加使用即可:</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Markdown"><span class="hljs-strong">**<span class="hljs-emphasis">*斜体加粗*</span>**</span><br></code></pre></div></td></tr></table></figure><p>快捷键也叠加：<code>ctrl+i+b</code></p><hr><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a><del>删除线</del></h2><p>删除线，把文字左右各放一个<code>~~</code>即可。如下:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">~~删除线~~<br></code></pre></div></td></tr></table></figure><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><del>删除线</del></p><p>快捷键比较奇葩：<code>atl+shift+5</code></p><h3 id="动图演示-2"><a href="#动图演示-2" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112212038552.gif" alt="删除线演示"></p><hr><h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a><u>下划线</u></h2><p>下划线建议使用快捷键<code>ctrl+u</code>，因为下划线 MD 不支持，但是 Typora 有这个快捷键，使用 HTML 渲染。当然，你也可以使用这个标签<code>&lt;u&gt;&lt;/u&gt;</code>手动输入。</p><hr><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>超链接使用这样的语法:</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Markdown">[<span class="hljs-string">文字</span>](<span class="hljs-link">链接</span>)<br></code></pre></div></td></tr></table></figure><p>方框中是你的文字，括号里边是你的链接。快捷键是 <code>ctrl+k</code></p><h3 id="动图演示-3"><a href="#动图演示-3" class="headerlink" title="动图演示"></a>动图演示</h3><p> <img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112211655668.gif" alt="添加链接"></p><hr><h2 id="添加图片"><a href="#添加图片" class="headerlink" title="添加图片"></a>添加图片</h2><p>对的没错！ MD 虽然是纯文本文件，但是人家可以添加图片！方法类似添加链接：</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Markdown">添加图片<br>![<span class="hljs-string">图注</span>](<span class="hljs-link">图片链接/地址</span>)<br></code></pre></div></td></tr></table></figure><p>就是在添加链接的前面添加一个感叹号而已。快捷键是 <code>ctrl+shift+i</code></p><p>效果就不用展示了，我的文章就是 MD 写的，里边的图片自然就是这样添加的。手打地址或者链接肯定麻烦，所以 Typora 可以直接拖拽添加，配合图床使用简直不要太舒服！！</p><h3 id="动图演示-4"><a href="#动图演示-4" class="headerlink" title="动图演示"></a>动图演示</h3><p>找张温馨一点的图：</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112211711892.gif" alt="直接拖拽"></p><p>这个方式还可以添加 GIF、视频等。</p><hr><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>分割线就跟简单了，就像上面这条分割线就是 MD 的标记，单个短杆<code>-</code>：</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Markdown">---<br></code></pre></div></td></tr></table></figure><h3 id="动图演示-5"><a href="#动图演示-5" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112211724390.gif" alt="分割线"></p><hr><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表很好玩，也很简单。</p><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>无序列表使用<code>-</code>加上一个空格，如下:</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Markdown"><span class="hljs-bullet">-</span> 第一个<br><span class="hljs-bullet">-</span> 二级无序列表<br><span class="hljs-bullet">-</span> 第二个<br><span class="hljs-bullet">-</span> 第三个<br></code></pre></div></td></tr></table></figure><h4 id="效果如下-2"><a href="#效果如下-2" class="headerlink" title="效果如下"></a>效果如下</h4><p>无序列表</p><ul><li>第一个<ul><li>二级无序列表</li></ul></li><li>第二个</li><li>第三个</li></ul><p>快捷键: <code>ctrl+shift+]</code>。</p><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>有序列表只需要使用阿拉伯数字加上一个小点(dot)和一个空格:</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Markdown"><span class="hljs-bullet">1.</span> 一级列表<br><span class="hljs-bullet">1.</span> 二级列表<br><span class="hljs-bullet">2.</span> 一级列表<br><span class="hljs-bullet">3.</span> 一级列表<br></code></pre></div></td></tr></table></figure><h4 id="效果如下-3"><a href="#效果如下-3" class="headerlink" title="效果如下"></a>效果如下</h4><p>有序列表</p><ol><li>一级列表<ol><li>一级列表</li></ol></li><li>一级列表</li><li>一级列表</li></ol><p>快捷键：<code>ctrl+shift+[</code>。</p><h3 id="动图演示-6"><a href="#动图演示-6" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112211734121.gif" alt="列表演示"></p><h2 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h2><p>任务列表很简单，就是<code>-空格[空格]空格文字</code>表示 未完成 ，<code>-空格[x]空格文字</code>表示 完成 。</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Markdown">未完成<br><span class="hljs-bullet">-</span> [] 明天好好复习<br><br>完成<br><span class="hljs-bullet">-</span> [x] 待会好好吃饭<br></code></pre></div></td></tr></table></figure><h3 id="效果如下-4"><a href="#效果如下-4" class="headerlink" title="效果如下"></a>效果如下</h3><ul><li><input disabled="" type="checkbox"> 明天好好复习</li><li><input checked="" disabled="" type="checkbox"> 待会好好吃饭</li></ul><h3 id="动图演示-7"><a href="#动图演示-7" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112220919301.gif" alt="任务列表"></p><p>可以看到， Typora 是有交互功能的，任务列表可以点击，就像表格一样。</p><hr><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>当你想引用别人的一句名言时，就可使用引用了。引用的格式也比较简单：一个尖括号加空格，然后就是名言—— <code>&gt; 名言</code></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">&gt; 子曰：君子不器。<br></code></pre></div></td></tr></table></figure><h3 id="效果如下-5"><a href="#效果如下-5" class="headerlink" title="效果如下"></a>效果如下</h3><blockquote><p>子曰：君子不器。</p></blockquote><p>快捷键：要个啥快捷键？？</p><h3 id="动图演示-8"><a href="#动图演示-8" class="headerlink" title="动图演示"></a>动图演示</h3><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112212044977.gif" alt="引用演示"></h3><hr><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>表格比较重要了。 MD 标准的没有表格，但是拓展的 MD 是有的。格式比较神奇：</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Markdown">|姓名|身份|排行|<br>|:---|:---:|---:|<br>|左对齐|中间对齐|右对齐|<br>|刘备|皇叔|老大|<br>|关羽|商户|老二|<br>|张飞|屠户|老三|<br></code></pre></div></td></tr></table></figure><p><code>|---|---|---|</code>以上是表头 ，以下是表身 ，冒号<code>:</code>表示对齐方式(下面没有展示出来，下面都是居中对齐)。</p><h3 id="效果如下-6"><a href="#效果如下-6" class="headerlink" title="效果如下"></a>效果如下</h3><table><thead><tr><th align="center">姓名</th><th align="center">身份</th><th align="center">排行</th></tr></thead><tbody><tr><td align="center">刘备</td><td align="center">皇叔</td><td align="center">老大</td></tr><tr><td align="center">关羽</td><td align="center">商户</td><td align="center">老二</td></tr><tr><td align="center">张飞</td><td align="center">屠户</td><td align="center">老三</td></tr></tbody></table><p>快捷键是 <code>ctrl+t</code>。谁都不会亲手去打这个表格，所以直接使用快捷键。</p><h3 id="动图演示-9"><a href="#动图演示-9" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112212057001.gif" alt="表格演示"></p><p> Typora 里边处理表格很舒服，此外还可以通过自定义的 CSS 改变表格格式：</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112212059948.gif" alt="不同主题中的表格"></p><h2 id="注脚"><a href="#注脚" class="headerlink" title="注脚"></a>注脚</h2><p>格式是<code>[^ 数字]</code>。</p><figure class="highlight lua"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lua">鲁迅说：我没说过[^<span class="hljs-number">4</span>]。<br><br><br><span class="hljs-comment">---------------</span><br>假设这里是篇末<br><span class="hljs-comment">---------------</span><br>[^<span class="hljs-number">4</span>]: 《狂人日记》，p250.<br></code></pre></div></td></tr></table></figure><h3 id="效果如下-7"><a href="#效果如下-7" class="headerlink" title="效果如下"></a>效果如下</h3><p>鲁迅说：我没说过<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="《狂人日记》，p250.">[4]</span></a></sup>。</p><h3 id="动图演示-10"><a href="#动图演示-10" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112212108251.gif" alt="庄子曰"></p><hr><p>我知道大家觉得这个很无聊，毕竟码字谁都会，但是我下面介绍的东西，理科生和文科生就该提起精神了，因为这会挑战你们做笔记的速度。</p><h2 id="画图——文科生"><a href="#画图——文科生" class="headerlink" title="画图——文科生"></a>画图——文科生</h2><p>首先声明， MD 不支持绘图，但是现在我们使用的是 Typora ，它集成了 MD 里绘图的语言： Mermaid 。是的，美人鱼。在 MD 里使用某种(编程)语言的时候，都要放到一对```里边，如下：</p><p>使用python<br>```python<br>import nothing</p><p>print(nothing)<br>```</p><p>使用C++<br>```cpp<br>#include &lt;iostream&gt;</p><p>int main(int argc, char const* argv[]){<br>    return 0;<br>}<br>```</p><p>使用lua<br>```lua<br>local cos &#x3D; math.cos<br>local print &#x3D; print<br>_ENV &#x3D; nil<br>```</p><p>所以使用 Mermaid 的时候，也需要这样使用</p><p>```mermaid</p><p>```</p><p>可以使用快捷键 <code>ctrl+shift+k</code> 快速插入代码。</p><h3 id="动图演示-11"><a href="#动图演示-11" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112212125411.gif" alt="使用编程语言"></p><hr><p> Mermaid 支持的绘图格式很多，包括时序图 、甘特图 、饼图和流程图等。下面主要讲解饼图 、时序图和流程图 。</p><h3 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h3><p>我们使用 Mermaid 画图，所以先进入 Mermaid :</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112212129599.png" alt="写代码的地方"></p><p>如果我们要画 饼图 ，我们需要在首行标注饼图（刚考过六级，饼图怎么说？ cookie chart ? 非也： pie ）。</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">pie<br><span class="hljs-code">title 为什么总是宅在宿舍？</span><br><span class="hljs-code">&quot;没有npy&quot;: 30</span><br><span class="hljs-code">&quot;太冷了&quot;: 12</span><br><span class="hljs-code">&quot;遭被子残忍封印&quot;: 5</span><br><span class="hljs-code">&quot;穷&quot;: 500</span><br></code></pre></div></td></tr></table></figure><h4 id="效果如下："><a href="#效果如下：" class="headerlink" title="效果如下："></a>效果如下：</h4><pre><code class=" mermaid">pietitle 为什么总是宅在宿舍？&quot;没有npy&quot;: 30&quot;太冷了&quot;: 18&quot;遭被子残忍封印&quot;: 12&quot;穷&quot;: 500</code></pre><h4 id="动图演示-12"><a href="#动图演示-12" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112212212114.gif" alt="饼图演示"></p><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p>流程图的画法主要有两种:  Mermaid 中的 Graph 和 Flowchart 。先介绍 Graph 。</p><h4 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h4><p>主要是方向性。你的流程图如果从左( Left)到右( Right)，那就再首行写下 <code>graph LR</code>(反之<code>graph RL</code>)，如果是上( Top)到下(Down)就是<code>graph TD</code>(反之 <code>graph BT</code>,  bottom top)。使用两个短杆加小于号<code>–&gt;</code>表示方向。</p><p>方向：</p><ul><li><code>--&gt;</code>表示直线</li><li><code>-.-&gt;</code>表示虚线</li><li><code>--文字--&gt;</code>表示实线标签</li><li><code>-.文字.-&gt;</code>表示虚线标签</li></ul><p>方框:</p><ul><li>纯文字，默认<code>方框</code></li><li>id(文字)，<code>圆角</code>。所谓<code>id</code>就是给名字找一个方便记忆的id</li><li>id[()]，<code>圆柱</code></li><li>id([])，<code>椭圆</code></li><li>id{}，<code>菱形</code></li><li>等等</li></ul><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">graph TD<br><span class="hljs-code">夏明--&gt;大东</span><br><span class="hljs-code">夏明-.-&gt;大东</span><br><span class="hljs-code">夏明--标签--&gt;大东</span><br><span class="hljs-code">夏明-.标签.-&gt;大东</span><br></code></pre></div></td></tr></table></figure><h4 id="效果如下-8"><a href="#效果如下-8" class="headerlink" title="效果如下"></a>效果如下</h4><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112212235419.png" alt="graph演示"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112212238193.png" alt="方框格式"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112212242594.png" alt="各种格式"></p><p>因为是介绍，所以不会太深入了。</p><h4 id="Flowchart"><a href="#Flowchart" class="headerlink" title="Flowchart"></a>Flowchart</h4><p> Flowchart 和 Graph 差不多，但是更加丝滑：</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">flowchart TD<br><span class="hljs-code">%% subgraph 是子图</span><br><span class="hljs-code">subgraph Left</span><br><span class="hljs-code">男主--&gt;铃兰一中</span><br><span class="hljs-code">end</span><br><span class="hljs-code"></span><br><span class="hljs-code">subgraph Right</span><br><span class="hljs-code">女主--&gt;快乐星球</span><br><span class="hljs-code">end</span><br><span class="hljs-code">   </span><br><span class="hljs-code">女主 --x 铃兰一中</span><br><span class="hljs-code">男主 --x 快乐星球</span><br><span class="hljs-code"></span><br><span class="hljs-code">Left--&gt;南开大学</span><br><span class="hljs-code">Right--&gt;南开大学</span><br></code></pre></div></td></tr></table></figure><h4 id="效果如下-9"><a href="#效果如下-9" class="headerlink" title="效果如下"></a>效果如下</h4><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112212245690.png" alt="flowchart"></p><h4 id="插个时序图"><a href="#插个时序图" class="headerlink" title="插个时序图"></a>插个时序图</h4><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">sequenceDiagram<br><span class="hljs-code">participant Alice</span><br><span class="hljs-code">participant Bob</span><br><span class="hljs-code">participant Hohn</span><br><span class="hljs-code">Alice-&gt;&gt;Hohn: Hello Hohn, how are you ?</span><br><span class="hljs-code">loop HealthCheck</span><br><span class="hljs-code">Hohn-&gt;&gt;Hohn: Fight against hypochondria</span><br><span class="hljs-code">    end</span><br><span class="hljs-code">    Note right of Hohn: Rational thoughts &lt;br/&gt;prevail</span><br><span class="hljs-code">    Hohn--&gt;&gt;Alice:Greate!</span><br><span class="hljs-code">    Hohn-&gt;&gt;Bob: How about you?</span><br><span class="hljs-code">    Bob--&gt;&gt;Hohn: Jolly good</span><br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112221044616.png" alt="时序图"></p><h2 id="公式——理科生"><a href="#公式——理科生" class="headerlink" title="公式——理科生"></a>公式——理科生</h2><p>写数学公式是物理数学同学不可避免地悲剧，使用 Word 记录的话直接就是死亡，所以很多人使用手写(电子笔记)。但是我想说， MD 可以救你。</p><p>公式使用 $L_EX$ 渲染，所以还是很好玩地。行内公式左右各一个 <code>$</code> ，独立公式则用两个 <code>$$</code> 。如下：</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Markdown">$$ <br>\sum^&#123;x \to \infty&#125;<span class="hljs-emphasis">_&#123;y \to 0&#125;&#123;\frac&#123;x&#125;&#123;y&#125;&#125; </span><br><span class="hljs-emphasis">$$</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">$ \alpha $</span><br></code></pre></div></td></tr></table></figure><h4 id="效果如下-10"><a href="#效果如下-10" class="headerlink" title="效果如下"></a>效果如下</h4><p>$$<br>\sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}<br>$$</p><p>$ \alpha $</p><p>不过我使用的不多，大家要是感兴趣地话可以去查查，随便百度就可以找到很多教程的。我这里浅尝辄止。</p><h2 id="上下标和高亮"><a href="#上下标和高亮" class="headerlink" title="上下标和高亮"></a>上下标和高亮</h2><p>上下标和高亮是 Typora 支持的，其他编辑器未必支持。</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">上标 X^2^<br>下标 O~2~<br>高亮 ==中国==<br></code></pre></div></td></tr></table></figure><h3 id="效果如下-11"><a href="#效果如下-11" class="headerlink" title="效果如下"></a>效果如下</h3><p>上标 $X^2$</p><p>下标 $O_2$</p><p>高亮 <mark>中国</mark></p><p>需要在 Typora 中打开：</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112212301341.png" alt="拓展语法"></p><hr><h1 id="Markdown回顾"><a href="#Markdown回顾" class="headerlink" title="Markdown回顾"></a>Markdown回顾</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>  Markdown 是一门轻量级的标记语言，可以通过几个简单的标记让你的文章具有一定的格式。Markdown 写出来的文章和笔记本质上只是纯文本，通过笔记软件或者一些网站渲染，可以展现不同的效果，可以让你专心于写作而不担心排版问题。</p><h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><p>网络平台或者软件、网址进行渲染。</p><p>目前大多数的笔记平台(有道等)、博客平台(知乎、博客园等)、思维导图(Xmind、百度脑图等)都支持  Markdown ，除了被诟病的 wx 公众号。公众号不支持  Markdown ，但是仍然有很多人开发了很多地接入公众号的工具，基本都是网页工具，可以实现软件写完之后复制到公众号即可——例如我就是这样，本地写完，导出 HTML 文件，复制到公众号即可。</p><h2 id="语法和Typora快捷键"><a href="#语法和Typora快捷键" class="headerlink" title="语法和Typora快捷键"></a>语法和Typora快捷键</h2><ol><li><p>标题</p><p>使用井号<code>#空格标题</code>，几个井号就是几级标题。快捷键:<code>ctrl+数字(0-6)</code>。</p><p>例如：<code># 一级标题</code>、<code>## 二级标题</code></p></li><li><p>加粗</p><p>文字左右各放一个<code>**</code>。快捷键是<code>ctrl+b</code>。</p><p>例如：<code>**我是249+1**</code></p></li><li><p>斜体</p><p>文字左右各放一个<code>*</code>。快捷键<code>ctrl+i</code>。</p><p>例如：<code>*学名需要斜体，因为人家是拉丁文*</code></p></li><li><p>删除线</p><p>文字左右各放一个<code>~~</code>。快捷键是<code>alt+shift+5</code>。</p><p>例如：<code>~~我是大聪明~~</code></p></li><li><p>下划线</p><p>文字放到<code>&lt;u&gt;&lt;/u&gt;</code>标签里边。快捷键<code>ctrl+u</code>。</p><p>例如：<code>&lt;u&gt;这道题要考&lt;/u&gt;</code></p></li><li><p>超链接和图片</p><p>方括号<code>[]</code>里边放文字或者图注，紧接着括号<code>()</code>里边放网址或者图片地址。快捷键：超链接<code>ctrl+k</code>;图片<code>ctrl+shift+i</code>。实在懒，直接拖拽。</p><p>例如：<code>[7k7k](www.7k7k.com)</code>、<code>[图片](D:/user/pictures/atl.jpg)</code></p></li><li><p>分割线</p><p>三个短杆<code>-</code>即可，没有快捷键。</p><p>例如: <code>---</code></p></li><li><p>列表</p><p> 有序列表 使用阿拉伯数字加点(dot)加空格(space)加文字。快捷键<code>ctrl+shift+[</code></p><p> 无序列表 使用短杆<code>-</code>加空格(space)加文字。快捷键<code>ctrl+shift+]</code></p><p>例如：<code>1. 第一项</code>、<code>- 列举</code></p></li><li><p>任务列表</p><p> 已完成 使用短杆<code>-</code>加空格(space)加方括号包围的x<code>[x]</code>加空格(space)加文字。</p><p> 未完成 使用短杆<code>-</code>加空格(space)加方括号包围的空格(space)<code>[ ]</code>加空格加文字。</p><p>例如：<code>- [ ] 未完成 </code>、<code>- [x] 完成了</code></p></li><li><p>引用</p><p>使用右尖括号<code>&gt;</code>加空格(space)加文字。</p><p>例如：<code>&gt; 子曰: 吾知子知吾不知子知吾知。</code></p></li><li><p>表格</p><p>短杆和竖杠排列，这个，建议直接使用快捷键<code>ctrl+t</code>。</p></li><li><p>注脚</p><p>方括号<code>[]</code>里边放<code>^</code>和数字。</p><p>例如：</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.typora.io">[1]</span></a></sup><br></code></pre></div></td></tr></table></figure></li><li><p>画图和公式</p><p>画图放到代码编辑块里边。快捷键：<code>ctrl+shift+k</code>，选择<code>mermaid</code>。</p><p>公式左右各放一个 <code>$</code> 或者 <code>$$</code> ，前者是行内公式，后者是块公式。</p><p>例如：</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ x^2 $<br>    <br>$$ <br><span class="hljs-built_in">sum</span>^&#123;x \to 100&#125;_&#123;x=0&#125; <br>$$<br></code></pre></div></td></tr></table></figure><ol start="14"><li><p>上下标和高亮</p><p>这是 Typora 的拓展，上边使用<code>^</code>包围，下标使用<code>~</code>包围，高亮使用<code>==</code>包围。</p><p>例如：<code>X^2^</code>、<code>O~2~</code>、<code>==收到==</code></p></li></ol><hr><h1 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h1><p> Typora <sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.typora.io">[1]</span></a></sup>官网可以下载 Beta 版，免费使用。作为一款优秀的  Markdown 笔记软件，无可挑剔，但是需要配合 Pandoc (导出任何格式，导出 PDF 需配合 $L_EX$ )使用。建议先安装 Pandoc 再安装 Typora 。</p><p> Typora 包含几个主题，有需要的也可以上网查找相关主题，甚至自己设置自己的主题——它支持 CSS 格式，只要自己会写就行。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>简单安装即可，确认到底。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112221005761.gif" alt="安装Typora"></p><h2 id="Pandoc"><a href="#Pandoc" class="headerlink" title="Pandoc"></a>Pandoc</h2><p> Pandoc <sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://pandoc.org">[2]</span></a></sup> 官网下载。如果电脑上不去，可以使用手机。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112221009185.png" alt="pandoc官网"></p><h2 id="设置-Pandoc-路径"><a href="#设置-Pandoc-路径" class="headerlink" title="设置 Pandoc 路径"></a>设置 Pandoc 路径</h2><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112221012699.png" alt="设置路径"></p><h2 id="如果需要导出成PDF"><a href="#如果需要导出成PDF" class="headerlink" title="如果需要导出成PDF"></a>如果需要导出成PDF</h2><p>如果要导出成 PDF ，建议安装$MiKT_EX$<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://miktex.org">[3]</span></a></sup>。安装有任何问题可以上网查找问题。</p><hr><h1 id="导出效果"><a href="#导出效果" class="headerlink" title="导出效果"></a>导出效果</h1><p>下面可以看看我的导出结果。因为我的这篇文章也是使用 Typora 写的，所以恰好可以看看。</p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112221019439.png" alt="暗夜模式"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112221020894.png" alt="推送主题"></p><h2 id="导出-PDF"><a href="#导出-PDF" class="headerlink" title="导出 PDF"></a>导出 PDF</h2><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112221021120.png" alt="导出"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112221021774.png" alt="pdf效果"></p><h2 id="导出-Word-文档"><a href="#导出-Word-文档" class="headerlink" title="导出 Word 文档"></a>导出 Word 文档</h2><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112221023441.png" alt="导出word"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112221024813.png" alt="导出效果"></p><h2 id="导出到公众号"><a href="#导出到公众号" class="headerlink" title="导出到公众号"></a>导出到公众号</h2><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112221024245.png" alt="公众号是html格式复制"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112221026210.png" alt="浏览器预览"></p><p><img src="https://cdn.jsdelivr.net/gh/chunshuyumao/202203bf@master/202112221027377.png" alt="复制到公众号"></p><p>至于 MD 效果如何，想必大家看完我的文章就知道了。</p><h1 id="相关网址"><a href="#相关网址" class="headerlink" title="相关网址"></a>相关网址</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.typora.io/">https://www.typora.io</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://pandoc.org/">https://pandoc.org</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://miktex.org/">https://miktex.org</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>《狂人日记》，p250.<a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
